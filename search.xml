<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2023%2F09%2F15%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2022%2F08%2F22%2FDjango%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程范式]]></title>
    <url>%2F2022%2F07%2F25%2F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[编程范式：指的是编程世界里的各种流派，有：面向过程、函数式、面向对象等。 面向过程面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤。详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。 优点：将复杂的问题流程化，进而简单化 缺点：程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题，改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕 应用场景：一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。 函数式函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础]]></title>
    <url>%2F2022%2F06%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[计算机基础科普扫盲 计算机体系的三层结构我们开发应用程序本质是在控制硬件，但是我们直接打交道的是操作系统，应用程序都是通过操作系统来间接地操作硬件的 计算机硬件 cpu存取的数据和指令都来自于内存 内存称之为主存,主存储器内的数据则是从输入单元所传输进来！而CPU处理完毕的数据也必须先写回主存储器中，最后数据才从主存储器传输到输出单元。 cpu相关cpu：控制器+运算器控制器：计算机的指挥系统，负责控制计算机所有其他组件如何工作的运算器：运算包括数学运算与逻辑运算寄存器：cpu访问内存以得到指令或数据的时间比cpu执行指令花费的时间要长得多，所以，所有CPU内部都有一些用来保存关键变量和临时数据的寄存器，与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延 指令集，在超大规模集成电路构成的微型计算机中，往往将CPU制成一块具有特定功能的芯片，称为微处理器，芯片里边有编写好的微指令集,我们在主机上的所有操作或者说任何软件的执行最终都要转化成cpu的指令去执行,如输入输出，阅读，视频，上网等这些都要参考CPU是否内置有相关微指令集才行。如果没有那么CPU无法处理这些操作。 x86-64 x86，是针对cpu的型号或者说架构的一种统称，详细地讲，最早的那颗Intel发明出来的CPU代号称为8086，后来在8086的基础上又开发出了80285、80386….，因此这种架构的CPU就被统称为x86架构了。由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人计算机上面，因此，个人计算机常被称为x86架构的计算机！程序员开发出的软件最终都要翻译成cpu的指令集才能运行，因此软件的版本必须与cpu的架构契合。软件名字中有x86，这其实就是告诉我们：该软件应该运行在x86架构的计算机上。 64位，cpu的位数指的是cpu一次性能从内存中取出多少位二进制指令，64bit指的是一次性能从内存中取出64位二进制指令。cpu具有向下兼容性，指的是64位的cpu既可以运行64位的软件，也可以运行32位的软件，而32位的cpu只能运行32位的软件。 内核态与用户态代表cpu的两种工作状态 内核态：运行的程序是操作系统，可以操作计算机硬件 用户态：运行的程序是应用程序，不能操作计算机硬件 内核态与用户态的转换，应用程序的运行必然涉及到计算机硬件的操作，那就必须有用户态切换到内核态下才能实现，所以计算机工作时在频繁发生内核态与用户态的转换 多线程与多核芯片2核4线程（假4核）：2核代表有两个cpu，4线程指的是每个cpu都有两个线程4核8线程（假8核）：4核代表有4个cpu，8线程指的是每个cpu都有两个线程 进程是资源单位而线程才是cpu的执行单位。多线程运行cpu保持两个不同的线程状态，可以在纳秒级的时间内来回切换，速度快到你看到的结果是并发的，伪并行的，然而多线程不提供真正的并行处理，一个cpu同一时刻只能处理一个进程（一个进程中至少一个线程） 存储器相关计算机的记忆功能，负责数据的存取，分类如下 内存(主存)（基于电工作）：存取数据都快，断电数据丢失，只能临时存取数据 RAM：内存 ROM：“只读内存”，存放计算机厂商写死计算机上的一段核心程序(BIOS) CMOS：存取速度慢，断电数据丢失，耗电量极低 外存（固态硬盘，机械硬盘：基于磁工作，磁带）：存取速度都慢，断电数据也不丢，可以永久保存数据 磁带（常见于大型数据库系统中）：在价钱相同的情况下比硬盘拥有更高的存储容量，虽然速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。 机械硬盘相关如下 磁道：一圈数据，对应着一串二进制（1bit代表一个二进制位）8bit比特位=1Bytes字节，1024Bytes=1KB 扇区：一个扇区通常为512Bytes，站在硬盘的解读，一次性读写数据的最小单为为扇区 柱面 机械硬盘的IO延迟：平均寻道时间+平均延迟时间 平均寻道时间：机械手臂转到数据所在磁道需要花费的时间，受限于物理工艺水平，目前机械硬盘可以达到的是5ms 平均延迟时间：转半圈需要花费4ms，受限于硬盘的转速 优化程序运行效率的一个核心法则：能从内存取数据，就不要从硬盘取 虚拟内存机制 虚拟内存机制，是指将正在使用的程序放入内存去执行，而暂时不需要执行的程序放到磁盘的某块地方，这块地方成为虚拟内存。 虚拟内存机制的核心，在于快速地映射内存地址，由cpu中的一个部件负责——存储器管理单元(Memory Management Unit MMU)。 许多计算机支持虚拟内存机制，使计算机可以运行大于物理内存的程序，在linux中称为swap， 从一个程序切换到另外一个程序，称为上下文切换(context switch)，缓存和MMU的出现提升了系统的性能，尤其是上下文切换 I/O设备I/O设备:设备本身+设备的控制器（主板上的一块芯片或一组芯片） 输入设备input：如键盘、鼠标 输出设备output：显示器、打印机 操作系统操作系统是一个协调、管理、控制计算机硬件资源与应用软件资源的一个控制程序，作用： 控制计算机硬件的基本运行 把使用硬件的复杂操作封装成简单的功能，给上层的应用程序使用 操作系统一次性读写的单位是一个block块（一般默认设置为8扇区的大小=4096Bytes)，优化操作系统可以考虑修改block块的大小设置 操作系统启动流程 计算机加电 BIOS开始运行，检测硬件：cpu、内存、硬盘等 BIOS读取CMOS存储器中的参数，选择启动设备 从启动设备上读取第一个扇区的内容（MBR主引导记录512字节，前446为引导信息，后64为分区信息，最后两个为标志位） 根据分区信息读入bootloader启动装载模块，启动操作系统 然后操作系统询问BIOS，以获得配置信息。对于每种设备，系统会检查其设备驱动程序是否存在，如果没有，系统则会要求用户按照设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始有关的表格（如进程表），穿件需要的进程，并在每个终端上启动登录程序或GUI BIOS(Basic Input Output System)，被写入ROM设备裸机：CPU+ROM(充当内存，存放BIOS系统)+CMOS(充当硬盘) 文件文件是操作系统提供给应用程序来操作硬盘的虚拟概念，用户或应用程序对文件的操作，就是向操作系统发起调用，然后由操作系统完成对硬盘的具体操作。 应用程序 应用程序分为两种 应用软件：应用程序相关逻辑 系统软件：控制底层硬件的 应用程序的启动流程 双击exe快捷方式(即告诉操作系统应用程序的文件路径) 操作系统根据文件路径找到程序在硬盘的位置，控制其代码从硬盘加载到内存 然后控制cpu从内存中读取刚刚读入内存的应用程序的代码，执行指令 应用程序完成启动 平台与跨平台 平台：计算机硬件+操作系统 软件的跨平台性指的是：一款软件可以任意平台上运行，是衡量软件质量高低的一个非常重要的指标 字符编码 ASCII 只有英文字符与数字的一一对应关系 一个英文字符对应1Bytes，1Bytes=8bit，8bit最多包含256个数字，可以对应256个字符，足够表示所有英文字符 GBK 只有中文字符、英文字符与数字的一一对应关系 一个英文字符对应1Bytes 一个中文字符对应2Bytes unicode 兼容万国字符，与万国字符都有对应关系 内存中是unicode编码的 一个字符对应2Bytes，中文中个别生僻会采用4Bytes、8Bytes unicode更像是一个过渡版本，用于兼容其他非utf-8的老编码存储数据 utf-8: unicode的转换格式，unicode固定使用两个字节来存储一个字符，所以存放英文字符时，unicode格式会额外占用一倍空间，传输时也会额外耗费一倍的时间，所以unicode二进制写入硬盘或者基于网络传输时转化为更精简的格式，即utf-8 一个英文字符对应1Bytes 一个中文字符对应3Bytes 其他 Shift_JIS：只有日文字符、英文字符与数字的一一对应关系 Euc-kr：只有韩文字符、英文字符与数字的一一对应关系 解码和编码 内存中的unicode转换成字符，以及由unicode转换成其他编码的过程，都称为编码encode 由字符转换成内存中的unicode，以及由其他编码转换成unicode的过程，都称为解码decode 内存固定使用unicode，我们可以改变的是存入硬盘采用格式 老的字符编码都可以转换成unicode，但是不能通过unicode互转 由内存写入硬盘时，必须将编码格式设置为支持所输入字符的编码格式 由硬盘读入内存时，必须采用与写入硬盘时相同的编码格式 内存 人类的字符———unicode格式的数字———- | | | | | 硬盘 | | | | | | GBK格式的二进制 Shift-JIS格式的二进制]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue3]]></title>
    <url>%2F2022%2F02%2F21%2Fvue3%2F</url>
    <content type="text"><![CDATA[vue3采用typescript开发，对ts支持有好 源码体积优化，移除部分api，使用tree-shaking 数据劫持优化，vue3采用proxy，性能提高 编译优化，vue3实现静态模板分析，重写diff算法 CompositionApi，整合业务代码逻辑，提取公共逻辑（vue2采用mixin） 自定义渲染器，改写vue底层渲染逻辑 新增Fragment、Teleport、Suspense组件]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9种常见跨域手段]]></title>
    <url>%2F2022%2F02%2F13%2F9%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[jsonp12345678910111213141516171819202122232425function jsonp(&#123;url,params,cb&#125;) &#123; return new Promise((resolve,reject)=&gt;&#123; let script = document.createElement('script'); window[cb] = function (data) &#123; resolve(data); document.body.removeChild(script); &#125; params = &#123;...params,cb&#125; // wd=b&amp;cb=show let arrs = []; for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script); &#125;); &#125; // 只能发送get请求 不支持post put delete // 不安全 xss攻击 不采用 jsonp(&#123; url: 'http://localhost:3000/say', params:&#123;wd:'hello'&#125;, cb:'show' &#125;).then(data=&gt;&#123; console.log(data); &#125;); cors 后台配置允许123456789101112131415161718192021222324let express = require('express');let app = express();let whitList = ['http://localhost:3000']app.use(function (req,res,next) &#123; let origin = req.headers.origin; if(whitList.includes(origin))&#123; // 设置哪个源可以访问 res.setHeader('Access-Control-Allow-Origin', origin); // 允许携带哪个头访问 res.setHeader('Access-Control-Allow-Headers','name'); // 允许哪个方法访问 res.setHeader('Access-Control-Allow-Methods','PUT'); // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true); // 预检的存活时间 res.setHeader('Access-Control-Max-Age',6); // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name'); if(req.method === 'OPTIONS')&#123; res.end(); // OPTIONS请求不做任何处理 &#125; &#125; next();&#125;); postMessage 页面间跨域通信12345678910111213141516171819&lt;!-- http://localhost:3000/a.html--&gt;&lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt;&lt;script&gt; function load() &#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('hello','http://localhost:4000'); window.onmessage = function (e) &#123; console.log(e.data); &#125; &#125;&lt;/script&gt;&lt;!-- http://localhost:4000/b.html--&gt;&lt;script&gt; window.onmessage = function (e) &#123; console.log(e.data); e.source.postMessage('hi',e.origin) &#125;&lt;/script&gt; window.name12345678910111213141516171819202122&lt;!-- http://localhost:3000/a.html--&gt;&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true function load() &#123; if(first)&#123; let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 获取c的window.name console.log(iframe.contentWindow.name); &#125; &#125;&lt;/script&gt;&lt;!-- http://localhost:3000/b.html a和b是同域的 无内容--&gt;&lt;!-- http://localhost:4000/c.html--&gt;&lt;script&gt; window.name = '我不爱你' &lt;/script&gt; hash1234567891011121314151617181920&lt;!-- http://localhost:3000/a.html--&gt;&lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function () &#123; console.log(location.hash); &#125;&lt;/script&gt;&lt;!-- http://localhost:3000/b.html--&gt;&lt;script&gt; window.parent.parent.location.hash = location.hash &lt;/script&gt;&lt;!-- http://localhost:4000/c.html--&gt;&lt;script&gt; console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe);&lt;/script&gt; document.domain 父子域通信document.domain 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个父域将用于后续源检查 端口号是由浏览器另行检查的。任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此使用 document.domain 来允许子域安全访问其父域时，需要在父域和子域中都进行赋值，即使这样做只是将父域设置回其原始值，但这是必要的，以确保端口号都为 null 。 12345678910111213141516&lt;!-- 域名 一级域名二级域名 --&gt;&lt;!-- http://a.zf1.cn:3000/a.html --&gt;&lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125;&lt;/script&gt;&lt;!-- http://b.zf1.cn:3000/b.html--&gt;&lt;script&gt; document.domain = 'zf1.cn' var a = 100;&lt;/script&gt; 其他 http-proxy nginx websocket]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>http</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise原理]]></title>
    <url>%2F2019%2F09%2F11%2FPromise%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计模式.md]]></title>
    <url>%2F2019%2F08%2F28%2F%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[23种设计模式 面向对象把客观对象抽象成属性数据和对数据的相关操作，把内部细节和不想关的信息隐藏起来；把同一个类型的客观对象的属性数据和操作绑定在一起，封装成类，并且允许分成不同层次进行抽象，通过继承实现属性和操作的共享。 面向对象开发计划 面向对象的分析 OOA 面向对象的设计 OOD 面向对象的编程 OOP 封装把数据封装起来，不该外部访问的不要让外部访问，减少耦合，利于数据的接口权限管理 ES6 目前不支持，一般认为_开头的都是私有的，不要使用 typescript修饰符实现 public：修饰公有的属性或者行为，可以在类内或者类外使用，是默认的修饰符 protected：修饰受保护的属性或者行为，可以在本类内和子类中使用 private：修饰私有的属性或者行为，只可以在本类内使用 123456789101112131415161718192021222324252627282930class Animal &#123; public name; protected age; private weight; constructor(name,age,weight) &#123; this.name=name; this.age=age; this.weight=weight; &#125;&#125;class Person extends Animal &#123; private money; constructor(name,age,weight,money) &#123; super(name,age,weight); this.money=money; &#125; getName() &#123; console.log(this.name);// hello &#125; getAge() &#123; console.log(this.age);// 1 &#125; getWeight() &#123; console.log(this.weight);// undefined &#125;&#125;let p=new Person('hello',1,100,100);console.log(p.name);// helloconsole.log(p.age);// undefinedconsole.log(p.weight);// undefined 继承子类继承父类，父类是公共的。 将公共方法抽离到父类中，可以提高复用，减少冗余 12345678910111213141516171819202122//把同一个类型的客观对象的属性数据和操作绑定在一起，封装成类Animal// 分成Animal和Dog不同层次进行抽象，通过继承实现属性和操作的共享class Animal&#123; constructor(name)&#123; this.name=name; &#125; eat()&#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;let animal=new Animal('动物');class Dog extends Animal&#123; constructor(name,age)&#123; super(name); this.age=age; &#125; bark()&#123; console.log(`$&#123;this.name&#125; is barking!`) &#125;&#125;let dog=new Dog('dog',2); 多态面向接口编程 同一个接口可以有不同实现，保持子类的开放性和灵活性 123456789101112131415161718192021222324252627class Animal &#123; constructor(name,age,weight) &#123; this.name=name; this.age=age; this.weight=weight; &#125; speak() &#123; &#125;&#125;class Person extends Animal &#123; constructor(name,age,weight,money) &#123; super(name,age,weight); this.money=money; &#125; speak() &#123; console.log('你好!'); &#125;&#125;class Dog extends Animal &#123; constructor(name,age,weight) &#123; super(name,age,weight); &#125; speak() &#123; console.log('汪汪汪!'); &#125;&#125; 五大设计原则（SOLID）SOLID设计原则 S：单一职责原则(Single responsibility principle)，对象应该仅具有一种单一功能，如果功能特别复杂就进行拆分 O：开放封闭原则(Open Closed Principle)，对扩展开放，对修改关闭，增加需求时，扩展新代码，而非修改已有代码，这是软件设计的终极目标 12345678910111213141516171819202122function parseJSON(response) &#123;return response.json();&#125;function checkStatus(response) &#123;if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response;&#125;const error = new Error(response.statusText);error.response = response;throw error;&#125;export default function request(url, options) &#123;return fetch(url, options) .then(checkStatus) .then(parseJSON) .then(data=&gt;&#123;data&#125;) .catch(err =&gt; (&#123; err &#125;));&#125; L：里氏替换原则(Liskov Substitution Principle)，子类能覆盖父类，父类能出现的地方子类就能出现 I：接口隔离原则(Interface Segregation Principle)，保持接口的单一独立，避免出现胖接口，类似于单一职责原则，更关注接口 D：依赖倒置原则(Dependence Inversion Principle)，面向接口编程，依赖于抽象而不依赖于具体实现，使用方只关注接口而不关注具体类的实现 23种设计模式创建型工厂模式简单工厂模式工厂方法模式抽象工厂模式单例模式原型模式建造者模式结构型适配器模式装饰器模式代理模式外观模式巧接模式组合模式享元模式行为型观察者模式状态模式策略模式命令模式模版方法模式迭代器模式职责链模式备忘录模式访问者模式中介者模式解释器模式]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2019%2F08%2F16%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[高阶函数：参数是函数 或 返回值是函数的函数 js的核心是回调 before和afterAOP（面向切面编程），把核心抽离出来，在核心基础上增加功能 before1234567891011121314151617181920212223242526Function.prototype.before=function(beforeFn)&#123; return (...args)=&gt;&#123; // 箭头函数中没有this和arguments beforeFn(); // this向上级作用域查找，代表Function实例 this(...args); &#125;&#125;let say=(...args)=&gt;&#123; console.log(args,'say');&#125;// 得到新函数，this指向saylet hello=say.before(()=&gt;&#123; console.log('hello')&#125;);let bye=say.before(()=&gt;&#123; console.log('bye')&#125;);// 传参，传入this，即say函数hello('2019');bye('2018','world')// 结果//hello//[ '2019' ] 'say'//bye//[ '2018', 'world' ] 'say' transcation事务实际应用 react事务的改变，可以在前面和后面，同时增加方法]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用JWT认证]]></title>
    <url>%2F2019%2F08%2F16%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8JWT%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[创建项目并配置vue-config.js使用vue-cli3.0创建vue项目：vue create &lt;project-name&gt;，配置vue-config.js 1234567891011121314151617181920212223242526272829303132333435363738let path = require('path')module.exports = &#123; publicPath:process.env.NODE_ENV === 'production'? '/vue-project':'/', outputDir:'myassets', // 输出路径 assetsDir:'static', // 生成静态目录的文件夹 runtimeCompiler: true, // 是否可以使用template模板 parallel:require('os').cpus().length &gt; 1, //多余1核cpu时 启动并行压缩 productionSourceMap:false, //生产环境下 不使用soruceMap // https://github.com/neutrinojs/webpack-chain chainWebpack:config=&gt;&#123; // 控制webpack内部配置 config.resolve.alias.set('component',path.resolve(__dirname,'src/components')); &#125;, // https://github.com/survivejs/webpack-merge configureWebpack:&#123; // 新增插件等 plugins:[] &#125;, devServer:&#123; // 配置代理 proxy:&#123; '/api':&#123; target:'http://a.zf.cn:3000', changeOrigin:true &#125; &#125; &#125;, // 第三方插件配置 pluginOptions: &#123; 'style-resources-loader': &#123; preProcessor: 'less', patterns: [ // 插入全局样式 path.resolve(__dirname,'src/assets/common.less') ], &#125; &#125;&#125; jwtJSON Web Token（JWT）是目前最流行的跨域身份验证解决方案 解决问题：session不支持分布式架构，无法支持横向扩展，只能通过数据库来保存会话数据实现共享。如果持久层失败会出现认证失败。 优点：服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展。 JWT包含了使用.分隔的三部分 Header 头部 123&#123; "alg": "HS256", "typ": "JWT"&#125; // algorithm =&gt; HMAC SHA256// type =&gt; JWT Payload 负载、载荷 12345678JWT 规定了7个官方字段iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 Signature 签名 对前两部分的签名，防止数据篡改 1234HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 使用方式HTTP 请求的头信息Authorization字段里面 1Authorization: Bearer &lt;token&gt; 通过url传输 1http://www.xxx.com/pwa?token=xxxxx 如果是post请求也可以放在请求体中 二.服务端返回TOKEN1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let express = require('express');let app = express();let bodyParser = require('body-parser');let jwt = require('jsonwebtoken');app.use((req,res,next)=&gt;&#123; res.header("Access-Control-Allow-Origin", "http://localhost:8080"); res.header("Access-Control-Allow-Methods", "GET,HEAD,OPTIONS,POST,PUT"); res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization"); if(req.method.toLowerCase() === 'options')&#123; return res.end(); &#125; next();&#125;)app.use(bodyParser.json());let secret = 'zfjg';app.get('/test',(req,res)=&gt;&#123; res.end(&#123;test:'test'&#125;)&#125;)app.post('/login',(req,res)=&gt;&#123; let &#123;username&#125; = req.body; if(username === 'admin')&#123; // 如果访问的是admin 种植cookie res.json(&#123; code:0, username:'admin', token:jwt.sign(&#123;username:'admin'&#125;,secret,&#123; expiresIn:20 &#125;) &#125;) &#125;else&#123; res.json(&#123; code:1, data:'用户名不存在' &#125;) &#125;&#125;);app.get('/validate',(req,res)=&gt;&#123; let token = req.headers.authorization; jwt.verify(token,secret,(err,decode)=&gt;&#123; // 验证token的可靠性 if(err)&#123; return res.json(&#123; code:1, data:'token失效了' &#125;) &#125;else&#123; res.json(&#123; username:decode.username, code:0, // 延长tokne的过期时间 token:jwt.sign(&#123;username:'admin'&#125;,secret,&#123; expiresIn:20 &#125;) &#125;) &#125; &#125;);&#125;);app.listen(3000); 三.路由配置 Home.vue 首页 Profile.vue 个人中心 Login.vue 登录页面 12345678910111213141516171819202122export default new Router(&#123; mode: 'history', base: process.env.BASE_URL, routes: [ &#123; path: '/', name: 'home', component: Home, &#125;, &#123; path: '/profile', name: 'profile', component: Profile, meta: &#123; needLogin: true &#125;, // 必须要登录才能访问 &#125;, &#123; path: '/login', name: 'login', component: Login, &#125;, ],&#125;); 四.axios封装1234567891011121314151617181920212223242526272829303132333435import axios from 'axios';class FetchData &#123; constructor() &#123; this.baseURL = process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : '/'; // 请求路径 this.timeout = 3000; // 设置超时时间 &#125; setInterceptor(instance) &#123; // 设置拦截器 instance.interceptors.request.use(config =&gt; &#123; config.headers.Authorization = `$&#123;localStorage.getItem('token')&#125;`; return config; // 增加token &#125;, (err) =&gt; &#123; Promise.reject(err); &#125;); instance.interceptors.response.use(res =&gt; res.data, (err) =&gt; &#123; Promise.reject(err); &#125;); &#125; request(request) &#123; const instance = axios.create(); const config = &#123; baseURL: this.baseURL, timeout: this.timeout, ...request, &#125;; // 合并配置 this.setInterceptor(instance); return instance(config); &#125;&#125;export default new FetchData(); 五.测试接口123456789export const getTest = () =&gt; fetchData.request(&#123; url: '/test' &#125;);export const login = username =&gt; fetchData.request(&#123; url: '/login', method: 'POST', data: &#123; username, &#125;,&#125;);export const validate = () =&gt; fetchData.request(&#123; url: '/validate' &#125;); 六.在vuex中发送请求123456789101112131415161718192021export default new Vuex.Store(&#123; state: &#123; username: '', &#125;, mutations: &#123; setUsername(state, username) &#123; state.username = username; &#125;, &#125;, actions: &#123; async login(&#123; commit &#125;, username) &#123; const r = await login(username); // 登录成功后返回用户名信息 if (r.token) &#123; // 如果有返回token说明成功 commit('setUsername', username); // 将用户存入state中 localStorage.setItem('token', r.token); // 将token存放起来 &#125; else &#123; // 否则返回失败的promise return Promise.reject(r); &#125; &#125;, &#125;,&#125;); 七.权限认证123456789async validate(&#123; commit &#125;) &#123; const r = await validate(); if (r.code === 1) &#123; return false; &#125; commit('setUsername', r.username); localStorage.setItem('token', r.token); // 将token存放起来 return true;&#125; 判断用户访问权限12345678910111213141516171819router.beforeEach(async (to, from, next) =&gt; &#123; // 如果不需要校验可以设置白名单 const isLogin = await store.dispatch('validate'); if (isLogin) &#123; // 如果是登录 if (to.name === 'login') &#123; next('/profile'); &#125; else &#123; next(); &#125; &#125; else &#123; const flag = to.matched.some(item =&gt; item.meta.needLogin); if (flag) &#123; next('/login'); &#125; else &#123; next(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中render函数之JSX应用]]></title>
    <url>%2F2019%2F08%2F15%2Fvue%E4%B8%ADrender%E5%87%BD%E6%95%B0%E4%B9%8BJSX%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[快速原型开发@vue/cli-service-global可以快速识别.vue文件封装组件插件等功能 123sudo npm install @vue/cli -gsudo npm install -g @vue/cli-service-globalvue serve App.vue 模板缺陷模板最大的缺点是不易扩展，可能会造成逻辑冗余。 Level组件需要对不同的type产生不同的标签 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;!--使用Level组件--&gt; &lt;Level :type="1"&gt;哈哈&lt;/Level&gt; &lt;Level :type="2"&gt;哈哈&lt;/Level&gt; &lt;Level :type="3"&gt;哈哈&lt;/Level&gt; &lt;/div&gt;&lt;/template&gt;&lt;template&gt; &lt;h1 v-if="type==1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if="type==2"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-else-if="type==3"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt;&lt;/template&gt;&lt;script&gt; // Level组件 export default &#123; props: &#123; type: &#123; type: Number &#125; &#125; &#125;;&lt;/script&gt; 函数式组件函数式组件没有模板,必须提供render函数 复杂的逻辑变得非常简单 123456789101112131415161718192021222324252627// 函数式组件导出对象export default &#123; // 必须提供render函数 render(h) &#123; return h( "h" + this.type/*标签类型*/, &#123; // 绑定事件 on:&#123; click()&#123; console.log(1) &#125; &#125;, //设置属性 attrs:&#123; a:1 &#125; &#125;/*属性*/, this.$slots.default/*子节点*/ ); &#125;, props: &#123; type: &#123; type: Number &#125; &#125;&#125;; JSX应用jsx会让代码看起来更加简洁易于读取 1234567891011export default &#123; render(h) &#123; const tag = "h" + this.type; return &lt;tag&gt;&#123;this.$slots.default&#125;&lt;/tag&gt;; &#125;, props: &#123; type: &#123; type: Number &#125; &#125;&#125;; render方法订制组件编写List组件可以根据用户传入的数据自动循环列表 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;List :data="data"&gt;&lt;/List&gt;&lt;/template&gt;&lt;script&gt; import List from "./components/List"; export default &#123; data() &#123; return &#123; data: ["苹果", "香蕉", "橘子"] &#125;; &#125;, components: &#123; List &#125; &#125;;&lt;/script&gt;&lt;!-- List组件 --&gt;&lt;template&gt;&lt;div class="list"&gt; &lt;div v-for="(item,index) in data" :key="index"&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;props: &#123; data: Array, default: () =&gt; []&#125;&#125;;&lt;/script&gt; Lsit组件自定义循环的元素 通过render方法来订制,在父组件中传入render方法 我们需要createElement方法，就会想到可以编写个函数组件，将createElement方法传递出来 ListItem.vue调用最外层的render方法，将createElement和当前项传递出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!--父组件--&gt;&lt;template&gt; &lt;List :data="data" :render="render"&gt;&lt;/List&gt;&lt;/template&gt;&lt;script&gt;import List from "./components/List";export default&#123; data() &#123; return &#123; data: ["苹果", "香蕉", "橘子"] &#125;; &#125;, components:&#123; List &#125;, methods:&#123; render(h, name) &#123; return &lt;span&gt;&#123;name&#125;&lt;/span&gt;; &#125; &#125;&#125;;&lt;/script&gt;&lt;!--List组件--&gt;&lt;template&gt; &lt;div class="list"&gt; &lt;div v-for="(item,index) in data" :key="index"&gt; &lt;li v-if="!render"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;!-- 将render方法传到函数组件中，将渲染项传入到组件中，在内部回调这个render方法 --&gt; &lt;ListItem v-else :item="item" :render="render"&gt;&lt;/ListItem&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 函数组件ListItemimport ListItem from "./ListItem";export default &#123; components: &#123; ListItem &#125;, props: &#123; render: &#123; type: Function &#125;, data:&#123; type:Array, default: () =&gt; [] &#125; &#125;&#125;;&lt;/script&gt;&lt;!--ListItem组件--&gt;&lt;script&gt;export default &#123; props: &#123; render: &#123; type: Function &#125;, item: &#123;&#125; &#125;, render(h) &#123; return this.render(h, this.item); &#125;&#125;;&lt;/script&gt; slot 作用域插槽使用v-slot定义模板和设置模板的参数，使用&lt;slot&gt;使用模板并给模板传递参数 123456789101112&lt;!--child用于匹配--&gt;&lt;!--父组件--&gt;&lt;List :arr="arr"&gt; &lt;template v-slot:child="&#123;item&#125;"&gt; &#123;&#123;item&#125;&#125; &lt;/template&gt;&lt;/List&gt;&lt;!--List组件--&gt;&lt;template v-for="(item,key) in arr" :key="key"&gt; &lt;slot name="child" :item="item"&gt;&lt;/slot&gt;&lt;/template&gt; 编写可编辑表格基于iview使用jsx扩展成可编辑的表格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt;&lt;div&gt; &lt;Table :columns="columns" :data="data"&gt;&lt;/Table&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue';export default &#123; methods:&#123; render(h,&#123;column,index,row&#125;)&#123; let value = row[column.key]; // 绑定原生事件，onOn-enter传参on-enter函数 return ( &lt;div on-click=&#123;(e)=&gt;this.changeIndex(e,index)&#125; &gt; &#123;this.index === index?( &lt;i-input type="text" value=&#123;value&#125; on-input=&#123;(value)=&gt;&#123; this.handleChange(value,column,row) &#125;&#125; onOn-enter=&#123;()=&gt;this.enter(row,index)&#125; /&gt; ):( &lt;span&gt;&#123;value&#125;&lt;/span&gt; )&#125; &lt;/div&gt; ) &#125;, enter(row,index)&#123; this.data.splice(index,1,row); this.index = -1; &#125;, handleChange(value,column,row)&#123; row[column['key']]= value; &#125;, changeIndex(e,index)&#123; this.index = index; this.$nextTick(()=&gt;&#123; e.currentTarget.getElementsByTagName("input")[0].focus() &#125;) &#125; &#125;, data() &#123; return &#123; index:-1, columns: [ &#123; title: 'Name', key: 'name', render:this.render &#125;, &#123; title: 'Age', key: 'age', &#125;, &#123; title: 'Address', key: 'address', &#125;, ], data: [ &#123; name: 'John Brown', age: 18, address: 'New York No. 1 Lake Park', date: '2016-10-03', &#125;, &#123; name: 'Jim Green', age: 24, address: 'London No. 1 Lake Park', date: '2016-10-01', &#125; ], &#125;; &#125;,&#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件间通信方式]]></title>
    <url>%2F2019%2F08%2F13%2Fvue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[文件结构123456components ├── Grandson1.vue ├── Grandson2.vue ├── Parent.vue ├── Son1.vue └── Son2.vue Props（父传子） 在父组件Parent.vue中使用子组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123;mny&#125;&#125; &lt;Son1 :mny="mny"&gt;&lt;/Son1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son1 from "./Son1"; export default &#123; // 注册子组件 components: &#123; Son1 &#125;, data() &#123; return &#123; mny: 100 &#125;; &#125; &#125;;&lt;/script&gt; 在子组件Son1.vue中接受父组件的属性 12345678910111213&lt;template&gt; &lt;div&gt;子组件1: &#123;&#123;mny&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 接收父组件传递的属性 props: &#123; mny: &#123; type: Number &#125; &#125; &#125;;&lt;/script&gt; $emit（子传父）子组件通过事件触发父组件绑定的回调，将修改的内容传递给父组件 在父组件Parent.vue中绑定事件的回调 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123;mny&#125;&#125; &lt;Son1 :mny="mny" @input="change"&gt;&lt;/Son1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son1 from "./Son1"; export default &#123; methods: &#123; change(mny) &#123; this.mny = mny; &#125; &#125;, components: &#123; Son1 &#125;, data() &#123; return &#123; mny: 100 &#125;; &#125; &#125;;&lt;/script&gt; 在子组件Son1.vue触发事件回调 12345678910111213141516&lt;template&gt; &lt;div&gt; 子组件1: &#123;&#123;mny&#125;&#125; &lt;!--触发事件回调，并传参--&gt; &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; mny: &#123; type: Number &#125; &#125; &#125;;&lt;/script&gt; 语法糖的写法（同步父子组件的数据） .sync 12345678&lt;!--父组件--&gt;&lt;Son1 :mny.sync="mny"&gt;&lt;/Son1&gt;&lt;!--父组件--&gt;&lt;Son1 :mny.sync="mny"&gt;&lt;/Son1&gt;&lt;!--子组件--&gt;&lt;!-- 触发的事件名 update:(绑定.sync属性的名字) --&gt;&lt;button @click="$emit('update:mny',200)"&gt;更改&lt;/button&gt; v-model 12345678910111213141516171819202122&lt;!--父组件--&gt;&lt;Son1 v-model="mny"&gt;&lt;/Son1&gt;&lt;!--子组件--&gt;&lt;template&gt; &lt;div&gt; &lt;!--只能是value--&gt; 子组件1: &#123;&#123;value&#125;&#125; &lt;!--只能是input--&gt; &lt;button @click="$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: &#123; // 接收到的属性名只能叫value type: Number &#125; &#125; &#125;;&lt;/script&gt; $parent和$children$parent父组件实例，$children子组件实例组成的数组，可以用来继续将属性传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--父组件--&gt;&lt;template&gt; &lt;div&gt; 父组件:&#123;&#123;mny&#125;&#125; &lt;Son1 :value="mny" @input="change"&gt;&lt;/Son1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Son1 from "./Son1"; export default &#123; methods: &#123; change(mny) &#123; this.mny = mny; &#125; &#125;, components: &#123; Son1 &#125;, data() &#123; return &#123; mny: 100 &#125;; &#125; &#125;;&lt;/script&gt;&lt;!--子组件Son1--&gt;&lt;Grandson1 :value="value"&gt;&lt;/Grandson1&gt;&lt;!--子组件的子组件Grandson1--&gt;&lt;template&gt; &lt;div&gt; 孙子:&#123;&#123;value&#125;&#125; &lt;!-- 触发父组件的input事件 --&gt; &lt;button @click="$parent.$emit('input',200)"&gt;更改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; value: &#123; type: Number &#125; &#125; &#125;;&lt;/script&gt; 如果层级很深那么就会出现$parent.$parent.....，封装$dispatch方法和$broadcast方法层层向上或向下进行派发，解决这个问题 层层传递$dispatch（层层向上）通过层层向上触发某个事件传递数据 1234567Vue.prototype.$dispatch = function $dispatch(eventName, data) &#123; let parent = this.$parent; while (parent) &#123; parent.$emit(eventName, data); parent = parent.$parent; &#125;&#125;; 同样可以封装一个$broadcast方法层层向下进行派发 $broadcast（层层向下）通过层层向下触发某个事件传递数据 1234567891011Vue.prototype.$broadcast = function $broadcast(eventName, data) &#123; const broadcast = function () &#123; this.$children.forEach((child) =&gt; &#123; child.$emit(eventName, data); if (child.$children) &#123; $broadcast.call(child, eventName, data); &#125; &#125;); &#125;; broadcast.call(this, eventName, data);&#125;; 批量传递$attrs代表没有被props接收的剩余属性的集合，可以用于批量向下传递属性 inheritAttrs:false使$attrs的属性不在真实DOM上 1234567891011121314151617181920212223&lt;!--父组件--&gt;&lt;Son2 name="小珠峰" age="10"&gt;&lt;/Son2&gt;&lt;!--子组件 可以在son2组件中使用$attrs属性,可以利用v-bind批量设置属性并继续向下传递 --&gt;&lt;div&gt; 儿子2: &#123;&#123;$attrs.name&#125;&#125; &lt;Grandson2 v-bind="$attrs"&gt;&lt;/Grandson2&gt;&lt;/div&gt;&lt;script&gt; export default &#123; inheritAttrs:false, &#125;&lt;/script&gt;&lt;!--子组件的子组件--&gt;&lt;template&gt; &lt;div&gt;孙子:&#123;&#123;$attrs&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; inheritAttrs:false, &#125;&lt;/script&gt; $listeners代表绑定事件的回调函数的集合，可以用于批量向下传递事件及回调 12345678&lt;!--父组件--&gt;&lt;Son2 name="小珠峰" age="10" @click="()=&gt;&#123;this.mny = 500&#125;"&gt;&lt;/Son2&gt;&lt;!--子组件 可以在son2组件中使用listeners属性,可以利用v-on批量绑定事件并将事件继续向下传递 --&gt;&lt;Grandson2 v-bind="$attrs" v-on="$listeners"&gt;&lt;/Grandson2&gt;&lt;!--子组件的子组件--&gt;&lt;button @click="$listeners.click()"&gt;更改&lt;/button&gt; 子组件共享父组件数据（类似react的context） 在业务场景下不推荐使用，一般在封装的库中使用 Provide在父级中注入要被共享的数据，可以为对象或函数 可以直接注入父组件 123provide() &#123; return &#123;parentMsg: "父亲",parent:this&#125;;&#125;, Inject在任意子组件中注入父级共享数据 1inject: ["parentMsg","parent"] // 会将数据挂载在当前实例上 Ref（父组件获取子组件数据）ref属性放在组件上，获取的是当前组件实例 12345&lt;Grandson2 v-bind="$attrs" v-on="$listeners" ref="grand2"&gt;&lt;/Grandson2&gt;mounted() &#123; // 获取组件定义的属性 console.log(this.$refs.grand2.name);&#125; EventBus（跨组件传递）用于跨组件通知，不复杂的项目可以使用这种方式。缺陷是定义到了全局上，会造成重名，不适合复杂项目 公开发布订阅 1Vue.prototype.$bus = new Vue(); Son2组件和Grandson1相互通信 12345mounted() &#123; this.$bus.$on("my", data =&gt; &#123; console.log(data); &#125;);&#125;, 123456mounted() &#123; // 事件环，推迟执行，当页面渲染完成后再执行回调 this.$nextTick(() =&gt; &#123; this.$bus.$emit("my", "我是Grandson1"); &#125;);&#125;, Vuex状态管理]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监控]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rangularJS_1.x]]></title>
    <url>%2F2019%2F07%2F22%2FangularJS_1.x%2F</url>
    <content type="text"><![CDATA[MVC 双向数据绑定(Model-View-ViewModel) 模版 将html文件解析到DOM中 模块化与依赖注入 指令可以用来创建自定义的标签，也可以用来装饰元素或者操作DOM属性 angularJS模板中要使用-连接命名形式，定义时要使用驼峰命名法 模块angular.module(&#39;moduleName&#39;,[])，总容器，控制器、指令、服务、路由、过滤器都挂在它下面 第一个参数：模块名，用于ng-app指令中 第二个参数：注入的依赖 一个angularJS应用中只能有一个模块，控制整个页面 随模块创建$rootScope（根作用域），注入各个控制器中，控制整个页面 控制器1234var app=angular.module('moduleName',[]);app.controller('controllerName',function($rootScope,$scope)&#123; $scope.name='Earth';&#125;) 第一个参数：控制器名，用于ng-controller指令中 第二个参数：视图渲染数据处理 一个控制器，控制一段视图（一段HTML标签） 一个控制器创建一个$scope（本作用域），控制视图 控制器之间不能互相调用（交互需要通过事件实现） 不要在控制器中操作DOM元素（在指令中操作DOM元素） 不要在控制器中格式化数据或过滤操作（使用filter实现数据格式化），如$rootScope.name=&#39;#&#39;+$rootScope.name，会导致如下问题 123456789&gt; // 页面显示 $rootScope 渲染结果为 $#Earth&gt; app.controller('1homeCtrl',function($rootScope)&#123;&gt; $rootScope.name='Earth';&gt; $rootScope.name='#'+$rootScope.name;&gt; &#125;)&gt; app.controller('1homeCtrl',function($rootScope)&#123;&gt; $rootScope.name='$'+$rootScope.name;&gt; &#125;)&gt; 模型scope scope通过控制器派生 scope默认是个空对象 scope是一个上下文 scope是一个树型结构，和DOM标签平行 每个angularJS应用都有一个根作用域rootScope scope可以传播事件，类似DOM事件，可以向上，也可以向下 scope是MVC基础，也是双向数据绑定的基础 替换变量时，类似作用域链查找，层层往上直到找到 scope上有很多方法 $apply：强行用模型刷新视图 $watch：监听模型某个值的变化 scope生命周期 创建：控制器创建时，自动创建 监听变化 当监听到模型发现变化时，通知监听者（需要通过angularJS的方法或指令实现） 销毁 事件(父子控制器交互)常用于父子控制器之间的交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body ng-controller="totalCtrl"&gt; &lt;input type="number" ng-model="total"&gt; &lt;div ng-controller="detailCtrl"&gt; &lt;table&gt; &lt;!--循环遍历渲染--&gt; &lt;tr ng-repeat="item in items"&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.price&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;input type="number" ng-model="item.num"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="./angular.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app=angular.module('eventModule',[]); app.controller('totalCtrl',function($scope)&#123; $scope.total=0; // 监听子控制器传参，进行操作 $scope.$on('changeTotal',function(e/*事件对象*/,total/*接收参数*/)&#123; $scope.total=total; &#125;) // 监听 $scope.total 的变化 $scope.$watch('total',function()&#123; // 向子控制器传参 $scope.$broadcast('changeTotal'/*事件名称*/,$scope.total/*要传的参数*/); &#125;) &#125;); app.controller('detailCtrl',function($scope)&#123; $scope.items=[ &#123;name:'馒头',num:0,price:5&#125;, &#123;name:'包子',num:0,price:10&#125;]; // 深度监听对象数据类型 $scope.items 的变化 $scope.$watch('items',function()&#123; var total=0; for(var i=0;i&lt;$scope.items.length;i++)&#123; total+=$scope.items[i].num*$scope.items[i].price; &#125; // 向父控制器传参 $scope.$emit('changeTotal'/*事件名称*/,total/*要传的参数*/) &#125;,true/*是否深度watch*/) // 监听父控制器传参，进行操作 $scope.$on('changeTotal',function(e/*事件对象*/,total/*接收参数*/)&#123; $scope.items[1].num=Math.floor(total/$scope.items[1].price); $scope.items[0].num=Math.floor(total%$scope.items[1].price/$scope.items[0].price) &#125;) &#125;)&lt;/script&gt; 双向数据绑定12345678910&lt;div&gt; &lt;input type="text" ng-model="name"&gt;&lt;/div&gt;app.controller('homeCtrl',function($scope)&#123; $scope.name='Earth'; $scope.$watch("name",function()&#123; console.log($scope.name); &#125;)&#125;) 指令12345app.directive('name'/*指令名*/,function()&#123; return &#123; // 指令属性 &#125;&#125;); 指令实例的名称，使用时名称是-连接形式，在定义时要使用驼峰命名法，否则无法找到 指令实例的属性设置 restrict: 设置指令用法，如&#39;E&#39;代表作为元素形式使用，&#39;EA&#39;代表作为元素形式或属性形式使用，默认值为&#39;EACM&#39; E：Element 元素 A：Attribute 属性 C：Class CSS类 M：Comment 注释 1234&lt;hello&gt;&lt;/hello&gt;&lt;!--元素--&gt;&lt;div hello&gt;&lt;/div&gt;&lt;!--属性--&gt;&lt;div class="hello"&gt;&lt;/div&gt;&lt;!--CSS类--&gt;&lt;!--directive:hello--&gt;&lt;!--注释--&gt; template：模板，值用于渲染时嵌套入指令或替换指令，值类型 &#39;&lt;div&gt;hello world&lt;/div&gt;&#39; $templateCache.get(&#39;hello&#39;) templateUrl：模板，值为文件路径，会发送一个请求，用于渲染时嵌套入指令或替换指令，如&#39;./hello.html&#39; replace: 设置嵌套入或替换指令，值如下 true：替换指令，EAC形式没有外层标签，M形式可用 false: 嵌套入指令，EAC形式有外层标签，M形式不能用 transclude：是否保存指令元素中或指令所在元素中的内容，通过ng-transclude(支持EAC三种形式)在模板中运用 1234567891011121314&lt;!--hello world 111--&gt;&lt;hello&gt;111&lt;/hello&gt;&lt;div hello&gt;111&lt;/div&gt;&lt;div class="hello"&gt;111&lt;/div&gt;&lt;script type="text/javascript"&gt; app.directive('hello',function($templateCache)&#123; return&#123; restrict:'EAC', template:'&lt;div&gt;hello world &lt;ng-transclude&gt;&lt;/div&gt;', replace:true, transclude:true &#125; &#125;)&lt;/script&gt; link：用于与控制器交互，值为function，function的参数如下 scope：当前指令的作用域 element：当前指令所属元素本身，jquery形式，可以直接使用jquery的方法 attrs：指令元素上或指令所在元素上的属性 ctrl：如果设置require，ctrl代表依赖指令的controller，可以获取依赖指令暴露的方法和数据，否则为undefined。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div ng-controller="ctrl1"&gt; &lt;hello done="world()"&gt;world&lt;/hello&gt; &lt;/div&gt; &lt;div ng-controller="ctrl2"&gt; &lt;hello done="earth()"&gt;earth&lt;/hello&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="./angular.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app=angular.module('helloModule',[]); app.controller('ctrl1',function($scope,$rootScope)&#123; $rootScope.log=function()&#123; console.log('hello'); &#125; $scope.name='world'; $scope.world=function()&#123; alert('world') &#125; &#125;); app.controller('ctrl2',function($scope,$rootScope)&#123; $scope.name='earth'; $scope.earth=function()&#123; alert('earth') &#125; &#125;); app.directive('hello'/*指令名*/,function($templateCache)&#123;//指令构造函数 return&#123; restrict:'EACM', template:'&lt;div&gt;hello &lt;ng-transclude&gt;&lt;/div&gt;', replace:true, transclude:true, link:function(scope,ele,attrs)&#123; // 为ele绑定click事件 ele.bind('click',function()&#123; scope.log() scope.$apply(attrs.done) &#125;) &#125; &#125; &#125;)&lt;/script&gt; controller：通过this暴露数据给其他指令，值为function，function的参数$scope为当前指令的作用域 12345678910111213141516171819app.directive('person',function()&#123; return &#123; restrict:'E', // 需要暴露出去的数据 controller:function($scope/*该指令自己的模型*/)&#123; $scope.style=[]; // 暴露add方法 this.add=function(item)&#123; $scope.style.push(item) &#125; &#125;, template:'&lt;div&gt;human&lt;/div&gt;', link:function(scope,ele,attrs)&#123; ele.bind('click',function(e)&#123; alert(scope.style) &#125;) &#125; &#125;&#125;); require：设置依赖的指令(有依赖的指令时link第四个参数才有值），用法如require:&#39;^person&#39; scope: 指令每次使用时初始化独立的scope作用域，设置要继承的所在控制器作用域中的方法和变量，用法如 1234567891011121314151617181920212223242526272829303132333435363738&lt;body ng-controller="ctrl1"&gt; &lt;div myname="&#123;&#123;name&#125;&#125;" person iage="age" age="&#123;&#123;age&#125;&#125;" hello="sayHello(word)"&gt;11&lt;/div&gt; &lt;person kind myname="&#123;&#123;name&#125;&#125;" iage="age" age="&#123;&#123;age&#125;&#125;"&gt;22&lt;/person&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; app.controller('ctrl1',function($scope)&#123; $scope.name="world" $scope.age=23 $scope.sayHello=function(word)&#123; console.log(word) &#125; &#125;) app.directive('person',function()&#123; return &#123; restrict:'E', // 创建一个独立的scope scope:&#123; // 继承指令元素或指令所在元素上myname属性的值 // 简写myname：'@' myname:'@myname', // 把当前的iage指向所属的控制器scope上的属性 // 相当于iage: '=iage' iage:'=', age:'@', // 用来调用所属的控制器scope上的函数 ihello:'&amp;hello' &#125;, transclude:true, template:'&lt;div&gt;human &lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;', link:function(scope,ele,attrs)&#123; console.log(scope.myname);// 输出结果world console.log(scope.iage,scope.age);// 输出结果为23 23 但是前一个23为number类型，后一个23为string类型 scope.ihello(&#123;word:'hello world'&#125;)// 输出结果hello world &#125; &#125; &#125;);&lt;/script&gt; 如果不设置，则使用同一个scope（即指令的rootScope），继承指令所在控制器作用域的所有方法和变量 @和=方式的继承有区别 @方式指向元素上属性的值，结果数据类型为字符串，如果是对象会转为JSON字符串 =方式指向所属的控制器的属性，结果数据类型与控制器一致。如果是对象，结果和控制器属性指向同一空间地址 指令的执行过程 从ng-app上开始，递归子层DOM元素，收集所有指令 编译阶段，根据指令中的template templateUrl transclude进行DOM结构的转换，如果指令提供了compile函数也会调用，对模板自身的转换，只会执行一次 链接阶段，负责模型scope和视图之间的动态关联，执行多次3 app.run()angularJS加载完所有模块后执行的第一个方法，可用于提取在多个指令里进行复用的内容，如模板等 123456789app.run(function($templateCache)&#123; $templateCache.put('hello','&lt;div&gt;hello world&lt;/div&gt;')&#125;)app.directive('hello',function($templateCache)&#123; return&#123; restrict:'E', template:$templateCache.get('hello'), &#125; &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
        <category>angular</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器解析]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[浏览器是方便一般互联网用户通过界面解析和发送HTTP协议的软件 PC端浏览器和移动端浏览器功能基本相同，但运行的操作系统不同，渲染机制有差异 浏览器的内核浏览器中负责将表示页面的字符转变成可视化图像的模块 远程主机响应（请求网页 http协议）http协议 请求报文格式：[请求方式] [请求URL] [HTTP版本]\r\n[首部名称]:[可选空格][首部内容]\r\n[首部名称]:[可选空格][首部内容]\r\n[首部名称]:[可选空格][首部内容]\r\n\r\n[实体] 1'GET / HTTTP/1.0\r\nHost:www.xxxx.cn\r\nUser-Agent: Mozilla/5.0(Macintosh;Intel Mac OS X 10_12_1) AppleWebkit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\r\nAccept: text/html\r\nAccept-Language:zh_CN,zh;q=0.9\r\n\r\n' 相应报文格式：[HTTP版本] [状态码] [原因短语]\r\n[首部名称]:[可选空格][首部内容]\r\n[首部名称]:[可选空格][首部内容]\r\n[首部名称]:[可选空格][首部内容]\r\n\r\n[实体] 12345678910HTTP/1.1 200 OKDate: Wed, 25 Apr 2019 12:01:22 GMT // 服务器发送内容时间Server: Apache // 服务器Last-Modified: Fri, 20 Apr 2018 09:13:48 GMT // 网页最后修改时间ETag: "700a6f-f72f-56a441b148b81" // 强校验码，用于缓存策略Accept-Ranges: bytes // 范围请求Content-Length: 63279 // 实体长度Vary: Accept-Encoding,User-AgentConnection: close // 关闭连接Content-Type: text/html // 实体类型 网页内容组成 doctype：提供浏览器html版本信息，&lt;!doctype html&gt; head：html头部 meta：元数据 charset： 此特性声明当前文档所使用的字符编码，&lt;meta chartset=&quot;utf-8&quot;&gt; http-equiv：客户端行为设置，如渲染模式，缓存等，&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; name=”keywords”：搜索引擎使用，SEO优化 name=”description”：搜索引擎使用，SEO优化 name=”viewport”：浏览器视口设置， link： script：需要在body前完成加载或运行的脚本 body：html实体 script：需要在body解析时加载或运行的脚本 加载资源浏览器解析到URL地址时，调用特定的资源加载器，加载不同的外联资源 chrome会在html文件解析过程中进行预扫描，加载其他资源 一般资源加载过程不会阻碍渲染过程，如CSS资源 javascript资源会阻碍渲染过程，放置在头部会造成进入网页时的短暂白屏 在现代浏览器中，渲染被阻塞时，浏览器会开启新的线程继续渲染 渲染引擎渲染引擎的一般渲染过程。虚线表示渲染阶段依赖的外部模块，不属于渲染引擎 HTML解释器：解释HTML文件的解释器，DOM树 CSS解释器：解释级联样式，为DOM对象计算样式信息，CSSOM树 javascript引擎：解释JS脚本，并使JS代码有调用DOM接口和CSSOM接口的能力 布局：结构DOM和CSSOM，计算出DOM对象的大小位置信息 绘图：将经过布局计算的DOM节点绘制成图像 渲染之前需要加载资源，渲染后DOM或CSS变化后，重新进行布局计算和渲染操作 内核架构 浏览器内核以外的功能基于webkit内核构建浏览器应用，除去内核完成的功能，现代浏览器的工作： 资源管理 多页面管理：多标签页的管理 插件和扩展 账户和同步 安全机制 多系统支持 Chromium(开源的最新版chrome浏览器)多进程架构 主要进程： Browser进程：主进程，负责浏览器界面和页面管理等，调度其他进程，控制其他进程的创建和销毁 Renderer进程：渲染进程 打开网页不一定创建一个Renderer进程，看浏览器开发者的配置，可能多个网页一个进程 NPAPI插件进程：用于管理如flash插件等 GPU进程：当GPU硬件加速打开时才会创建 进程间能互相调用，通过IPC通信，不同操作系统的进程通信方法不同（如windows和Linux） 多线程架构的目的： 职责分离，故障范围小 隔离性 性能 渲染原理 加载：加载渲染所需html代码 渲染：将html代码绘制成图像 加载资源加载机制资源加载器 特定资源加载器：针对每种资源类型的特定加载器，仅加载某一种资源 缓存资源加载器：特定加载器先通过缓存资源加载器来查找是否有缓存资源。如果资源缓存池中存在，取出使用，如果不存在，发送请求给网络模块 通用资源加载器：只负责通过网络获取目标资源的数据，不负责进一步解析 资源缓存 页面缓存：Page Cache 内存缓存: Memory Cache 磁盘缓存: Disk Cache 网络栈 URLRequest：确定请求类型，协议 URLRequestJob(Http)：判断是否需要建立网络连接（查找缓存） HttpNetworkTransaction：建立HTTP事务 HttpStream：建立TCP socket连接 StreamSocket 预加载 DNS预取：&lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt; 资源预取 TCP preconnect 提高加载速度渲染]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack简单实现]]></title>
    <url>%2F2019%2F07%2F15%2Fwebpack%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[webpack打包的简单实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! /usr/bin/env nodelet fs = require('fs');let ejs = require('ejs');let path = require('path');let entry = './src/index.js';let output = './dist/index.js';function styleLoader(content) &#123; content = JSON.stringify(content).replace(/\\r\\n/g, ''); return ` let style =document.getElementsByTagName('style')[0]; if(!style)&#123; style=document.createElement('style'); document.getElementsByTagName('head')[0].appendChild(style); &#125; style.innerHTML+=$&#123;content&#125;; `&#125;let modules = [];function extractModules(name) &#123; let content = fs.readFileSync(name, 'utf8'); if (/\.css$/.test(name)) &#123; content = styleLoader(content); &#125; else &#123; content = content.replace(/require\(['"](.+?)['"]\)/g, function () &#123; let namePath = path.join(name, '../', arguments[1]); extractModules(namePath); return `require('$&#123;namePath&#125;')` &#125;); &#125; modules.push(&#123; name, content &#125;);&#125;extractModules(entry);let template = `( function (modules) &#123; function require(moduleId) &#123; var module=&#123; exports:&#123;&#125; &#125;; modules[moduleId].call(module.exports,module,module.exports,require) return module.exports &#125; return require("&lt;%-entry%&gt;") &#125;)(&#123; &lt;%for(let i=0;i&lt;modules.length;i++)&#123;%&gt; "&lt;%-modules[i].name%&gt;": (function (module,exports,require) &#123; eval(\`&lt;%-modules[i].content%&gt;\`) &#125;), &lt;%&#125;%&gt;&#125;)`;let result = ejs.render(template, &#123;entry, modules&#125;);fs.writeFileSync(output, result);console.log('success');]]></content>
      <categories>
        <category>工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的MVVM原理]]></title>
    <url>%2F2019%2F07%2F12%2Fvue%E7%9A%84MVVM%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-saga]]></title>
    <url>%2F2019%2F07%2F10%2Fredux-saga%2F</url>
    <content type="text"><![CDATA[redux-saga是redux的中间件，用于在redux中处理异步任务，与redux-thunk相比，redux-saga管理更容易，测试更简单 sages 采用Generator函数（ES6）来 yield Effects Effect 是一个简单的对象，该对象包含了一些给 middleware 解释执行的信息。可以通过使用 effects API 如 fork，call，take，put，cancel 等来创建 Effect。 安装$ npm install --save redux-saga ##]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-actions]]></title>
    <url>%2F2019%2F07%2F03%2Fredux-actions%2F</url>
    <content type="text"><![CDATA[redux-actions是redux的中间件，用于简化使用redux的写法 安装npm install --save redux-actions createAction(s)用于创建action createAction创建单个actionCreatorcreateAction(actionType, payloadCreator, metaCreator)，返回值为function类型（actionCreator），actionCreator执行返回{type,payload,meta,error}（action）。 参数解释如下 actionType：必须是字符串类型，并且是唯一一个必要参数 payloadCreator：必须是null、undefined、function，返回值为action的payload属性值，参数为actionCreator的参数 metaCreator：payloadCreator：必须是null、undefined、function，返回值为action的meta属性值，参数为actionCreator的参数 payload属性为Error对象时，error属性自动为true 123456789101112131415161718192021222324export const increment = createAction('INCREMENT');increment(); // &#123; type: 'INCREMENT' &#125;increment([1, 42]); // &#123; type: 'INCREMENT', payload: [1, 42] &#125;const updateAdminUser = createAction( 'UPDATE_ADMIN_USER', updates =&gt; (-updates), (updates) =&gt; (&#123; admin:updates&gt;-1 &#125;));updateAdminUser(1);// &#123;// type: 'UPDATE_ADMIN_USER',// payload: -1,// meta: &#123; admin: true &#125;,// &#125;const noop = createAction('NOOP');const error = new TypeError('not a number');noop(error);//&#123;// type: 'NOOP',// payload: error,// error: true//&#125; createActions创建多个actionCreatorcreateActions(actionMap, ...actionTypes, options)，返回值{[key:actionType]:actionCreator}格式的对象，key符合驼峰命名。 参数解释如下 actionMap：对象类型，可以是递归数据结构，key为actionType，值可以为如下几种 payloadCreator函数 payloadCreator和metaCreator组成的数组，metaCreator必须有 actionMap对象 actionTypes：字符串 options，可以为actiontype添加前缀 prefix: 前缀 namespace: 分隔符 123456789101112131415161718192021222324252627282930313233343536373839404142createActions(&#123;&#125;, 'INCREMENT', &#123; prefix: 'counter', namespace: '--'&#125;// counter--INCREMENTconst actionCreators = createActions( &#123; APP: &#123; COUNTER: &#123; INCREMENT: [ amount =&gt; (&#123; amount &#125;), amount =&gt; (&#123; key: 'value', amount &#125;) ], DECREMENT: amount =&gt; (&#123; amount: -amount &#125;), &#125;, NOTIFY: [ (username, message) =&gt; (&#123; message: `$&#123;username&#125;: $&#123;message&#125;` &#125;), (username, message) =&gt; (&#123; username, message &#125;) ] &#125;, &#125;, 'ACTION_THREE');actionCreators.app.counter.increment(1);// &#123;// type: 'APP/COUNTER/INCREMENT',// payload: &#123; amount: 1 &#125;,// meta: &#123; key: 'value', amount: 1 &#125;// &#125;actionCreators.app.notify('yangmillstheory', 'Hello World');// &#123;// type: 'APP/NOTIFY',// payload: &#123; message: 'yangmillstheory: Hello World' &#125;,// meta: &#123; username: 'yangmillstheory', message: 'Hello World' &#125;// &#125;actionCreators.actionThree(3);// &#123;// type: 'ACTION_THREE',// payload: 3// &#125; handleAction(s)reducer handleAction创建单个action的reducerhandleAction(type, reducer | reducerMap = Identity, defaultState) 参数解释如下 type：字符串类型 reducer：function，处理action reducerMap：{next(){},throw(){}}，分别处理正确的action和错误的action defaultState：初始state，必须传 1234567891011handleAction( 'APP/COUNTER/INCREMENT', (state, action) =&gt; (&#123; counter: state.counter + action.payload.amount &#125;), defaultState);handleAction('FETCH_DATA', &#123; next(state, action) &#123;...&#125;, throw(state, action) &#123;...&#125;,&#125;, defaultState); handleActions创建多个action的reducerhandleActions(reducerMap, defaultState, options);，运用redux-reducers combineReducers(...reducers)和reduceReducers(...reducers)的区别 combineReducers，每个reducer维护自己的state reduceReducers， 每个reducer维护同一个state 参数解释如下 reducerMap：对象或数组类型 defaultState：初始state，必须传 options，对应createActions的options参数 prefix: 前缀 namespace: 分隔符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const increment = createAction(INCREMENT);const decrement = createAction(DECREMENT);// reducerMap 方式1const reducer = handleActions( &#123; INCREMENT: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;), DECREMENT: (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;) &#125;, &#123; counter: 0 &#125;);// reducerMap 方式2const reducer = handleActions( new Map([ [ INCREMENT, (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;) ], [ DECREMENT, (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;) ] ]), &#123; counter: 0 &#125;);// reducerMap 方式3const reducer = handleActions( new Map([ [ increment, (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;) ], [ decrement, (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;) ] ]), &#123; counter: 0 &#125;);// optionsconst options = &#123; prefix: 'counter', namespace: '--'&#125;createActions(&#123; ... &#125;, 'INCREMENT', options)handleActions(&#123; ... &#125;, defaultState, options) combineActionscombineActions(...types);，types可以是字符串，symbol类型，actionCreator 123456789101112131415161718192021222324const &#123; increment, decrement &#125; = createActions(&#123; INCREMENT: amount =&gt; (&#123; amount &#125;), DECREMENT: amount =&gt; (&#123; amount: -amount &#125;)&#125;);const reducer = handleActions( &#123; [combineActions(increment, decrement)]: ( state, &#123; payload: &#123; amount &#125; &#125; ) =&gt; &#123; return &#123; ...state, counter: state.counter + amount &#125;; &#125; &#125;, &#123; counter: 10 &#125;);reducer(&#123; counter: 5 &#125;, increment(5));//&#123; counter: 10 &#125;reducer(&#123; counter: 5 &#125;, decrement(5));// &#123; counter: 0 &#125;reducer(&#123; counter: 5 &#125;, &#123; type: 'NOT_TYPE', payload: 1000 &#125;);// &#123; counter: 5 &#125;reducer(undefined, increment(5));// &#123; counter: 15 &#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript]]></title>
    <url>%2F2019%2F06%2F28%2FTypescript%2F</url>
    <content type="text"><![CDATA[TypeScript 是微软开发的JavaScript的超集，主要在JavaScript的基础上添加了可选的静态类型和基于类的面向对象编程 开源于 GitHub 可以编译成纯 JavaScript TypeScript 编译工具可以运行在任何服务器和任何系统上 优缺点优点增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误 增强编辑器和IDE的功能，包括代码补全、接口提示、跳转到定义、重构等 对于一个需要长期维护的项目，能够减少其维护成本 缺点 短期可能会增加一些开发成本 集成到构建流程需要一些工作量 可能和一些第三方库结合的不是很完美 安装及编译 安装npm install typescript -g 查看版本tsc -v 编译tsc hello.ts 1234567891011function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user));// 编译结果// function sayHello(person) &#123;// return 'Hello, ' + person;// &#125;// var user = [0, 1, 2];// console.log(sayHello(user)); TypeScript只会进行静态检查，编译报错时，还是会生成编译结果js文件 编译报错终止js文件生成，可以在tsconfig.json中配置 noEmitOnError 数据类型原始数据类型布尔值boolean Typescript中，构造函数 Boolean创造的对象，不是boolean类型，而是Boolean对象 Typescript中，直接调用 Boolean返回的是boolean类型 123let isHappy:boolean=true; // var isHappy=true;let isSad:boolean=new Boolean(0);// 报错let isCry:boolean=Boolean(1); // var isCry=Boolean(1); 数值number 二进制和八进制表示法，会被编译为十进制数字，而十六进制不会 12345678let decLiteral: number = 6;// var decLiteral = 6;let hexLiteral: number = 0xf00d;//var hexLiteral = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;//var binaryLiteral = 10;// ES6 中的八进制表示法let octalLiteral: number = 0o744;//var octalLiteral = 484;let notANumber: number = NaN;//var notANumber = NaN;let infinityNumber: number = Infinity;//var infinityNumber = Infinity; 字符串string 模板字符串也是string类型 123456let myName: string = 'Tom';let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; 空值void void类型，只能赋值undefined或null 1234function alertName(): void &#123; alert('My name is Tom');&#125;let unusable: void = undefined; null和undefined undefined 和 null 是除了never其他所有类型的子类型 null类型，只能赋值null null类型的值能赋值给除了undefined、never类型以外的所有类型 1let n: null = null; undefined类型，只能赋值undefined undefined类型的值能赋值给除了null、never类型以外的所有类型 1let u: undefined = undefined; symbolES6中symbol类型 非原始类型object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。let aa:object={aaa:111}通过 任意类型any any类型，允许赋值任意类型的值 any类型上，访问任何属和调用任何方法都是允许的 123let anyThing: any = 'hello';console.log(anyThing.myName);anyThing.setName('Jerry').sayHello(); 联合类型联合类型使用|分隔每个类型，表示赋值可以为多种类型中的一种。如let myFavoriteNumber: string | number; 访问联合类型的属性或方法 联合类型的变量没有赋值时，只能访问该变量的所有类型里共有的属性或方法 1234function getLength(something: string | number): string &#123; //不能访问something.length，length不是number的属性 return something.toString();&#125; 联合类型的变量赋值时，会根据类型推论的规则推断出一个类型 12345let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length); // 通过myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 报错 type类型的别名我们使用type 创建类型别名，类型别名常用于联合类型。 123456789101112131415161718192021type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125;// 等价于interface NameResolver&#123; ():string;&#125;function getName(n: string|NameResolver): string &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型用type定义字符串字面量类型，来约束取值，只能是某几个字符串中的一个。 123456type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(event: EventNames) &#123; // do something&#125;handleEvent('scroll'); // 通过handleEvent('dbclick'); // 报错 数组类型 类数组不是数组类型 项类型[]，表示数组类型时，数组项中不允许出现其他类型 1234let ary:number[]=[1,2,3,4,5];// 通过ary.push('6');// 报错let aryErr:number[]=[1,'2',3,4,5];// 报错let ary2:(number|string)[]=[1,2,'3',4];// 通过 常见用法：any[]表示数组中允许出现任意类型 数组泛型Array&lt;项类型&gt;，表示数组类型 12let ary:Array&lt;number&gt;=[1,2,3,4,5];let ary2:Array&lt;number|string&gt;=[1,2,'3',4]; 元组（Tuple）[第一项类型，第二项类型]，如let xcatliu: [string, number] = [&#39;Xcat Liu&#39;, 25]; 当赋值或访问一个已知索引的元素时，会得到正确的类型 12345let xcatliu: [string, number];xcatliu[0] = 'Xcat Liu';xcatliu[1] = 25;xcatliu[0].slice(1);xcatliu[1].toFixed(2); 可以单独赋值其中的项 12let xcatliu: [string, number];xcatliu[1] = 2; 对元组类型的变量整体进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。 12let xcatliu: [string, number];xcatliu = ['Xcat Liu', 25];// 通过，如果xcatliu =['Xcat Liu']则报错 越界的元素被添加时，其类型限制为元组中每个类型的联合类型 1234let xcatliu: [string, number];xcatliu = ['Xcat Liu', 25];xcatliu.push('http://xcatliu.com/');// 通过xcatliu.push(true);// 报错 枚举类型enum枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天 普通枚举枚举使用enum定义 123456789101112// enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;// 编译后var Days;(function (Days) &#123; Days[Days["Sun"] = 0] = "Sun"; Days[Days["Mon"] = 1] = "Mon"; Days[Days["Tue"] = 2] = "Tue"; Days[Days["Wed"] = 3] = "Wed"; Days[Days["Thu"] = 4] = "Thu"; Days[Days["Fri"] = 5] = "Fri"; Days[Days["Sat"] = 6] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 因此，枚举成员会被默认赋值为从0开始递增的数字，并且会对枚举值到枚举名进行反向映射 1234567enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;let sat: Days = Days.Sat;// 通过let sun:number=Days.Sun;// 通过console.log(Days["Sun"] === 0); // trueconsole.log(Days["Sat"] === 6); // trueconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[6] === "Sat"); // true 手动赋值可以给枚举项手动赋值，未手动赋值的枚举项会接着上一个枚举项递增1，值可以重复，反向映射的枚举值的取值会被后面的枚举名覆盖 第一个枚举项未手动赋值，则赋值为0 手动赋值可以为小数或负数，未手动赋值的枚举项仍会接着上一个枚举项递增1 手动赋值的枚举项可以不是数字，但需要使用类型断言来让 tsc 无视类型检查，并且如果后面有相邻的枚举项，也要手动赋值 123456enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat= &lt;any&gt;"S"&#125;;console.log(Days["Sun"] === 3); // trueconsole.log(Days["Wed"] === 3); // trueconsole.log(Days[3] === "Sun"); // falseconsole.log(Days[3] === "Wed"); // trueconsole.log(Days['S'] === "Sat"); // true 常数项和计算所得项枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。 常数项 未手动赋值的枚举成员 使用常数枚举表达式手动赋值的枚举成员，常数枚举表达式可以在编译阶段求值，类型如下 数字字面量 引用其他的常数枚举成员（可以是不同的枚举类型中的） +, -, ~一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^二元运算符，常数枚举表达式做为其一个操作对象。求值结果为NaN或Infinity，会在编译阶段报错 非常数项的枚举成员都是计算所得项 常数枚举使用const enum定义的枚举类型 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员 123456789const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 编译为// var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举使用declare enum定义的枚举类型 declare定义的类型只会用于编译时的检查，编译结果中会被删除。外部枚举常出现在声明文件中，可以同时使用declare和const 1234567891011121314151617181920declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 编译结果// var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 同时使用 declare 和 const 也是可以的declare const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 编译结果var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; nevernever类型，表示永不存在的值的类型，一般用来给没有返回值的函数表达式指定返回值类型。 never 是其他类型 （包括 null 和 undefined）的子类型 1234567let aa:never;aa=(()=&gt;&#123; throw new Error('错误');&#125;)();function error():never&#123; throw new Error('错误');&#125; 类型推论（Type Inference） 在声明变量并赋值时，默认(未指定其类型时)依照类型推论的规则指定一个类型。 在声明变量并且没有赋值时，默认(未指定其类型时)为任意值类型 12let myFavoriteNumber = 'seven';// 等价于 let myFavoriteNumber: string = 'seven';let something;// 等价于 let something: any; 类型断言将一个变量指定为一个更加具体的类型，可以解决联合类型只能访问所有类型里共有的属性或方法的问题，有两种语法形式 类型断言不是类型转换，断言成一个联合类型中不存在的类型或非子类型是不允许的 &lt;类型&gt;变量，jsx语法中不能使用这种 12345678910function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125;let someValue:string= "this is a string";let strLength: number = &lt;null&gt;someValue;//通过，如果let strLength: number = someValue;报错 变量 as 类型，jsx语法中只能使用这种 函数的类型定义函数的输入和输出都要进行约束，类型定义 输入多的或者少的参数，都是不被允许的 123456789101112131415161718192021222324252627// 声明式function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1,2);sum(1);// 报错sum(1,2,3);// 报错// 表达式// 只对=右侧匿名函数进行了类型定义，左侧变量通过类型推论得出类型let mySum = function (x: number, y: number): number &#123; return x + y;&#125;;// 手动给变量添加类型// 与箭头函数毫无关系let mySum: (one: number, two: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;;// 接口定义interface ISum&#123; (one:number,two:number):number;&#125;let otherSum:ISum;otherSum=function (x: number, y: number): number &#123; return x + y;&#125;; 可选参数，以?表示，可选参数后面不允许再出现必须参数 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125; &#125; let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom'); 参数默认值，添加了默认值的参数会被识别为可选参数，并且其后面可以出现必须参数 12345function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 剩余参数，以用数组类型来定义，剩余参数只能是最后一个参数 12345678function push(array: any[], ...items: any[]) &#123; items.forEach(function(item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 重载允许一个函数输入不同数量或类型的参数时，作出不同的处理 1234567891011function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return Number(x.split('').reverse().join('')); &#125;&#125;let aa:number=reverse('s');// 报错let aa:string=reverse('s');// 通过 优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 接口描述对象形状用接口（Interfaces）来定义对象的类型。 接口名称一般首字母大写（最好以I为前缀） 赋值的时候，变量的形状必须和接口的形状保持一致（除了可选属性以外，变量的属性必须与接口的一致） 确定属性 1234567891011121314// 定义接口Personinterface Person&#123; name:stiring; age:number;&#125;// 定义对象数据类型let tom:Person=&#123; name:'Tom', age:18&#125;// 变量不能比接口少属性，也不能多let amy:Person=&#123; name:'Amy'&#125;// 报错 可选属性，以?表示，表示该属性可以不存在 12345678910111213interface Person &#123; name: string; age?: number;// 可选属性&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'// 报错&#125;;let amy:Person=&#123; name:'Amy'&#125;;// 通过 任意属性，[propName: string]定义键为string类型 123456789101112131415interface Person &#123; name: string; age?: number; [x: string]: string|number;&#125;// 通过let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;// 通过interface Dog=&#123; name: string; age?: number; [y:string]:string;&#125;// 报错// 确定属性和可选属性的类型必须是任意属性类型的子集 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 只读属性，以readonly表示，表示属性只能在对象创建的时候被赋值，之后不能修改 123456789101112interface Person &#123; readonly id?: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; // id: 89757, name: 'Tom', gender: 'male'&#125;;// 通过tom.id = 9527; // 报错 描述数组形状，[index:number]定义键为number类型 1234interface INumberArray&#123; [index:number]:number;&#125;let ary:INumberArray=[1,2,3,4,5]; 描述函数形状 1234567interface ISum&#123; (one:number,two:number):number;&#125;let otherSum:ISum;otherSum=function (x: number, y: number): number &#123; return x + y;&#125;; 抽象类的部分行为用implements关键字来把类之间的共有特性提取成接口 12345678910111213141516171819202122232425interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm,Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 混合类型接口函数可以有自己的属性和方法，需要混合类型接口 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 继承使用extends 接口继承接口，接口之间可以是继承关系 123456789101112131415161718interface Alarm &#123; alert();&#125;interface LightableAlarm extends Alarm &#123; lightOn(); lightOff();&#125;class Car implements LightableAlarm&#123; lightOff() &#123; console.log(1); &#125; lightOn() &#123; console.log(0); &#125; alert() &#123; console.log(3); &#125;&#125; 接口继承类 123456789class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 类TypeScript的类中可以使用三种访问修饰符 public: 修饰的属性或方法是公有的，可以在任何地方被访问到 12345678910class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom private：修饰的属性或方法是私有的，不能在声明它的类的外部访问（子类不能访问） 123456789101112131415class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // 报错a.name = 'Tom';// 报错class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name);// 报错 &#125;&#125; protected：修饰的属性或方法是受保护的，它和private的区别是它在子类中允许被访问 123456789101112class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); // 通过 &#125;&#125; 抽象类abstract用于定义抽象类*和其中的抽象方法。 即使是抽象方法，TypeScript的编译结果中，仍然会存在这个类 抽象类不允许被实例化 12345678abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack');// 报错 抽象类中的抽象方法必须被子类实现 12345678910111213abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat('Tom'); 类的类型与接口类似 1234567891011class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); 泛型（Generics）泛型，指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。用&lt;类型参数&gt;定义 12345678function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x'] 泛型的类型参数 多个类型参数 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, 'seven']); // ['seven', 7] 类型参数能指定默认值。使用泛型时，没有指定类型参数值，类型推测也无法得出，默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 泛型约束使用了extends约束了泛型必须符合接口的形状 12345678910interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;loggingIdentity(7);// 报错loggingIdentity('s');// 通过loggingIdentity(&#123;name:'aaa',length:6&#125;;// 通过 多个类型参数之间也可以互相约束 12345678910// 保证了 U 上不会出现 T 中不存在的字段function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 泛型接口泛型可以用于接口的类型定义中 可以使用含有泛型的接口来定义函数的形状 123456789101112interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 可以把泛型参数提前到接口名上 使用时，需要定义泛型的类型 123456789101112interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 泛型类泛型可以用于类的类型定义中 1234567class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 声明合并定义了两个相同名字的函数、接口或类，会合并成一个类型 函数的声明合并使用重载定义多个函数类型，会合并成一个类型 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 接口的声明合并 接口中方法的合并，与函数的合并一样 合并的属性可以重复，但属性的类型必须是一致的 12345678910111213141516interface Alarm &#123; price: number; alert(s: string): string;&#125;interface Alarm &#123; price: number;// 如果是price: string; 则报错 weight: number; alert(s: string, n: number): string;&#125;// 等价于// interface Alarm &#123;// price: number;// weight: number;// alert(s: string): string;// alert(s: string, n: number): string;// &#125; 类的合并类的合并与接口的合并规则一致。 声明文件TypeScript编译器只能从TypeScript代码文件里获取类型信息。在TypeScript中引用JavaScript文件，需要通过声明文件（通常我们会把声明语句放到一个单独的文件中，以.d.ts为后缀），声明文件描述JavaScript模块内所有导出接口的类型信息 声明语句仅仅用于编译时，在编译结果中不会存在，所以用ts写的模块仍然是用js发布。因此需要有.d.ts文件标记模块里的对象类型，供其他ts使用者调用 声明语句只定义类型，如declare const jQuery: (selector: string) =&gt; any;，禁止定义具体的实现，如declare const jQuery = function(selector) {}是不被允许的 推荐使用@types管理第三方库的声明 全局变量声明引用非模块化的JavaScript文件，通过&lt;script&gt;标签引入第三方库，注入全局变量，比如jQuery.js 全局变量声明文件只需要放在项目目录下，ts编辑器会解析项目中所有.ts文件 在全局变量的声明文件中，是不允许出现import，export关键字的。一旦出现了，那么他就会被视为一个npm包或UMD库 声明语句 作用 declare var/declare let 声明全局变量 declare const 声明全局常量 declare function 声明全局方法，函数重载也支持 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明全局对象（含有多个子属性的） declare namespace内部使用function、const、class、enum等语句定义类型 12345678910111213141516// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; const version: number; class Event &#123; blur(eventType: EventType): void &#125; enum EventType &#123; CustomClick &#125;&#125;// src/index.tsjQuery.ajax('/api/get_something');console.log(jQuery.version);const e = new jQuery.Event();e.blur(jQuery.EventType.CustomClick); 对象拥有深层的层级，则需要用嵌套的namespace来声明深层的属性的类型 12345678910111213141516// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; namespace fn &#123; function extend(object: any): void; &#125;&#125;// src/index.tsjQuery.ajax('/api/get_something');jQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); 声明合并。假如jQuery既是一个函数，又是一个对象，拥有子属性。可以组合多个声明语句，它们会不冲突的合并起来 12345678// src/jQuery.d.tsdeclare function jQuery(selector: string): any;declare namespace jQuery &#123; function ajax(url: string, settings?: any): void;&#125;// src/index.tsjQuery('#foo');jQuery.ajax('/api/get_something'); 全局类型声明 声明语句 作用 interface和type 声明全局类型 interface和type，声明全局接口或类型 12345678910111213141516// src/jQuery.d.tsinterface AjaxSettings &#123; method?: 'GET' | 'POST' data?: any;&#125;declare namespace jQuery &#123; function ajax(url: string, settings?: AjaxSettings): void;&#125;// src/index.tslet settings: AjaxSettings = &#123; method: 'POST', data: &#123; name: 'foo' &#125;&#125;;jQuery.ajax('/api/post_something', settings); 防止命名冲突，我们应该尽可能的减少全局变量或全局类型的数量，最好将他们放入namespace 12345678910111213141516// src/jQuery.d.tsdeclare namespace jQuery &#123; interface AjaxSettings &#123; method?: 'GET' | 'POST' data?: any; &#125; function ajax(url: string, settings?: AjaxSettings): void;&#125;// src/index.ts// 使用接口时，加上前缀let settings: jQuery.AjaxSettings = &#123; method: 'POST', data: &#123; name: 'foo' &#125;&#125;; npm包的声明文件通过import foo from &#39;foo&#39;导入，符合ES6模块规范。 npm包的声明文件可能存在于两个地方： package.json中,有types字段或者有index.d.ts声明文件。这种模式不需要额外安装其他包，最为推荐的 发布到@types里。只需要尝试安装对应的@types包npm install @types/foo --save-dev，不需要其他配置。这种模式一般由于npm包的维护者没有提供声明文件，由其他人将声明文件发布 自己为npm包写声明文件 创建types目录，管理自己的声明文件 将声明文件放在types/npm包名/index.d.ts 配置tsconfig.json中的paths和baseUrl字段。，import导入时，也会去types目录下寻找对应模块的声明文件 module 配置可以有很多种选项，不同的选项会影响模块的导入导出模式 声明语句 作用 export 导出变量 export const 导出常量 export function 导出方法 export class 导出类 export enum 导出枚举类型 export namespace 导出对象（含有多个子属性的） export interface和export type 导出类型 export default 导出默认值的类型 export = commonjs规范中导出 在npm包的声明文件中，declare声明的是局部变量而不是全局变量。需要用export导出，在调用时用import导入后 12345678910111213141516171819202122// 导出1// types/foo/index.d.tsexport const name: string;export function getName(): string;export class Animal &#123; constructor(name: string); sayHi(): string;&#125;// src/index.tsimport &#123; name, getName, Animal, Directions, Options &#125; from 'foo';// 导出2// types/foo/index.d.tsdeclare const name: string;declare function getName(): string;declare class Animal &#123; constructor(name: string); sayHi(): string;&#125;export &#123; name, getName, Animal&#125;;// src/index.tsimport &#123; name, getName, Animal, Directions, Options &#125; from 'foo'; 导出默认值类型export default，只有function、class和interface可以直接默认导出，其他需要先定义再默认导出 1234567891011121314151617181920// types/foo/index.d.ts//通过export default function foo(): string;// 通过export default Directions;declare enum Directions &#123; Up, Down, Left, Right&#125;// 报错export default enum Directions &#123; Up, Down, Left, Right&#125; commonjs规范中导出export =，不能单个导出 123456// types/foo/index.d.tsexport = foo;declare function foo(): string;declare namespace foo &#123; const bar: number;&#125; UMD库的声明文件既可以通过&lt;script&gt;标签引入，又可以通过import导入 声明语句 作用 export as namespace UMD 库声明全局变量 基于npm包声明文件，添加一条export as namespace语句 1234567891011// types/foo/index.d.tsexport as namespace foo;export = foo;// 或// export as namespace foo;// export default foo;declare function foo(): string;declare namespace foo &#123; const bar: number;&#125; 扩展全局变量第三方库扩展了一个全局变量，却没有相应的更新类型，就会导致 ts 编译错误，此时就需要扩展全局变量的类型 直接扩展全局变量 通过声明合并，使用interface，扩展全局变量的类型 1234interface String&#123; prependHello():string;&#125;'foo'.prependHello(); 使用declare namespace，给已有的命名空间添加类型声明 1234567891011121314// types/jquery-plugin/index.d.tsdeclare namespace JQuery &#123; interface CustomOptions &#123; bar: string; &#125;&#125;interface JQueryStatic &#123; foo(options: JQuery.CustomOptions): string;&#125;// src/index.tsjQuery.foo(&#123; bar: ''&#125;); 在npm包或UMD库的声明文件中扩展全局变量，要使用declare global，因为只有export导出的类型声明才被导入 12345678910// types/foo/index.d.tsdeclare global &#123; interface String &#123; prependHello(): string; &#125;&#125;export &#123;&#125;;// src/index.ts'bar'.prependHello(); 即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。 模块插件的声明文件处理导入模块插件后，可能改变对应模块的结构。如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，会导致类型不完整，需要扩展原有模块的类型 需要在类型声明文件中先引用原有模块，再使用declare module扩展原有模块 12345678910// types/moment-plugin/index.d.tsimport * as moment from 'moment';declare module 'moment' &#123; export function foo(): moment.CalendarKey;&#125;// src/index.tsimport * as moment from 'moment';import 'moment-plugin';moment.foo(); declare module也可用于在一个文件中一次性声明多个模块的类型 12345678910111213141516// types/foo-bar.d.tsdeclare module 'foo' &#123; export interface Foo &#123; foo: string; &#125;&#125;declare module 'bar' &#123; export function bar(): string;&#125;// src/index.tsimport &#123; Foo &#125; from 'foo';import * as bar from 'bar';let f: Foo;bar.bar(); 声明文件中的依赖一个声明文件有时会依赖另一个声明文件 通过import导入另一个声明文件 12345// types/moment-plugin/index.d.tsimport * as moment from 'moment';declare module 'moment' &#123; export function foo(): moment.CalendarKey;&#125; /// &lt;reference /&gt;三斜线指令（必须放在文件的最顶端，前面只能有注释），导入另一个声明文件 /// &lt;reference typrs=&quot;jquery&quot;/&gt;, 用于声明对另一个库的依赖 /// &lt;reference path=&quot;jquery.d.ts&quot;/&gt;, 用于声明对另一个文件的依赖 一般建议使用import，只有以下几种情况，不能使用import，需要三斜线指令 当在一个全局变量的声明文件中 123456// types/jquery-plugin/index.d.ts/// &lt;reference types="jquery" /&gt;declare function foo(options: JQuery.AjaxSettings): string;// src/index.tsfoo(&#123;&#125;); - 当需要依赖一个全局变量的声明文件时 1234567// types/node-plugin/index.d.ts/// &lt;reference types="node" /&gt;export function foo(p: NodeJS.Process): string;// src/index.tsimport &#123; foo &#125; from 'node-plugin';foo(global.process); 自动生成声明文件如果库的源码本身就是由ts写的，那么在使用tsc脚本将ts编译为js时，添加 declaration选项，就可以同时自动为每个ts文件生成对应的.d.ts声明文件。 在命令行中添加，tsc *.ts --declaration 在tsconfig.json中添加，declaration选项 1234567&#123; "compilerOptions": &#123; "module": "commonjs", "outDir": "lib", "declaration": true, &#125;&#125; tsconfig.json``compilerOptions选项中，其他关于自动生成声明文件的选项 outDir，设置ts文件编译结果输出目录 declarationDir：设置生成.d.ts文件的目录 declarationMap： 对每个.d.ts文件，都生成对应的.d.ts.map（sourcemap）文件 emitDeclarationOnly：仅生成.d.ts文件，不生成.js文件 发布声明文件 将声明文件和源码放在一起，推荐做法 如果自动生成声明文件，就不需要做其他配置，只需要把编译好的文件也发布到npm上 如果是手动写的声明文件，还需要满足以下条件之一 给package.json中的types或typings字段指定一个类型声明文件地址 在项目根目录下，编写一个index.d.ts文件。如果没有指定types或typings，就会寻找它作为此库的类型声明文件 针对入口文件（package.json中的main字段指定的入口文件），编写一个同名不同后缀的.d.ts文件。如果没有找到index.d.ts文件，就会寻找它作为此库的类型声明文件 将声明文件发布到@types下 内置对象JavaScript中有很多内置对象，它们可以直接在TypeScript中当做定义好了的类型。 ES的内置象，Boolean、Error、Date、RegExp等 12345// boolean类型和Boolean类型不等价let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; DOM和BOM的内置对象，Document、HTMLElement、Event、NodeList等 12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123;// Do something&#125;); TypeScript核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。但不包含Node.js部分，需要引入第三方声明文件npm install @types/node --save-dev]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言]]></title>
    <url>%2F2019%2F06%2F24%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[编程语言是一套与计算机交互的语法规则 主流语言 语言 介绍 C语言 各种操作系统的开发语言 C++ C语言的加强版（C语言太底层），对C语言的进一步扩展和完善 java java虚拟机，支持跨平台（不同操作系统） php 纯web开发语言 C# 运行于.NET Framework Ruby 与python非常相似，Ruby on rails (web框架) perl 文字处理强大，新手老手区别非常大，不容易配合开发大型项目 shell 脚本语言，做一些简单的系统管理任务，运维必学 python Go 具有C语言的编译速度 javascript 使用最为广泛的语言，主要写前端的语言，nodejs，全栈式语言 lua nginx(时下最nb的web服务器)的脚本语言 语言分类低级语言面向机器的计算机语言，无法独立于机器（特定的CPU体系结构） 机器指令 –&gt; 汇编指令 –&gt; 汇编语言（汇编语言需要翻译成机器指令才能执行） 交叉汇编技术：使一些汇编程序获得不同机器之间的可移植性（将运行在一种机器上的汇编语言翻译成运行在另一种机器上的机器指令） 高级语言从人类的逻辑思维角度出发的计算机语言，能独立于机器。 程序本身不变，靠编译器编译得到的目标代码去适应不同的机器 可以编译成直接可执行的目标代码 可以编译成一种中间表示，然后在不同机器和系统上执行，需要支撑环境（解释器或虚拟机）的支持 解释型和编译型解释型执行时翻译，不生成可存储的目标代码，程序运行时的控制权在解释器。如python，php，ruby，javascript 优点 具有良好的可移植性，具有良好的平台兼容性，程序不用改动就可以在安装了解释器（虚拟机）的系统上运行。 具有良好的动态特性，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。 缺点 执行效率低，性能上不如编译型语言。 占用空间大，不仅要给用户程序分配空间，解释器本身也占用了宝贵的系统资源。 编译型翻译和执行分开，生成可存储的目标代码，把源程序编译并保存成二进制文件，执行时直接以机器语言来运行，程序运行时的控制权在用户程序。如C语言，C++，Go，Swift 优点 执行效率高，因为运行时不需要编译。 可以脱离语言环境独立运行。 缺点 编译后需要修改就需要整个模块重新编译。编译时根据对应的运行环境生成机器码 不同的操作系统之间移植会有问题，需要根据运行的操作系统环境编译不同的可执行文件。 链接（Link）和链接程序（Linker） 链接（Link）：复杂项目中，模块化来组织代码，各个文件源文件都编译生成对应目标文件。最后把这些目标文件打包成一个可执行文件的过程为链接（Link）。 链接程序（Linker）：负责完成链接的程序。链接程序除了链接目标文件外，还有各种资源，如图标文件、声音文件，还要负责去除目标文件之间的冗余重复代码 混合型 java：在执行之前进行预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行时由JVM（Java的虚拟机平台，可视为解释器）解释执行。保留了源代码的高抽象、可移植的特点，又比纯解释型程序执行效率高 C#：生成.net目标代码，实际执行时则由.net解释系统（虚拟机平台）进行执行 动态语言和静态语言 动态语言：编程时不用给任何变量指定数据类型，运行时才做数据类型检查（即在变量赋值时，才确定变量的数据类型，不用事先给变量指定数据类型）。如Python、Ruby 静态语言：在编译时检查数据类型，编程时要声明所有变量的数据类型。如C语言、C++、java、C# 强类型定义语言和弱类型定义语言 强类型定义语言：强制数据类型定义的语言（类型安全）。一个变量被指定了数据类型，不经过强制转换，它的数据类型不会改变，不能当做别的数据类型处理。如python 弱类型定义语言：数据类型可以被忽略的语言。一个变量可以赋不同数据类型的值。 强类型定义语言在速度上略逊色于弱类型定义语言，但能够有效避免许多错误]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3.0基础]]></title>
    <url>%2F2019%2F05%2F17%2Fpython3.0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[大小写敏感，强类型定义的动态语言优点：简单，高效，优雅，跨平台，可扩展。缺点：运行速度慢，代码不能加密 介绍概览 优缺点优点 简单，优雅，易懂 高效，有非常强大的第三方库，通过计算机实现任何功能，Python官方库里都有相应的模块进行支持 高级语言，无需考虑底层细节 可移植性，开源，可以被移植在许多平台上（经过改动依赖于系统的特性，它能工作在不同平台上）。如果避免使用依赖于系统的特性，则无需修改可以在市场上所有的系统平台上运行 可扩展性，可以在python中使用其他语言编写的程序，如C、C++ 可嵌入性，可以把Python嵌入C/C++程序，从而向程序用户提供脚本功能。 缺点 速度慢，比C语言和java慢，大多数情况下用户无法直接感知到速度差距，除非开发对速度要求极高的搜索引擎等 代码不能加密，因为解释型语言，它的源码都是以名文形式存放的 线程不能利用多CPU，即使在多核CPU平台上，因为GIL（全局解释器锁Global Interpreter Lock），所以禁止多线程的并行执行 python版本python3.x不兼容python2.x 版本 默认编码 python2.x ASCII python3.x UNICODE(万国码，支持所有国家和地区的编码) python2.x中使用中文需要声明编码类型，文件首行写入# coding:utf-8 12#coding:utf-8print("你好") python解释器python解释器是一款应用程序，专门用来解释python这门语言的语法风格并执行的，可以这么说python语言更多地都是在调用python解释器的功能，所以解释器性能的高低很大程度决定了我们用python写出来的程序执行效率的高低 CPython：官方版本的解释器，C语言开发的，使用最广泛 IPython：基于CPython之上的一个交互式解释器，只是在交互方式上有所增强执行Python代码的功能和CPython是完全一样。 PyPy： 显著提高Python代码的执行速度，采用JIT技术 PyPy和CPython有一些不同，相同的Python代码在两种解释器下执行可能会有不同的结果 Jython：Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行 IronPython：运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码 如果要和Java或.Net平台交互，最好的办法是通过网络调用来交互 命令行 python在命令行模式下进入python交互模式，提示符&gt;&gt;&gt; exit()退出python交互模式，回到命令行模式 python filename.py执行python文件 交互模式下，上一次打印出来的结果被复制给变量_ 12345&gt;&gt;&gt;num=9&gt;&gt;&gt;num*0.10.9&gt;&gt;&gt;num+_9.9 注释123456789# 单行注释'''多行注释'''"""多行注释""" 变量 python是动态语言，变量类型不固定 =是赋值语句，同一个变量可以反复赋值 变量有三大组成部分： 变量名：是指向等号右侧值的内存地址的，用来访问等号右侧的值 赋值符号：将变量值的内存地址绑定给变量名 变量值：代表记录的事物的状态 变量名的命名的规则 变量名不能与保留字符相同 为了代码的可读性，变量名要具有描述性 变量名必须是大小写英文、数字和_的组合，且不能用数字开头 通常用全部大写的变量名表示常量(不变的变量，如代表数学常数π的变量)，这只是习惯上的用法，实际常量仍是变量，没有任何机制保证它不会被改变 命名风格： 纯小写加下划线的方式(在python中，关于变量名的命名推荐使用这种方式) 驼峰体 变量值的三个重要特征1234567name='xxx'# id：反映的是变量值的内存地址，内存地址不同id则不同print(id(name))# type：不同类型的值用来表示记录不同的状态print(type(name))# value：值本身print(name) is与== is：比较左右两个值身份id是否相等 ==：比较左右两个值他们的值是否相等 id不同的情况下，值有可能相同，即两块不同的内存空间里可以存相同的值 id相同的情况下，值一定相同，x is y成立，x == y也必然成立 12345x='info：Egon：18'y='info：Egon：18'print(id(x),id(y)) # 4565819264 4566192176print(x == y) # Trueprint(x is y) # False 变量存储&amp;垃圾回收机制 变量的存储内存中有两块区域：堆区与栈区，在定义变量时，变量名与值内存地址的关联关系存放于栈区，变量值存放于堆区，内存管理回收(垃圾回收)的是堆区的内容 垃圾回收机制垃圾回收机制（简称GC）是Python解释器自带一种机制，专门用来回收不可用的变量值所占用的内存空间。 主要运用了“引用计数”来跟踪和回收垃圾。 在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题， 并且通过“分代回收”以空间换取时间的方式来进一步提高垃圾回收的效率。 引用计数（reference counting） 引用计数：变量值被变量名关联的次数 age=&#39;10&#39; 引用计数增加 m=age 引用计数减少 age=10,del m 变量值被关联次数的增加或减少，都会引发引用计数机制的执行，存在执行效率问题 引用计数的致命的弱点:循环引用（交叉引用）12345678910l1=['xxx'] # 列表1被引用一次，列表1的引用计数变为1l2=['yyy'] # 列表2被引用一次，列表2的引用计数变为1l1.append(l2) # 把列表2追加到l1中作为第二个元素，列表2的引用计数变为2l2.append(l1) # 把列表1追加到l2中作为第二个元素，列表1的引用计数变为2# l1与l2之间有相互引用# l1 = ['xxx'的内存地址,列表2的内存地址] &gt;&gt;&gt; ['xxx', ['yyy', [...]]]# l2 = ['yyy'的内存地址,列表1的内存地址] &gt;&gt;&gt; ['yyy', ['xxx', [...]]]del l1 # 列表1的引用计数减1，列表1的引用计数变为1del l2 # 列表2的引用计数减1，列表2的引用计数变为1 两个列表的引用计数均不为0，但两个列表不再被任何其他对象关联，没有任何人可以再引用到它们，所以它俩占用内存空间应该被回收，但由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放，导致内存泄露，所以循环引用是致命的。解决办法标记清除算法 标记&amp;清除（mark and sweep）为了解决循环引用的问题，标记清除算法的做法是当应用程序可用的内存空间被耗尽时，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项则是清除 标记：标记的过程就行相当于从栈区出发一条线，“连接”到堆区，再由堆区间接“连接”到其他地址，凡是被这条自栈区起始的线连接到内存空间都属于可以访达的，会被标记为存活。具体地：标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。 直接引用指的是从栈区出发直接引用到的内存地址，间接引用指的是从栈区出发引用到堆区后再进一步引用到的内存地址 清除：清除的过程将遍历堆中所有的对象，将没有标记存活的对象全部清除掉。 在启用标记清除算法时，发现栈区内不再有l1与l2（只剩下堆区内二者的相互引用），于是列表1与列表2都没有被标记为存活，二者会被清理掉，这样就解决了循环引用带来的内存泄漏问题。 分代回收（generation collection）提高回收效率，分代回收采用的是用“空间换时间”的策略。根据存活时间来为变量划分不同等级(即分代)，等级（代）越高，被垃圾回收机制扫描的频率越低。 回收依然是使用引用计数作为回收的依据 新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低 小整数池从python解释器启动那一刻开始，就会在内存中事先申请好一系列内存空间存放好常用的整数，解释器中为-5到256的整数，在pycharm中这个范围被优化的更大了一点 数据类型 python是强类型定义语言 数学运算结果类型由参与运算的数据类型决定，由高到低为复数&gt;浮点数&gt;分数&gt;整数复数与复数、整数、浮点数、分数的运算结果为复数，虚数前的参数可以为0，即如13+0jNone和字符串不能直接与整数、浮点数、分数、复数进行运算字符串之间可以进行拼接，即+操作 整数int(integer) 十进制：100,-100 十六进制，0x为前缀0-9、a-f表示：0xff00，0xa5b4c3d2 整数没有需要掌握的内置方法，他们的使用就是数学运算+比较运算 整数没有大小限制 类型转换及进制转换 int：可以将由纯整数构成的字符串直接转换成整型，若包含其他任意非整数符号，则会报错 12345678910111213# 10进制 -&gt; 二进制bin(11) # '0b1011'# 10进制 -&gt; 八进制oct(11) # '0o13'# 10进制 -&gt; 十六进制hex(11) # '0xb'# 二进制 -&gt; 10进制int('0b1011',2) # 11# 八进制 -&gt; 10进制int('0o13',8) # 11# 十六进制 -&gt; 10进制int('0o13',16) # 11 浮点数(小数)(float)对于很大或很小的浮点数，必须用科学计数法表示，把10用e替代，1.23，1.23e9代表1.23*10^9，1.23e-5代表0.0000123 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法也是精确的），而浮点数运算则可能会有四舍五入的误差浮点数没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 浮点数没有需要掌握的内置方法，他们的使用就是数学运算+比较运算 类型转换 float：可以将由小数构成的字符串直接转换成小数，若包含其他任意非小数符号，则会报错 1float("3.1") # 3.1 复数(complex)支持复数，使用后缀j或者J就可以表示虚数，3+5j。或者complex(3,5) 分数(fractions.Fraction)声明前要引入标准库fractions 12&gt;&gt;&gt;import fractions&gt;&gt;&gt;x=fractions.Fraction(1,10)&gt;&gt;&gt;print(x) 字符串(str) &#39;abc&#39;或&quot;abc&quot;，单引号或双引号表示单行内容，不能混用 &#39;&#39;&#39;，&quot;&quot;&quot;表示多行内容，回车行会自动包含到字符串中，如果不想包含，在行尾加\ 内容内的&#39;或&quot;用\转义符标识 r表示字符串内部不转义 len(str)获取字符串长度 123456789101112131415161718192021222324252627282930# 单行print('I\'m "OK"')# I'm "Ok"print(r'I\'m "OK"')# I\'m "OK"# 多行print('''abc''')# # a# b# cprint('''\abc''')# a# b# cprint(r'''a\nbc''')# a\n# b# c 字符串在内存中以unicode编码表示，在传输和硬盘中以utf-8编码表示 类型转换 str：可以将任意数据类型转换成字符串类型 1234str([1,2,3]) # '[1, 2, 3]'str(&#123;"name":"xxx","age":18&#125;) # "&#123;'name': 'xxx', 'age': 18&#125;"str((1,2,3)) # '(1, 2, 3)'str(&#123;1,2,3,4&#125;) # '&#123;1, 2, 3, 4&#125;' 索引(获取单个字符) 索引为正数，从0开始递增，从字符串左往右索引 索引为复数，从-1开始递减，从字符串右往左索引 越界索引(超出字符串内容的索引)会产生错误 123msg='hello world'msg[0] # 'h'msg[-1] # 'd' 切片(获取子字符串)str[n:m:x]：从索引n(包括n)开始到索引m(不包括m)；x步长，可以为负数(反向步长) n在m左边时能取到值，否则为&#39;&#39; n不设置时，表示头开始切片 m不设置时，表示切片到末尾 1234567891011121314msg='hello world'msg[0:5] # 'hello'msg[:5] # 'hello'msg[0:-2] # 'hello wor'msg[-3:-2] # 'r'msg[-3:] # 'rld'# 步长msg[0:5:2] # 'hlo'# 反向步长msg[0:5:-2] # ''msg[5:0:-2] # ' le'# 把字符串倒过来msg[::-1] # 'dlrow olleh' 切片时使用越界索引(超出字符串内容的索引)不会产生错误，自动以界限为止 长度len：获取字符串长度 12msg='hello world'len(msg) # 11 运算 加法：字符串之间可以相加，但仅限于str与str之间进行（不推荐使用，因为str之间的相加效率极低） +：和字符串拼接 *：字符串重复 1'abc'*3 # 'abcabcabc' 成员运算in和not in 相邻的两个或多个字符串字面值会自动连接，字符串变量或表达式不行 内置方法strip,lstrip,rstrip(移除首尾两侧特定字符) strip：移除字符串左右两侧的符号，不传参，默认移除首尾空白字符(空格、\n、\t) lstrip：只移除左边的指定字符 rstrip：只移除右边的指定字符 只移除两边，不移除中间 12345678910# 默认去掉的空格，只移除两边，不移除中间msg=' hello world 'msg.strip() # 'hello world'msg.lstrip() # 'hello world 'msg.rstrip() # ' hello world'# 收尾移除多种字符msg='**/*=-**hello world**-=()**'msg.strip('*/-=()') # 'hello world' split,rsplit(按分隔符切分列表) split：把一个字符串按照某种分隔符从左往右进行切分，得到一个列表 rsplit：把一个字符串按照某种分隔符从右往左进行切分，得到一个列表 参数： 第一个：分隔符，默认分隔符是空白字符 第二个：分隔次数，为负数则无效 返回结果为列表数据类型 1234567891011121314# 默认分隔符是空格msg=' hello world 'msg.split() # ['hello', 'world']# 指定分隔符msg='*hello**world*'msg.split('*') # ['', 'hello', '', 'world', '']msg.rsplit('*') # ['', 'hello', '', 'world', '']msg.split('**') # ['*hello', 'world*']# 指定分隔次数msg='**hello**world*'msg.split('*',1) # ['', '*hello**world*']msg.rsplit('*',1) # ['*hello**world', ''] lower,upper(大小写转换) lower：将英文字符串全部变小写 upper‘：将英文字符串全部变大写 123msg='你好，Hello'msg.lower() # '你好，hello'msg.upper() # '你好，HELLO' startswith,endswith(判断首尾字符) startswith：判断字符串是否以括号内指定的字符开头，结果为布尔值True或False endswith：判断字符串是否以括号内指定的字符结尾，结果为布尔值True或False 12345msg='hello world'msg.startswith('hello') # Truemsg.startswith('helo') # Falsemsg.endswith('world') # Truemsg.endswith('rd') # False join(按分隔符拼接列表或字符串)用指定分隔符拼接列表或字符串，返回字符串 1234''.join(['hello','world','你好']) # 'helloworld你好'' '.join(['hello','world','你好']) # 'hello world 你好''**'.join(['hello','world','你好']) # 'hello**world**你好''*'.join('hello world') # 'h*e*l*l*o* *w*o*r*l*d' replace(替换字符)用新的字符替换字符串中旧的字符 参数： 第一个：旧字符 第二个：新字符 第三个：替换次数 返回结果为替换后的结果 123msg="you can you up no can no bb"msg.replace("you","YOU") # 'YOU can YOU up no can no bb'msg.replace("you","YOU",1) # 'YOU can you up no can no bb' find,rfind(查找子字符索引) find：从指定范围内从左往右查找子字符串，找得到则返回子字符串首字母的索引，找不到则返回-1 rfind：从指定范围内从右往左查找子字符串，找得到则返回子字符串首字母的索引，找不到则返回-1 参数： 第一个：子字符串 第二个：范围开始索引，包含 第三个：范围结束索引，不包含 返回结果，存在则返回子字符串的首字符在目标字符串中的索引，找不到则返回-1 123msg='hello world hahaha'msg.find('ha') # 11msg.rfinx('ha') # 15 index,rindex(查找子字符索引)作用同find,rfind，但在找不到时会报错 count(查找子字符出现次数)统计子字符串在字符串中出现的次数 12msg='hello world hahaha'msg.count('ha') # 3 center,ljust,rjust,zfill(填充字符) center：生成x长的字符串，字符串居中显示，不够用特定字符填充 参数： 第一个：结果字符串总长度 第二个：填充字符（单个字符） ljust：生成x长的字符串，字符串左对齐显示，不够用特定字符填充 参数： 第一个：结果字符串总长度 第二个：填充字符（单个字符） rjust：生成x长的字符串，字符串右对齐显示，不够用特定字符填充 参数： 第一个：结果字符串总长度 第二个：填充字符（单个字符） zfill：生成x长的字符串，字符串右对齐显示，不够用0填充 参数只有一个：结果字符串总长度 1234'hello'.center(11,'*') # '***hello***''hello'.ljust(11,'*') # 'hello******''hello'.rjust(11,'*') # '******hello''hello'.zfill(11) # '000000hello' expandtabs(\t制表符转换为几个空格)修改\t制表符代表的空格数，参数为单个制表符代表的空格数 首个制表符只代表一个空格，与传参无关 12345# \t表示制表符(tab键)'hello\tworld'.expandtabs(1) # 'hello world''hello\tworld'.expandtabs(2) # 'hello world''hello\t\tworld'.expandtabs(1) # 'hello world''hello\t\tworld'.expandtabs(2) # 'hello world' capitalize,swapcase,title(大小写转换) capitalize：首字母大写 swapcase：大小写翻转 title：每个单词的首字母大写 123'hello world'.capitalize() # 'Hello world''Hello World'.swapcase() # 'hELLO wORLD''hello world'.title() # 'Hello World' is检查字符串内容is检查数字 isdigit：判断字符串是否是纯数字组成，返回结果为True或False isdecimal：判断字符串是否是uncicode类型的数字组成，bytes类型无isdecimal方法 isnumberic：判断字符串是否是:unicode,中文数字,罗马数字类型的数字组成，bytes类型无isnumberic方法 三者都不能判断浮点数 123456789101112131415161718num1 = b'4' #bytesnum2 = u'4' #unicode,python3中无需加u就是unicodenum3 = '四' #中文数字num4 = 'Ⅳ' #罗马数字num1.isdigit() # Truenum2.isdigit() # Truenum3.isdigit() # Falsenum4.isdigit() # False'12.3'.isdigit() # Falsenum2.isdecimal() # Truenum3.isdecimal() # Falsenum4.isdecimal() # Falsenum2.isnumeric() # Truenum3.isnumeric() # Truenum4.isnumeric() # True is其他12345678910111213141516name='world123'# 字符串中既可以包含数字也可以包含字母 name.isalnum() # True# 字符串中只包含字母name.isalpha() # False# 判断字符串是否是有效的标识符，可用来判断变量名是否合法name.isidentifier() # True# 字符串是否是纯小写name.islower() # True# 字符串是否是纯大写 name.isupper() # False# 字符串是否全是空格name.isspace() # False# 字符串中的单词首字母是否都是大写 name.istitle() # False format详见格式化输出format 格式化输出%12345678910111213# 值按照位置与%s一一对应，少一个不行，多一个也不行"my name is %s my age is %s" %('xxx',"18")"my name is %s my age is %s" %("18",'xxx')"my name is %s" %"xxx"# 以字典的形式传值，打破位置的限制"我的名字是 %(name)s 我的年龄是 %(age)s" %&#123;"age":"18","name":'xxx'&#125;# %s可以接收任意类型，%d只能接收int'my age is %s' %18'my age is %s' %[1,23]'my age is %s' %&#123;'a':333&#125;'my age is %d' %18 format兼容性好 12345# 按照位置传值'我的名字是 &#123;&#125; 我的年龄是 &#123;&#125;'.format('xxx',18) # 我的名字是 xxx 我的年龄是 18'我的名字是 &#123;0&#125;&#123;0&#125;&#123;0&#125; 我的年龄是 &#123;1&#125;&#123;1&#125;'.format('xxx',18) # 我的名字是 xxxxxxxxx 我的年龄是 1818# 打破位置的限制，按照key=value传值"我的名字是 &#123;name&#125; 我的年龄是 &#123;age&#125;".format(age=18,name='xxx') # 我的名字是 xxx 我的年龄是 18 填充与格式化在冒号后设定填充格式[填充字符][对齐方式][宽度] 12345# *&lt;6：左对齐，总共6个字符，不够的用*号填充# *&gt;6：右对齐，总共6个字符，不够的用*号填充# *^6：居中显示，总共6个字符，不够的用*号填充'我的名字是 &#123;0:*&lt;6&#125;&#123;0:-^5&#125;&#123;0:*&gt;6&#125; 我的年龄是 &#123;1:$&gt;4&#125;&#123;1:&amp;&lt;3&#125;'.format('xxx',18) # 我的名字是 xxx***-xxx-***xxx 我的年龄是 $$1818&amp;'我的名字是 &#123;name:*^7&#125; 我的年龄是 &#123;age:-^4&#125;'.format(age=18,name='xxx') # 我的名字是 **xxx** 我的年龄是 -18- 精度与进制12345678910 # 精确到小数点后3位，四舍五入'&#123;salary:.3f&#125;'.format(salary=1232132.12351) # 1232132.124# 转成二进制'&#123;0:b&#125;'.format(123) # 1111011# 转成八进制'&#123;0:o&#125;'.format(9) # 11# 转成十六进制'&#123;0:x&#125;'.format(15) # f# 千分位格式化'&#123;0:,&#125;'.format(99812939393931) # 99,812,939,393,931 fpython版本&gt;=3.5 123x = input('your name: ')y = input('your age: ')res = f'我的名字是&#123;x&#125; 我的年龄是&#123;y&#125;' 字节字符串(bytes)b&#39;abc&#39;，二进制 布尔值(bool)True、False 注意大小写隐式布尔值，所有的值都可以当成条件去用，其中0、None、空(空字符串、空列表、空字典)代表的布尔值为False，其余都为True 空值(None)None，不能理解为0，0是有意义的，None是一个特殊空值 列表(list)索引对应值，索引从0开始，0代表第一个，索引反映的是顺序、位置，对值没有描述性的功能 12345l=[10, 3.1, 'aaa', ['bbb', 'ccc'], 'ddd']print(l[-1])# dddprint(l[3][1])# bbb 类型转换 list：但凡能被for循环遍历的数据类型都可以传给list转换成列表类型，list会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中 12345list('wdad') # ['w', 'd', 'a', 'd'] list([1,2,3]) # [1, 2, 3]list(&#123;"name":"jason","age":18&#125;) # ['name', 'age']list((1,2,3)) # [1, 2, 3] list(&#123;1,2,3,4&#125;) # [1, 2, 3, 4] 索引(存取值) 无论是取值操作还是赋值操作：索引不存在则报错 12345678910num=['XXX',2,3,4,5]# 正向取(从左往右)num[0] # 'XXX'# 反向取(负号表示从右往左)num[-1] # 5# 改值num[2]=1print(num) # ['XXX',1,3,4,5] 切片(类似字符串)list[n:m:x]：从索引n(包括n)开始到索引m(不包括m)；x步长，可以为负数(反向步长) n在m左边时能取到值，否则为&#39;&#39; n不设置时，表示头开始切片 m不设置时，表示切片到末尾 切片等同于拷贝行为，而且相当于浅copy 12345678num=['XXX',2,3,4,5]num[0:4] # ['XXX', 2, 3, 4]# 正向步长num[0:4:2] # ['XXX', 3]# 反向步长num[4:0:-2] # [5,3]num[0:4:-2] # []num[::-1] # [5, 4, 3, 2, 'XXX'] 长度(类似字符串)len：获取列表长度 12num=['XXX',2,3,4,5]len(num) # 5 运算 成员运算in和not in 123num=['XXX',2,3,4,5]'XXX' in num # True5 not in num # False 内置方法append(尾部添加)列表尾部追加元素 123l1 = ['a','b','c']l1.append('d')print(l1) # ['a', 'b', 'c', 'd'] extend(合并列表，在尾部添加多个元素)一次性在列表尾部添加多个元素，原列表值改变，id不变 123l1 = ['a','b','c']l1.extend(['a','b','c'])print(l1) # ['a', 'b', 'c','a', 'b', 'c'] insert(添加到指定位置)在指定位置插入元素 123l1 = ['a','b','c']l1.insert(1,'hello')print(l1) # ['a', 'hello', 'b', 'c'] pop(按索引删除元素) pop: 根据索引删除，会返回删除的值 参数，要删除元素的索引，不指定索引默认删除最后一个 123l1 = ['a','b','c']l1.pop(1) # 'b'print(l1) # ['a','c'] 还能通过del删除，del l1[1]，但只是单纯的删除、没有返回值 remove(按值删除元素) remove：从左往右查找到第一个元素删除，返回None， 12345l1 = ['a','b',[1],'c','a',[1]]l1.remove('a')print(l1) # ['b', [1], 'c', 'a', [1]]l1.remove([1])print(l1) # ['b', 'c', 'a', [1]] 匹配的是值，与JS不同 reverse(颠倒列表) reverse：颠倒列表内元素顺序 123l = [11,22,33,44]l.reverse() print(l) # [44,33,22,11] sort(列表排序) sort：给列表内所有元素排序，默认从小到大排序 reverse：是否颠倒排序，值为True/False，默认False 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大 字符串、列表等都可以比较大小，原理相同：都是依次比较对应索引的元素的大小，如果分出大小，则无需比较下一个元素 123456789l = [11,22,3,42,7,55]# 默认从小到大排序l.sort()print(l) # [3, 7, 11, 22, 42, 55]# reverse用来指定是否跌倒排序，默认为Falsel = [11,22,3,42,7,55]l.sort(reverse=True)print(l) # [55, 42, 22, 11, 7, 3] 元组(tuple)元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取。索引(只能取值)，切片，长度，运算特点同列表 如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改，如果元组中存在可变类型，可变类型的内容是可以修改 12345# 在()内用逗号分隔开多个任意类型的值countries = ("中国"，"美国"，"英国")# 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组countries = ("中国"，) # 本质:countries = tuple("中国") 类型转换 tuple：但凡能被for循环的遍历的数据类型都可以传给tuple转换成元组类型，tuple会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中 12345tuple('wdad') # ('w', 'd', 'a', 'd') tuple([1,2,3]) # (1, 2, 3)tuple(&#123;"name":"jason","age":18&#125;) # ('name', ')tuple((1,2,3)) # (1, 2, 3)tuple(&#123;1,2,3,4&#125;) # (1, 2, 3, 4) 字典(dict)key对应值，其中key通常为字符串类型，所以key对值可以有描述性的功能 123d=&#123;'a':1,'b':2&#125;print(d['a'])# 1 类型转换 dict 参数格式1: key=value, ‘,’隔开 参数格式2：传入一个元组或列表，其中每个元素也是元组或列表(由key作为第一个元素，对应value作为第二个元素) fromkeys：从元组中取出每个值当做key，与后面的值组层key:value放入目标字典 12345678# dict p1=dict([['name','xxx'],('age',18)])print(p1) # &#123;'age': 18, 'name': 'xxx'&#125;p2=dict(name='xxx',age=18,sex='male')print(p2) # &#123;'name': 'xxx', 'age': 18, 'sex': 'male'&#125;# fromkeys&#123;&#125;.fromkeys(('name','age','sex'),None) # &#123;&#125;.fromkeys(('name','age','sex'),None) key(存取值) 取值操作，key不存在，则会报错，’get’方法取值不会报错,字典取值建议使用get方法 对于赋值操作，如果key原先不存在于字典，则会新增key:value，如果key原先存在于字典，则会修改对应value的值 123456789dic = &#123;'name': 'xxx','age': 18,'hobbies': ['play game', 'basketball']&#125;dic['name'] # 'xxx'dic['hobbies'][1] # 'basketball'# key不存在dic['gender'] = 'male'print(dic) # &#123;'name': 'xxx', 'age': 18, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125;# key存在dic['age']=12print(dic) # &#123;'name': 'xxx', 'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125; 长度len：获取字典key的数量 12dic=&#123;'name': 'xxx', 'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125;len(dic) # 4 运算 成员运算in和not in：判断某个值是否是字典的key 12dic=&#123;'name': 'xxx', 'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125;'name' in dic # True 内置方法keys(获取所有的key)、values(获取所有的value)，items(获取所有的键值对) keys：获取字典所有的key，返回dict_keys类型 values：获取字典所有的值，返回dict_values类型 items：获取字典所有的键值对，返回dict_items类型 1234dic=&#123;'name': 'xxx', 'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125;dic.keys() # dict_keys(['name', 'age', 'hobbies', 'gender'])dic.values() # dict_values(['xxx', 12, ['play game', 'basketball'], 'male'])dic.items() # dict_items([('name', 'xxx'), ('age', 12), ('hobbies', ['play game', 'basketball']), ('gender', 'male')]) get(获取key对应value) get：获取字典中key对应的value，key存在，则获取key对应的value值，key不存在，不会报错而是默认返回None 第一个参数：key 第二个参数：当key不存在时的默认返回值 字典取值建议使用get方法 123dic= &#123;'k1':'111','k2':'222','k3':'333'&#125;dic.get('k1') # '111'dic.get('k4',444) # 4444 pop(按key删除键值对) pop：指定字典的key来删除字典的键值对，返回key对应的值 123dic=&#123;'name': 'xxx', 'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125;dic.pop('name') # 'xxx'print(dic) # &#123;'age': 12, 'hobbies': ['play game', 'basketball'], 'gender': 'male'&#125; popitem(随机删除一组键值对) popitem：随机删除一组键值对,并将删除的键值放到元组内返回 123dic= &#123;'k1':'111','k2':'222','k3':'333'&#125;dic.popitem() # ('k3', '333')print(dic) # &#123;'k1': '111', 'k2': '222'&#125; fromkeys见类型转换 setdefault(设置默认值) setdefault：key不存在则新增键值对，并将新增的value返回，key存在则不做任何修改，并返回已存在key对应的value值 1234567dic=&#123;'k1':111,'k2':222&#125;dic.setdefault('k3',333) # 333print(dic) # &#123;'k1': 111, 'k3': 333, 'k2': 222&#125;dic1=&#123;'k1':111,'k2':222&#125;dic1.setdefault('k1',666) # 111print(dic1) # &#123;'k1':111,'k2':222&#125; clear(删除所有键值对)123dic=&#123;'k1':'111','k2':'222','k3':'333'&#125;dic.clear()print(dic) # &#123;&#125; update(用新字典更新旧字典) update：用新字典更新旧字典，有则修改，无则添加 123456dic=&#123;'k1':'111','k2':'222','k3':'333'&#125;id(dic) # 1473275203008dic1=&#123;'k1':1,'k2':2,'k3':3&#125;id(dic1) # 1473275615360dic.update(dic1)print(dic,id(dic)) # &#123;'k1': 1, 'k2': 2, 'k3': 3&#125; 1473275203008 集合(set)主要用于：去重、关系运算 每个元素必须是不可变类型 集合内没有重复的元素 集合内元素无序 {}默认是空字典，set()才是空集合 1&#123;1,2,3,4&#125; 类型转换 set：但凡能被for循环的遍历的数据类型（遍历出的每一个值都必须为不可变类型）都可以传给set()转换成集合类型 12345set([1,2,3,4]) # &#123;1, 2, 3, 4&#125;set((1,2,3,4)) # &#123;1, 2, 3, 4&#125;set(&#123;'name':'jason',&#125;) # &#123;'name'&#125;set('egon') # &#123;'e', 'o', 'g', 'n'&#125; 长度len：获取集合长度 12s=&#123;'a','b','c'&#125;len(s) # 3 运算 成员运算in和not in 关系元素(见下章节运用-关系运算) 运用关系运算1234567891011121314151617181920friends1 = &#123;"a","b","A","B"&#125;friends2 = &#123;"A","B","c","C"&#125;friends1 | friends2 # &#123;'b', 'C', 'c', 'A', 'B', 'a'&#125;friends1 &amp; friends2 # &#123;'A', 'B'&#125;friends1 - friends2 # &#123;'b', 'a'&#125;friends2 - friends1 # &#123;'c', 'C'&#125;friends1 ^ friends2 # &#123;'b', 'C', 'c', 'a'&#125;# 值是否相等friends1 == friends2 # False&#123;1,2,3&#125;==&#123;2,3,1&#125; # True # 父集：一个集合是否包含另外一个集合&#123;1,2,3&#125; &gt; &#123;1,2&#125; # True&#123;1,2,3&#125; &gt;= &#123;1,2&#125; # True&#123;1,2,3&#125; &gt; &#123;2,3,1&#125; # False&#123;1,2,3&#125; &gt; &#123;1,3,4,5&#125; # False# 子集&#123;1,2&#125; &lt; &#123;1,2,3&#125; # True&#123;1,2&#125; &lt;= &#123;1,2,3&#125; # True 去重 集合去重复有局限性： 只能针对不可变类型 合本身是无序的，去重之后无法保留原来的顺序 12l=['a','b',1,'a','a']set(l) # &#123;'b', 1, 'a'&#125; 检测数据类型type(变量)1234&gt;&gt;&gt;type(1)&lt;class 'int'&gt;&gt;&gt;&gt;type('a')&lt;class 'str'&gt; isinstance(变量,数据类型)1234&gt;&gt;&gt;isinstance(1.0,float)True&gt;&gt;&gt;isinstance(False,bool)True 可变不可变类型 可变类型：值改变，内存地址不变(id不变)，证明改的是原值，证明原值是可以被改变的 list dict: value可以是任意类型，key必须是不可变类型 不可变类型：值改变，内存地址也改变(id改变)，证明是产生新的值，压根没有改变原值，证明原值是不可以被修改的 int float str bool tuple 深copy和浅copy 数据类型分类 可迭代对象列表、字典、字符串、元组、集合 支持迭代器协议的内置函数 max：取最大值 min：取最小值 sorted：排序 map reduce filter 1234567891011121314151617181920212223242526salaries=&#123; 'siry':3000, 'tom':7000, 'lili':10000, 'jack':2000&#125;# 比较keymax(salaries) # 'tom'min(salaries) # 'jack'# 比较值# 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字max(salaries,key=lambda k:salaries[k]) # 'lili'min(salaries,key=lambda k:salaries[k]) # 'jack'sorted(salaries) # ['jack', 'lili', 'siry', 'tom']sorted(salaries,key=lambda key:salaries[key]) # ['jack', 'siry', 'tom', 'lili']array=[1,2,3,4,5]res=map(lambda x:x**2,array) # &lt;map object at 0x1033f45f8&gt;list(res) # [1, 4, 9, 16, 25]from functools import reduceres=reduce(lambda x,y:x+y,array) # 15res=filter(lambda x:x&gt;3,array)list(res) # [4, 5] 用户交互输入输出 Python3 print()会依次打印每个字符串，遇到逗号,会输出一个空格 input()，可以让用户输入字符串，并存放到一个变量里 input会将用户输入的所有内容都存成字符串类型 1234&gt;&gt;&gt; name = input('pleace enter your name: ')pleace enter your name: Cindy&gt;&gt;&gt; print('hello,',name)hello, Cindy python2 raw_input()，用法与python3的input一模一样 input(): 要求用户必须输入一个明确的数据类型，输入的是什么类型，就存成什么类型 python2中input输入的是什么类型，就存成什么类型 1234&gt;&gt;&gt; age = input('pleace enter your age: ')pleace enter your name: 18&gt;&gt;&gt; print(type(age))&lt;type 'int'&gt; 运算符算数运算符 比较运算符 赋值运算符=:变量的赋值增量赋值 链式赋值123456# 链式赋值z = y = x = 10# 等同于# x=10# y=x# z=y 交叉赋值12345678# 交叉赋值m=10n=20m,n=n,m# 等同于# temp=m# m=n# n=temp 解压赋值 字符串、字典、元组、集合类型都支持解压赋值解压字典默认解压出来的是字典的key 123456789101112131415161718nums=[111,222,333,444,555]# 解压赋值# 等号左边的变量名个数必须与右面包含值的个数相同，否则报错a,b,c,d,e=nums# *，可以帮助我们取需要的值，只能出现一个*# 取前三个值x,y,z,*_=nums# 取后三个值*_,x,y,z=nums# 取首尾的值x,*_,y,z=nums# 取中间的值 _,*middle,_=salaries# 解压字典x,y,z=dic=&#123;'a':1,'b':2,'c':3&#125; # a b c 逻辑运算符 and：可以用and连接多个条件，偷懒原则，会按照从左到右的顺序依次判断，一旦某一个条件为False，则无需再往右判断，可以立即判定最终结果就为False，只有在所有条件的结果都为True的情况下，最终结果才为True。 or：可以用or连接多个条件，偷懒原则，会按照从左到右的顺序依次判断，一旦某一个条件为True，则无需再往右判断，可以立即判定最终结果就为True，只有在所有条件的结果都为False的情况下，最终结果才为False 混用优先级：not &gt; and &gt; or not的优先级最高，就是把紧跟其后的那个条件结果取反，所以not与紧跟其后的条件不可分割 短路运算：逻辑运算的结果一旦可以确定，那么就以当前处计算到的值作为最终结果返回，如0 and 2 or 1 or 4结果为1 隐式布尔值，所有的值都可以当成条件去用，其中0、None、空(空字符串、空列表、空字典)代表的布尔值为False，其余都为True 成员运算符 身份运算符 ==双等号比较的是value是否相等，而is比较的是id是否相等 缩进和代码块当语句以:结尾时，缩进的语句视为代码块 12345a = 100if a &gt;= 0: print(a)else: print(-a) 好处：强迫你写出格式化的缩进较少的代码，将一段很长的代码拆分成若干函数 缺点：复制粘贴功能需要重新检查缩进正确性，IDE很难格式化python代码 缩进级别必须保持一致 流程控制 流程控制即控制流程，具体指控制程序的执行流程，而程序的执行流程分为三种结构：顺序结构（之前我们写的代码都是顺序结构）、分支结构（用到if判断）、循环结构（用到while与for） if判断（分支结构）条件可以是任意表达式，但执行结果必须为布尔类型，所有的数据类型会自动转换成布尔类型 隐式布尔值，所有的值都可以当成条件去用，其中0、None、空(空字符串、空列表、空字典)代表的布尔值为False，其余都为True 123456789101112131415161718192021'''语法3:if 条件1: 代码...elif 条件2: 代码...elif 条件2: 代码......else: 代码...'''a = 100if a &lt; 60: print('D')elif a&lt;80: print('C')elif a&lt;90: print('B')else: print('A') while循环（条件循环）（循环结构） 123456789101112131415'''while 条件: 代码...else : 代码...'''# while循环嵌套与结束# 每一层都必须配一个breakwhile True: while True: while True: break break break 结束循环与跳过 将条件改为False，等到下次循环判断条件时才会生效 break：只要运行到break就会立刻终止本层循环 continue：结束本次循环，跳过后续代码，直接进入下一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 改变条件的方式tag=Truewhile tag: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') while tag: cmd=input("输入命令&gt;: ") if cmd == 'q': tag=False else: print('命令&#123;x&#125;正在运行'.format(x=cmd)) else: print('账号名或密码错误')print('====end====')# break的方式while True: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') while True: cmd=input("输入命令&gt;: ") if cmd == 'q': break print('命令&#123;x&#125;正在运行'.format(x=cmd)) break # 立刻终止本层循环 else: print('账号名或密码错误')else: print("循环正常执行完啦")print('====end====')# continue：结束本次循环，直接进入下一次count=0while count &lt; 6: if count == 4: count+=1 continue # count+=1 # 错误 print(count) count+=1 当while循环正常执行完并且中间没有被break中止的话，就会执行else后面的语句，所以我们可以用else来验证，循环是否正常结束 for循环（取值循环）（循环结构）理论上for循环能做的事情，while循环都可以做，之所以要有for循环，是因为for循环在循环取值（遍历取值）比while循环更简洁 123456789101112131415161718# 可迭代对象可以是：列表、字典、字符串、元组、集合'''for 变量名 in 可迭代对象: 代码...'''for x in [1,2,3]: print(x)# for循环控制循环次数：range()range(10) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]range(1,9,1) # [1, 2, 3, 4, 5, 6, 7, 8]range(1,9,2) # [1, 3, 5, 7]# for循环嵌套:外层循环循环一次，内层循环需要完整的循环完毕for i in range(3): print('外层循环--&gt;', i) for j in range(5): print('内层--&gt;', j) 结束循环与跳过 break：只要运行到break就会立刻终止本层循环，同while continue：结束本次循环，跳过后续代码，直接进入下一次，同while 终止for循环只有break一种方案 for循环原理123goods=['mac','lenovo','acer','dell','sony']for item in goods: print(item) for 循环在工作时，首先会调用可迭代对象goods内置的iter方法拿到一个迭代器对象，然后再调用该迭代器对象的next方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。 for循环与while循环的异同 相同之处：都是循环，for循环可以干的事，while循环也可以干 不同之处：while循环称之为条件循环，循环次数取决于条件何时变为假，for循环称之为”取值循环”，循环次数取决in后包含的值的个数 函数 定义函数发生的事情1.申请内存空间保存函数体代码2.将上述内存地址绑定函数名 定义函数不会执行函数体代码，但是会检测函数体语法 调用函数发生的事情1.通过函数名找到函数的内存地址2.触发函数体代码的执行 定义1234def 函数名(参数1,参数2,...): &quot;&quot;&quot;文档描述&quot;&quot;&quot; 函数体 return 值 def: 定义函数的关键字； 函数名：函数名指向函数内存地址，是对函数体代码的引用。函数的命名应该反映出函数的功能； 括号：括号内定义参数，参数是可有可无的，且无需指定参数的类型； 冒号：括号后要加冒号，然后在下一行开始缩进编写函数体的代码； 文档描述: 描述函数功能，参数介绍等信息的文档，非必要，但是建议加上，从而增强函数的可读性； help(函数名)：可以查看函数的文档描述 函数体：由语句和表达式组成；为pass时代表什么也不做，这种函数称为空函数 return 值：定义函数的返回值，return是可有可无的。默认返回None，返回多个返回值会放到一个元组内，return x,y,z等同于return (x,y,z) 定义空函数通常是有用的，因为在程序设计的开始，往往是先想好程序都需要完成什么功能，然后把所有功能都列举出来用pass充当函数体“占位符”，这将使得程序的体系结构立见，清晰且可读性强，如编写ftp程序，功能有用户认证，下载，上传，浏览，切换目录等，可以先做出如下定义： 12345678910111213141516171819def auth_user(): """user authentication function""" passdef download_file(): """download file function""" passdef upload_file(): """upload file function""" passdef ls(): """list contents function""" passdef cd(): """change directory""" pass 函数的使用分为定义阶段与调用阶段，定义函数时只检测语法，不执行函数体代码（变量未定义等错误不会报错），函数名加括号即函数调用，只有调用函数时才会执行函数体代码 123456789101112#定义阶段def foo(): print('in the foo') bar()def bar(): print('in the bar')#调用阶段foo()# 定义阶段函数foo与bar均无语法错误，而在调用阶段调用foo()时，函数foo与bar都早已经存在于内存中了，所以不会有任何问题。 参数 形参：在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。 位置形参：在定义函数时，按照从左到右的顺序依次定义形参，凡是按照这种形式定义的形参都必须被传值 默认参数：在定义函数时，就已经为形参赋值。调用时可以不传值，默认参数必须在位置参数之后，值通常应设为不可变类型 可变长度的参数: 在调用函数时，实参的个数可以不固定，不能设置默认值 *形参名：在形参名前加*号,那么在调用函数时，溢出的位置实参，都会被接收，以元组的形式保存下来赋值给该形参 **形参名：在形参名前加**号,那么在调用函数时，溢出的关键字参数，都会被接收，以字典的形式保存下来赋值给该形参 命名关键字参数：在能够以位置实参传值的形参(即位置形参和*可变长度参数)之后，在**可变长度参数之前定义的参数。在函数调用时，限定调用者必须以key=value的形式传值，可以设置默认值 实参：在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合 位置实参：在调用函数时，按照从左到右的顺序依次定义实参，凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应 关键字参数：在调用函数时，实参可以是key=value的形式，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义 *可迭代对象类型数据：将各元素转为位置实参 **可迭代对象类型数据：将各键值对转为关键字参数 实参可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值 形参定义顺序: 位置参数、默认参数、*可变长度参数、命名关键字参数、**可变长度参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 定义位置形参：name，age，sex，三者都必须被传值def register(name,age,sex): print('Name:%s Age:%s Sex:%s' %(name,age,sex))# 不传值报错register() # TypeError：缺少3个位置参数# 关键字参数register(sex='male',name='lili',age=18) # Name:lili Age:18 Sex:male# 位置实参和关键字参数的混合使用register('lili',sex='male',age=18) # Name:lili Age:18 Sex:maleregister(name='lili',18,sex='male') # SyntaxError：关键字参数name=‘lili’在位置参数18之前register('lili',sex='male',age=18,name='jack') # TypeError：形参name被重复赋值# 默认参数def register(name,age,sex='male'): # 默认sex的值为male print('Name:%s Age:%s Sex:%s' %(name,age,sex))# 大多数情况,无需为sex传值,默认为maleregister('tom',17)# 少数情况,可以为sex传值femaleregister('Lili',18,'female')# 可变长度的参数 *def foo(x,y,z=1,*args): #在最后一个形参名args前加*号 print(x) print(y) print(z) print(args)foo(1,2,3,4,5,6,7)# *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)L=[3,4,5]foo(1,2,*L) # 1# 2# 3# (4, 5, 6, 7)# 可变长度的参数 **def foo(x,**kwargs): #在最后一个参数kwargs前加** print(x) print(kwargs) foo(y=2,x=1,z=3)# 1# &#123;'z': 3, 'y': 2&#125;# **dic就相当于关键字参数a=1，b=2，foo(1,2,**dic)等同foo(1,2,a=1,b=2)dic=&#123;'a':1,'b':2&#125;foo(1,c=2,**dic)# 1# &#123;'c': 2, 'a': 1, 'b': 2&#125; 名称空间 名称空间即存放名字与对象映射/绑定关系的地方。对于x=3，Python会申请内存空间存放对象3，然后将名字x与3的绑定关系存放于名称空间中，del x表示清除该绑定关系。 内建名称空间：伴随python解释器的启动/关闭而产生/回收，用来存放一些内置的名字，比如内建函数名 全局名称空间：伴随python文件的开始执行/执行完毕而产生/回收，文件执行过程中产生的名字都会存放于该名称空间中 局部名称空间：伴随函数的调用/结束而临时产生/回收，函数的形参、函数内定义的名字都会被存放于该名称空间中 名称空间的加载顺序：内置名称空间&gt;全局名称空间&gt;局部名称空间 名称空间的销毁顺序：局部名称空间&gt;全局名空间&gt;内置名称空间 名字的查找优先级：当前所在的位置向上一层一层查找，局部名称空间(嵌套定义中由内而外一层层查找)&gt;全局名称空间&gt;内置名称空间，最终没有找到就会抛出异常 名称空间的”嵌套”关系是以函数定义阶段为准，与调用位置无关 1234567891011121314x=1def outer(): x=2 def inner(): # 函数名inner属于outer这一层作用域的名字 x=3 print('inner x:%s' %x) inner() print('outer x:%s' %x)outer() #结果为# inner x:3# outer x:2 作用域 全局作用域：位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用） 在全局作用域调用locals()或者globals()，查看全局作用域名字，返回字典类型，两个内建函数结果相同 局部作用域：位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）。 在局部作用域调用locals()，查看局部作用域名字，返回字典类型 在局部作用域调用globals()，查看全局作用域名字，返回字典类型 修改上级作用域的名字的值 global：在函数内，无论嵌套多少层，都可以查看到全局作用域的名字 若要在函数内修改全局名称空间中名字的值，则需要用到global关键字 nonlocal：对于嵌套多层的函数，可以查看到外部嵌套函数定义的作用域的名字(非全局作用域的) 使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域 123456789101112131415161718# globalx=1def foo(): global x # 声明x为全局名称空间的名字 x=2foo() print(x) # 2# nonlocaldef f1(): x=2 def f2(): nonlocal x x=3 f2() #调用f2(),修改f1作用域中名字x的值 print(x) #在f1作用域查看xf1() # 3 函数对象 函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用 函数可以被引用 函数可以作为容器类型的元素 函数可以作为参数传入另外一个函数 函数的返回值可以是一个函数 123456789101112131415161718192021def add(x,y): return x+y# 函数可以被引用func=addfunc(1,2)# 函数可以作为容器类型的元素dic=&#123;'add':add,'max':max&#125;print(dic) # &#123;'add': &lt;function add at 0x100661e18&gt;, 'max': &lt;built-in function max&gt;&#125;dic['add'](1,2)# 函数可以作为参数传入另外一个函数def foo(x,y,func): return func(x,y)foo(1,2,add)# 函数的返回值可以是一个函数def bar(): return add func=bar() func(1,2) 闭包基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关。函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包(Closures) “闭”函数指的该函数是内嵌函数 “包”函数指的该函数包含对外层函数作用域名字的引用（不是对全局作用域） 可以通过函数的closure属性，查看到闭包函数所包裹的外部变量 123456789101112x=1def outer(): x=2 def inner(): print(x) return innerfunc=outer()func() # 结果为2func.__closure__# (&lt;cell at 0x10212af78: int object at 0x10028cca0&gt;,)func.__closure__[0].cell_contents# 2 匿名函数lambda 参数1,参数2,...: expression，匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用 12345res=(lambda x,y,z:x+y+z)(1,2,3)# “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的func=lambda x,y,z:x+y+z res=func(1,2,3) 装饰器 类似同ES6，本质高阶函数。在不修改被装饰对象源代码和调用方式的前提下为被装饰对象添加额外的功能。可调用对象有函数，方法或者类 无参装饰器12345678910@deco3@deco2@deco1def index(): pass# 等同于def index(): passindex=deco3(deco2(deco1(index))) 有参装饰器本质，高阶函数，接收需要的参数，return无参装饰器 1234567891011def auth(driver): def deco(func): …… return deco# 先调用auth(driver='file')，得到@deco，deco是一个闭包函数，包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样@auth(driver='file') def index(): pass@auth(driver='mysql') def home(): pass @wraps@wraps：在装饰器内部使用，保证被装饰之后的函数，name和doc属性与原函数一直，如通过help(函数名)查看函数文档注释时，不会报错 1234567891011from functools import wrapsdef timer(func): @wraps(func) def wrapper(*args,**kwargs): start_time=time.time() res=func(*args,**kwargs) stop_time=time.time() print('run time is %s' %(stop_time-start_time)) return res return wrapper 迭代器 迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需的目标或结果，每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值,单纯的重复并不是迭代 优点 为序列和非序列类型提供了一种统一的迭代取值方式。 惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。 缺点 除非取尽，否则无法获取迭代器的长度 只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值 可迭代对象从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象 迭代器对象迭代器对象是内置有iter和next方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.iter()方法得到的仍然是迭代器本身，而执行迭代器.next()方法就会计算出迭代器中的下一个值。 123456789# 可迭代对象ss=&#123;1,2,3&#125;# 本质就是在调用s.__iter__(),返回s的迭代器对象i，i=iter(s) # 本质就是在调用i.__next__()next(i) # 1next(i) # 2next(i) # 3next(i) # 抛出StopIteration的异常，代表无值可取， 生成器 若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象(生成器内置有iter和next方法，所以生成器本身就是一个迭代器)，不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，将yield后的值，当做本次调用的结果返回，可以返回多次值 1234567891011def eater(): print('Ready to eat') while True: food=yield print('get the food: %s, and start to eat' %food)g=eater() # 得到生成器对象print(g) # &lt;generator object eater at 0x101b6e2b0&gt;# 需要事先”初始化”一次，让函数挂起在food=yield，等待调用g.send()方法为其传值next(e) # Ready to eatg.send('包子') # get the food: 包子, and start to eatg.send('鸡腿') # get the food: 鸡腿, and start to eat next(g)d等同于g.send(None) 1234567891011121314151617&gt;&gt;&gt; def eater():... print('Ready to eat')... food_list=[]... while True:... food=yield food_list... food_list.append(food)... &gt;&gt;&gt; e=eater()&gt;&gt;&gt; next(e)Ready to eat[]&gt;&gt;&gt; e.send('蒸羊羔')['蒸羊羔']&gt;&gt;&gt; e.send('蒸熊掌')['蒸羊羔', '蒸熊掌']&gt;&gt;&gt; e.send('蒸鹿尾儿')['蒸羊羔', '蒸熊掌', '蒸鹿尾儿'] 表达式形式的yield也可以用于返回多次值，即变量名=yield 值的形式 表达式三元表达式条件成立时返回的值 if 条件 else 条件不成立时返回的值 123456789101112def max2(x,y): if x &gt; y: return x else: return yres = max2(1,2)# 三元表达式x=1y=2res = x if x &gt; y else y 生成式列表生成式[expression for item in iterable if condition]，返回的是一个列表 123456egg_list=[]for i in range(10): egg_list.append('鸡蛋%s' %i)# 列表生成式egg_list=['鸡蛋%s' %i for i in range(10)] 字典生成式{key_expression:value_expression for key in iterable if condition}，返回的是一个字典 123items=[('name','egon'),('age',18),('gender','male')]res=&#123;k+'1':str(v)+'2' for k,v in items if k != 'gender'&#125;print(res) # &#123;'name1': 'egon2', 'age1': '182'&#125; 集合生成式{expression for key in iterable if condition}，返回的是一个集合 123keys=['name','age','gender']set1=&#123;key for key in keys&#125;print(set1,type(set1)) 生成器表达式（expression for item in iterable if condition），返回的是一个生成器对象 123with open('db.txt','rb') as f: nums=(len(line) for line in f) total_size=sum(nums) # 依次执行next(nums)，然后累加到一起得到结果= eval&amp;exec eval：eval用来执行表达式，并返回表达式执行的结果，不能执行语句 exec(str,g,l)：exec用来执行语句，不会返回任何值，参数如下 str：包含一系列python代码的字符串 g：全局作用域（字典形式），如果不指定，默认为globals() l：局部作用域（字典形式），如果不指定，默认为locals() compile(str,filename,kind) filename：用于追踪str来自于哪个文件，如果不想追踪就可以不定义 kind：&#39;single&#39;代表一条语句，&#39;exec&#39;代表一组语句，&#39;eval&#39;代表一个表达式 12345678910111213141516171819202122232425262728293031323334s='1+2+3'print(eval(s)) # 6print(exec(s)) # Noneprint(eval('1+2+x',&#123;'x':3&#125;,&#123;'x':30&#125;)) # 33print(exec('1+2+x',&#123;'x':3&#125;,&#123;'x':30&#125;)) # Noneprint(eval('for i in range(10):print(i)')) # 报错print(exec('for i in range(10):print(i)'))s='for i in range(10):print(i)'code=compile(s,'','exec')exec(code)s='1+2+3'code=compile(s,'','eval')eval(code)g=&#123; 'x':1, 'y':2&#125;l=&#123;&#125;exec('''global x,zx=100z=200m=300''',g,l)print(g) # &#123;'x': 100, 'y': 2,'z':200,......&#125;print(l) # &#123;'m': 300&#125; 模块 一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。 模块其实分为四个通用类别，分别是： 使用纯Python代码编写的py文件 包含一系列模块的包(及文件夹) 使用C编写并链接到Python解释器中的内置模块 使用C或C++编译的扩展模块(共享库或DLL) 12345678910#文件名：foo.pyx=1def get(): print(x)def change(): global x x=0class Foo: def func(self): print('from the func') 要想在另外一个py文件中引用foo.py中的功能，需要使用import foo，首次导入模块会做三件事： 执行源文件代码 产生一个新的名称空间用于存放源文件执行过程中产生的名字 在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀，如下 1234567891011#导入模块fooimport foo #引用模块foo中变量x的值赋值给当前名称空间中的名字aa=foo.x#调用模块foo的get函数foo.get() #调用模块foo中的change函数foo.change() # 执行foo.get()或foo.change()操作的都是源文件中的全局变量x#使用模块foo的类Foo来实例化，进一步可以执行obj.func()obj=foo.Foo() 第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。 import语法 在文件开头导入模块属于全局作用域，在函数内导入的模块则属于局部的作用域。 import 模块名 123456789101112131415161718192021'''我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开不同类别的导入顺序如1. python内置模块2. 第三方模块3. 程序员自定义模块'''# 为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名fimport foo as ff.xf.get()# 导入多个模块# 多行import module1import module2# ...import moduleN# 一行import module1,module2,...,moduleN from 模块名 import 模块内的具体名字 优点：代码更加简洁 缺点：容易与当前名称空间的名字冲突，后定义的名字会覆盖之前定义的名字。 123456789101112131415#将模块foo中的x和get导入到当前名称空间from foo import x,get,change # 直接使用模块foo中的x赋值给aa=x # 直接执行foo中的get函数get() # 即便是当前有重名的x，修改的仍然是源文件中的xchange() #把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字from foo import *a=xget()change()obj=Foo() from foo import *只能在模块最顶层使用的方式导入，在函数内则非法 编写者可以在自己的文件中定义__all__变量用来控制*代表的意思，如在foo.py加入__all__=[&#39;x&#39;,&#39;get&#39;]，则change()、Foo()在from foo import *导入时不可用 循环导入问题 循环导入问题大多数情况是因为程序设计失误导致，解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入 指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码。比较下列两种情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# m1.pyprint('正在导入m1')from m2 import yx='m1'# m2.pyprint('正在导入m2')from m1 import xy='m2# run.pyimport m1# 情况一：执行run.py会抛出异常'''正在导入m1正在导入m2Traceback (most recent call last): File ".../run.py", line 1, in &lt;module&gt; import m1 File ".../m1.py", line 2, in &lt;module&gt; from m2 import y File ".../m2.py", line 2, in &lt;module&gt; from m1 import xImportError: cannot import name 'x'''''''分析---&gt;先执行run.py---&gt;执行import m1，开始导入m1并运行其内部代码---&gt;打印内容"正在导入m1"---&gt;执行from m2 import y 开始导入m2并运行其内部代码---&gt;打印内容“正在导入m2”---&gt;执行from m1 import x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错'''# 情况二：直接执行m1.py也会抛出异常，但打印结果不一样'''正在导入m1正在导入m2正在导入m1Traceback (most recent call last): File ".../m1.py", line 2, in &lt;module&gt; from m2 import y File ".../m2.py", line 2, in &lt;module&gt; from m1 import x File ".../m1.py", line 2, in &lt;module&gt; from m2 import yImportError: cannot import name 'y'''''''分析：执行m1.py不等于导入了m1模块---&gt;执行m1.py---&gt;打印“正在导入m1”---&gt;执行from m2 import y ---&gt;导入m2进而执行m2.py内部代码---&gt;打印"正在导入m2"---&gt;执行from m1 import x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码---&gt;打印"正在导入m1"---&gt;执行from m2 import y，由于m2已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错''' 解决办法123456789101112131415161718192021222324252627282930313233343536# 方法一：导入语句放到最后，保证在导入时，所有名字都已经加载过# 文件：m1.pyprint('正在导入m1')x='m1'from m2 import y# 文件：m2.pyprint('正在导入m2')y='m2'from m1 import x# 文件：run.py内容如下，执行该文件，可以正常使用import m1print(m1.x)print(m1.y)# 方法二：导入语句放到函数中，只有在调用函数时才会执行其内部代码# 文件：m1.pyprint('正在导入m1')def f1(): from m2 import y print(x,y)x = 'm1'# 文件：m2.pyprint('正在导入m2')def f2(): from m1 import x print(x,y)y = 'm2'# 文件：run.py内容如下，执行该文件，可以正常使用import m1m1.f1() 搜索模块的路径与优先级搜索模块优先级：内存中已加载的模块&gt;内置模块&gt;sys.path中定义的路径(列表类型，按索引查找，直到找模块对应的文件为止)，都没找到则抛出异常。(内存&gt;硬盘) sys.modules：查看已经加载到内存中的模块 Python支持从一个压缩文件中导入模块 被导入的模块与执行文件在不同级目录下，为了确保模块对应的源文件仍可以被找到，需要将源文件所在的路径添加到sys.path中 123456# 假设源文件foo.py所在的路径为/pythoner/projects/import sys# 也可以使用sys.path.insert(……)sys.path.append(r'/pythoner/projects/') # 无论foo.py在何处,我们都可以导入它了import foo 环境变量是以执行文件为准备的，所有的被导入的模块或者说后续的其他文件引用的sys.path都是参照执行文件的sys.path 区分py文件的两种用途一个python文件有两种用途： 被当成程序运行 被当做模块导入 区别：在py文件被当做脚本执行时，__name__变量被赋值为&quot;__main__&quot;。在py文件被当做模块导入时，__name__变量被赋值为模块名 内置模块time(时间模块)时间的三种模式 时间戳：从1970年1月1日00:00:00到现在经历过的秒数 time.time()：返回的是float类型 按某种格式显示的时间 time.strftime(&#39;%Y-%m-%d %H:%M:%S %p&#39;) time.strftime(&#39;%Y-%m-%d %H:%M:%S %X&#39;) 时间格式|格式 | 含义 | 取值范围（格式）||:–:|:—–|:—–||%y|去掉世纪的年份|00-99，如”15”||%Y|完整的年份|如”2015”||%j|指定日期是一年中的第几天|001-366||%m|返回月份|01-12||%b|本地简化月份的名称|简写英文月份||%B|本地完整月份的名称|完整英文月份||%d|该月的第几日|如5月1日返回”01”||%H|该日的第几时（24小时制）|00-23||%l|该日的第几时（12小时制）|01-12||%M|分钟|00-59||%S|秒|00-59||%U|在该年中的第多少星期（以周日为一周起点）|00-53||%W|同上，只不过是以周一为起点|00-53||%w|一星期中的第几天|0-6||%Z|时区|在中国大陆测试，返回CST，即China Standard Time||%x|日期|日/月/年||%X|时间|时:分:秒||%c|详细日期时间|日/月/年 时:分:秒||%%|‘%’字符|‘%’字符||%p|上下午|AM or PM| 结构化的时间：struct_time元组共有9个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时) time.localtime()：本地时区的struct_time time.gmtime()：UTC时区的struct_time 三种时间模式转换 localtime：将一个时间戳转换为当前时区的struct_time，不传参默认当前时间的时间戳 gmtime：类似localtime，将一个时间戳转换为UTC时区（0时区）的struct_time mktime：将一个struct_time转化为时间戳 strftime：把一个代表时间的元组或者struct_time转化为格式化的时间字符串 第一个参数为时间格式字符串 第二个参数不传参默认为time.localtime()，元组中任何一个元素越界，ValueError的错误将会被抛出。 strptime：把一个格式化时间字符串转化为struct_time，是strftime的逆操作 第一个参数为格式化时间字符串 第二个参数为时间格式字符串，默认为&#39;%a %b %d %H:%M:%S %Y&#39; asctime：把一个表示时间的元组或者struct_time表示为&#39;%a %b %d %H:%M:%S %Y&#39;形式 ctime([secs])：把一个时间戳（按秒计算的浮点数）转化为&#39;%a %b %d %H:%M:%S %Y&#39;形式 12345678910111213141516171819202122import time# localtime([secs])time.localtime() # time.struct_time(tm_year=2022, tm_mon=8, tm_mday=7, tm_hour=14, tm_min=43, tm_sec=42, tm_wday=6, tm_yday=219, tm_isdst=0)time.localtime(1659854649.524673) # time.struct_time(tm_year=2022, tm_mon=8, tm_mday=7, tm_hour=14, tm_min=44, tm_sec=9, tm_wday=6, tm_yday=219, tm_isdst=0)# gmtime([secs])time.gmtime(1659854649.524673) # time.struct_time(tm_year=2022, tm_mon=8, tm_mday=7, tm_hour=6, tm_min=44, tm_sec=9, tm_wday=6, tm_yday=219, tm_isdst=0)# mktime(t)time.mktime(time.localtime()) # 1659854826.0# strftime(format[, t])time.strftime("%Y-%m-%d %X", time.localtime()) # '2022-08-07 15:03:50'time.strftime('%Y-%m-%d %H-%M-%S',(2022,8,7,14,44,9,6,219,0)) # '2022-08-07 14-44-09'# time.strptime(string[, format])time.strptime('2022-08-07 14:44:09','%Y-%m-%d %X') # time.struct_time(tm_year=2022, tm_mon=8, tm_mday=7, tm_hour=14, tm_min=44, tm_sec=9, tm_wday=6, tm_yday=219, tm_isdst=-1)# asctime([t])time.asctime(time.localtime()) # 'Sun Aug 7 15:54:13 2022'time.ctime(time.time()) # 'Sun Aug 7 15:54:49 2022' 其他 sleep：线程推迟指定的时间运行，参数单位为秒。time.sleep(10) datetime(时间加减)1234567891011121314151617import datetimetoday=datetime.datetime.now() # datetime.datetime(2022, 8, 7, 16, 28, 10, 535644)# 时间加减today + datetime.timedelta(3) # datetime.datetime(2022, 8, 10, 16, 28, 10, 535644)today + datetime.timedelta(-3) # datetime.datetime(2022, 8, 4, 16, 28, 10, 535644)today + datetime.timedelta(hours=3) # datetime.datetime(2022, 8, 7, 19, 28, 10, 535644)today + datetime.timedelta(minutes=30) # datetime.datetime(2022, 8, 7, 16, 58, 10, 535644)时间替换today.replace(minute=3,hour=2) # datetime.datetime(2022, 8, 7, 2, 3, 10, 535644)# 时间戳直接转成datetimedatetime.datetime.fromtimestamp(time.time()) # datetime.datetime(2022, 8, 7, 16, 34, 13, 155009)# datetime转成struct_timetoday.timetuple() # time.struct_time(tm_year=2022, tm_mon=8, tm_mday=7, tm_hour=16, tm_min=28, tm_sec=10, tm_wday=6, tm_yday=219, tm_isdst=-1) random random()：大于0且小于1之间的小数，返回类型float uniform(m,n)：大于m小于n的小数 randint(m,n)：大于等于m且小于等于n之间的整数，返回类型int randrange(m,n)：大于等于m且小于n之间的整数 choice：参数列表，随机返回列表中的某个项 sample([],n)：参数列表，随机返回列表元素任意n个的组合, shuffle：参数列表，打乱项的顺序，原列表改变(项顺序改变，id不变) 123456789101112import randomrandom.random() # 0.8494743062780097random.uniform(1,3) # 1.8118915610884312random.randint(1,3) # 3randrange(1,3) # 2random.choice([1,'23',[4,5]]) # [4,5]random.sample([1,'23',[4,5]],2) # [[4, 5], '23']ls=[1,3,5,7,9]random.shuffle(ls) print(ls) # [9, 3, 7, 1, 5] osos模块负责程序与操作系统交互 getcwd()：获取当前工作目录，即当前python脚本工作的目录路径 chdir(&quot;dirname&quot;)：改变当前脚本工作目录；相当于shell下cd curdir：返回当前目录&#39;.&#39; pardir：获取当前目录的父目录字符串名&#39;..&#39; removedirs(&#39;dirname1&#39;)：若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 mkdir(&#39;dirname&#39;)：生成单级目录；相当于shell中mkdir dirname rmdir(&#39;dirname&#39;)：删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname listdir(&#39;dirname&#39;)：列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 remove()：删除一个文件 rename(&quot;oldname&quot;,&quot;newname&quot;)：重命名文件/目录 stat(&#39;path/filename&#39;)：获取文件/目录信息 sep：输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot; linesep：输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot; pathsep：输出用于分割文件路径的字符串 win下为’;’,Linux下为’:’ name：输出字符串指示当前使用平台。win下为&#39;nt&#39;; Linux下为&#39;posix&#39; system(&quot;bash command&quot;)：运行shell命令，直接显示 environ：获取系统环境变量 path path.abspath(path)：返回path规范化的绝对路径 path.split(path)：将path分割成目录和文件名二元组返回 path.dirname(path：返回path的目录。其实就是os.path.split(path)的第一个元素 path.basename(path)：返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 path.exists(path)：如果path存在，返回True；如果path不存在，返回False path.isabs(path)：如果path是绝对路径，返回True path.isfile(path)：如果path是一个存在的文件，返回True。否则返回False path.isdir(path)： 如果path是一个存在的目录，则返回True。否则返回False path.join(path1[, path2[, ...]])：将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 path.getatime(path)：返回path所指向的文件或者目录的最后存取时间 getmtime(path)：返回path所指向的文件或者目录的最后修改时间 path.getsize(path)：返回path的大小 path.normcase(path)：在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。 path.normpath(path)：规范化路径，如..和/，os.path.normpath(&#39;c://windows\\System32\\../Temp/&#39;)返回&#39;c:\\windows\\Temp&#39; os路径处理12345678910111213import os,sys#方式一：推荐使用possible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, #上一级 os.pardir, os.pardir))sys.path.insert(0,possible_topdir)#方式二：不推荐使用os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) syssys模块负责程序与Python解释器进行交互。 sys.argv：命令行参数List，第一个元素是程序本身路径 sys.exit(n)：退出程序，正常退出时exit(0) sys.version：获取Python解释程序的版本信息 sys.hexversion：获取Python解释程序的版本值，16进制格式如：0x020403F0 sys.api_version：解释器的C的API版本 sys.maxint：最大的Int值 sys.maxunicode：最大的Unicode值 sys.path：返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform：返回操作系统平台名称 sys.modules：返回系统导入的模块字段，key是模块名，value是模块 sys.modules.keys()：返回所有已经导入的模块列表 sys.exc_info()：获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 `sys.stdout：标准输出 sys.stdin：标准输入 sys.stderr：错误输出 sys.exc_clear()：用来清除当前线程所出现的当前的或最近的错误信息 sys.exec_prefix：返回平台独立的python文件安装的位置 sys.byteorder：本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’ sys.copyright：记录python版权相关的东西 shutil(文件、文件夹、压缩包处理模块)高级的文件、文件夹、压缩包处理模块 copyfileobj(fsrc, fdst[, length])：将文件内容拷贝到另一个文件中 copyfile(src, dst)：拷贝文件，目标文件无需存在 copymode(src, dst)：仅拷贝权限。内容、组、用户均不变，目标文件必须存在 copystat(src, dst)：仅拷贝状态的信息，包括：mode bits, atime, mtime, flags，目标文件必须存在 copy(src, dst)：拷贝文件和权限 copy2(src, dst)：拷贝文件和状态信息 ignore_patterns(*patterns)：排除满足条件的文件 copytree(src, dst, symlinks=False, ignore=None)：递归的去拷贝文件夹，目标目录不能存在，注意对dst目录父级目录要有可写权限 ignore：排除，由shutil.ignore_patterns(*patterns)返回 symlinks：通常值为False或省略,指拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件(元数据复制到新文件夹中)。为True时，源文件夹中的软链接仍然拷贝成软连接，但是软链接的元数据不会被复制 rmtree(path[, ignore_errors[, onerror]])：递归的去删除文件 move(src, dst)：递归的去移动文件，它类似mv命令，其实就是重命名。 1234567891011import shutilshutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w'))shutil.copyfile('f1.log', 'f2.log')shutil.copymode('f1.log', 'f2.log')shutil.copystat('f1.log', 'f2.log')shutil.copy('f1.log', 'f2.log')shutil.copy2('f1.log', 'f2.log')shutil.copytree('folder1', 'folder2', ignore=shutil.ignore_patterns('*.pyc', 'tmp*'))shutil.rmtree('folder1')shutil.move('folder1', 'folder3') 压缩和解压缩 make_archive(base_name, format,...)：创建压缩包并返回文件路径，例如：zip、tar base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，如 data_bak=&gt;保存至当前路径；如 /tmp/data_bak=&gt;保存至/tmp/ format：压缩包种类，“zip”, “tar”, “bztar”，“gztar” root_dir：要压缩的文件夹路径（默认当前目录） owner：用户，默认当前用户 group：组，默认当前组 logger：用于记录日志，通常是logging.Logger对象 1234567# 将 /data 下的文件打包放置当前程序目录import shutilret = shutil.make_archive("data_bak", 'gztar', root_dir='/data')# 将 /data下的文件打包放置 /tmp/目录import shutilret = shutil.make_archive("/tmp/data_bak", 'gztar', root_dir='/data') shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的 12345678910111213141516171819202122232425262728import zipfile# 压缩z = zipfile.ZipFile('laxi.zip', 'w')z.write('a.log')z.write('data.data')z.close()# 解压z = zipfile.ZipFile('laxi.zip', 'r')z.extractall(path='.')z.close()import tarfile# 压缩t=tarfile.open('/tmp/egon.tar','w')t.add('/test1/a.py',arcname='a.bak')t.add('/test1/b.py',arcname='b.bak')t.close()# 解压t=tarfile.open('/tmp/egon.tar','r')t.extractall('/egon')t.close() JSON&amp;pickle(序列化和反序列化)序列化 序列化：把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等 反序列化：反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化 序列化的优点： 持久保存状态：内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。但是在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。如游戏存档，虚拟机状态的挂起 跨平台数据交互：序列化时不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。 JSONJson序列化并不是python独有的，json序列化在java等语言中也会涉及到，因此使用json序列化能够达到跨平台传输数据的目的。JSON不仅是标准格式，并且比XML更快 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下 Json类型 Python类型 {} dict [] list “string” str 520.13 int或float true/false True/False null None json不认单引号 json模块序列化和反序列化的一个过程如下图所示 1234567891011121314151617181920212223import jsondic=&#123;'name':'alvin','age':23,'sex':'male'&#125;print(type(dic)) # &lt;class 'dict'&gt; j=json.dumps(dic)print(type(j)) # &lt;class 'str'&gt;# 序列化f=open('序列化对象.json','w')json.dump(dic,f)# 等价于f.write(json.dumps(dic))f.close()# 反序列化f=open('序列化对象.json')data=json.load(f)# 等价于 data=json.loads(f.read())f.close() 无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads 在python解释器2.7与3.6之后都可以json.loads(bytes类型)，但唯独3.5不可以 picklePickle序列化，只能用来保存那些不重要的数据，即不能成功地反序列化也没关系。 缺点：只能用于Python，并且可能不同版本的Python彼此都不兼容 优点：可以存储Python中的所有的数据类型，包括对象，而json不可以 pickle模块序列化和反序列化的过程如下图所示 123456789101112131415161718192021import pickledic=&#123;'name':'alvin','age':23,'sex':'male'&#125;print(type(dic)) # &lt;class 'dict'&gt; j=pickle.dumps(dic)print(type(j)) # &lt;class 'bytes'&gt;# 序列化# 注意是w是写入str,wb是写入bytes,j是'bytes'f=open('序列化对象_pickle','wb') pickle.dump(dic,f)# 等价于 f.write(j)f.close()# 反序列化f=open('序列化对象_pickle','rb')data=pickle.load(f)# 等价于 data=pickle.loads(f.read())f.close() python2和python3的pickle兼容性处理 12345678910111213# coding:utf-8import picklewith open('a.pkl',mode='wb') as f: # 一：在python3中执行的序列化操作如何兼容python2 # python2不支持protocol&gt;2，默认python3中protocol=4 # 所以在python3中dump操作应该指定protocol=2 pickle.dump('你好啊',f,protocol=2)with open('a.pkl', mode='rb') as f: # 二：python2中反序列化才能正常使用 res=pickle.load(f) print(res) shelve对象持久化保存方法，将对象保存到文件里面，默认的数据存储格式是二进制的。只有一个open函数，返回类似字典的对象，可读可写。key必须为字符串，而值可以是python所支持的数据类型 shelve.open(filename, flag=&#39;c&#39;, protocol=None, writeback=False) filename：是关联的文件路径 flag：可选参数 c：默认，如果数据文件不存在，就创建，允许读写；可以是 r: 只读； `w: 可读写; n: 每次调用open()都重新创建一个空的文件，可读写。 writeback：默认为False。当设置为True以后，shelve对象将为所有访问过的条目保留缓存并在close()或sync()时将它们写回到DB。 优点：减少了出错的概率，对持久化字典中可变条目的修改更方便。 缺点：如果访问的条目很多，这会消耗大量内存作为缓存，并会使得关闭操作变得非常缓慢，因为所有被访问的条目都需要写回到字典（无法确定被访问的条目中哪个是可变的，也无法确定哪个被实际修改了）。 shelve.close()：同步并关闭shelve对象。注意：每次使用完毕，都必须确保shelve对象被安全关闭。同样可以使用 with shelve.open() 作为上下文管理器 xml12345678910111213import xml.etree.ElementTree as ETtree = ET.parse("xmltest.xml")root = tree.getroot()# 遍历xml文档for child in root: print('========&gt;',child.tag,child.attrib,child.attrib['name']) for i in child: print(i.tag,i.attrib,i.text) # 只遍历year 节点for node in root.iter('year'): print(node.tag,node.text) 1234567891011121314151617181920import xml.etree.ElementTree as ET tree = ET.parse("xmltest.xml")root = tree.getroot() # 修改for node in root.iter('year'): new_year=int(node.text)+1 node.text=str(new_year) node.set('updated','yes') node.set('version','1.0')tree.write('test.xml') # 删除nodefor country in root.findall('country'): rank = int(country.find('rank').text) if rank &gt; 50: root.remove(country) tree.write('output.xml') 12345678910111213# 在country内添加（append）节点year2import xml.etree.ElementTree as ETtree = ET.parse("a.xml")root=tree.getroot()for country in root.findall('country'): for year in country.findall('year'): if int(year.text) &gt; 2000: year2=ET.Element('year2') year2.text='新年' year2.attrib=&#123;'update':'yes'&#125; country.append(year2) #往country节点下添加子节点tree.write('a.xml.swap') root.iter(str)：全文搜索 root.find(str)：在root的子节点找，只找一个 root.findall(str)：在root的子节点找，找所有 自己创建xml文档 12345678910111213141516import xml.etree.ElementTree as ET new_xml = ET.Element("namelist")name = ET.SubElement(new_xml,"name",attrib=&#123;"enrolled":"yes"&#125;)age = ET.SubElement(name,"age",attrib=&#123;"checked":"no"&#125;)sex = ET.SubElement(name,"sex")sex.text = '33'name2 = ET.SubElement(new_xml,"name",attrib=&#123;"enrolled":"no"&#125;)age = ET.SubElement(name2,"age")age.text = '19' et = ET.ElementTree(new_xml) #生成文档对象et.write("test.xml", encoding="utf-8",xml_declaration=True) ET.dump(new_xml) #打印生成的格式 configparserini配置文件如下 12345678910111213# 注释1; 注释2[section1]k1 = v1k2:v2user=egonage=18is_admin=truesalary=31[section2]k1 = v1 读取1234567891011121314151617181920212223242526272829303132import configparserconfig=configparser.ConfigParser()config.read('a.cfg')#查看所有的标题res=config.sections() #['section1', 'section2']print(res)#查看标题section1下所有key=value的keyoptions=config.options('section1')print(options) #['k1', 'k2', 'user', 'age', 'is_admin', 'salary']#查看标题section1下所有key=value的(key,value)格式item_list=config.items('section1')print(item_list) #[('k1', 'v1'), ('k2', 'v2'), ('user', 'egon'), ('age', '18'), ('is_admin', 'true'), ('salary', '31')]#查看标题section1下user的值=&gt;字符串格式val=config.get('section1','user')print(val) #egon#查看标题section1下age的值=&gt;整数格式val1=config.getint('section1','age')print(val1) #18#查看标题section1下is_admin的值=&gt;布尔值格式val2=config.getboolean('section1','is_admin')print(val2) #True#查看标题section1下salary的值=&gt;浮点型格式val3=config.getfloat('section1','salary')print(val3) #31.0 改写123456789101112131415161718192021222324252627282930import configparserconfig=configparser.ConfigParser()config.read('a.cfg',encoding='utf-8')#删除整个标题section2config.remove_section('section2')#删除标题section1下的某个k1和k2config.remove_option('section1','k1')config.remove_option('section1','k2')#判断是否存在某个标题print(config.has_section('section1'))#判断标题section1下是否有userprint(config.has_option('section1',''))#添加一个标题config.add_section('egon')#在标题egon下添加name=egon,age=18的配置config.set('egon','name','egon')config.set('egon','age',18) #报错,必须是字符串#最后将修改的内容写入文件,完成最终的修改config.write(open('a.cfg','w')) 使用案例添加一个ini文档 12345678910111213141516import configparser config = configparser.ConfigParser()config["DEFAULT"] = &#123;'ServerAliveInterval': '45', 'Compression': 'yes', 'CompressionLevel': '9'&#125; config['bitbucket.org'] = &#123;&#125;config['bitbucket.org']['User'] = 'hg'config['topsecret.server.com'] = &#123;&#125;topsecret = config['topsecret.server.com']topsecret['Host Port'] = '50022' # mutates the parsertopsecret['ForwardX11'] = 'no' # same hereconfig['DEFAULT']['ForwardX11'] = 'yes'with open('example.ini', 'w') as configfile: config.write(configfile) hashlib(加密)hash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值。 特点： 只要传入的内容一样，得到的hash值一样，可用于非明文密码传输时密码校验 不能由hash值返解成内容，即可以保证非明文密码的安全性 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的，可以用于对文本的哈希处理 1234567891011121314import hashlib m=hashlib.md5()# m=hashlib.sha256() m.update('hello'.encode('utf8'))print(m.hexdigest()) # 5d41402abc4b2a76b9719d911017c592 m.update('alvin'.encode('utf8')) print(m.hexdigest()) # 92a7e713c30abbb0319fa07da2a5c4af m2=hashlib.md5()m2.update('helloalvin'.encode('utf8'))print(m2.hexdigest()) # 92a7e713c30abbb0319fa07da2a5c4af 把一段很长的数据update多次，与一次update这段长数据，得到的结果一样，但是update多次为校验大文件提供了可能。 hash加密算法虽然看起来很厉害，但是他是存在一定缺陷的，即可以通过撞库可以反解。有必要对加密算法中添加自定义key再来做加密（即密码加盐，可以提升撞库的成本）。 1234567import hashlib # ######## 256 ######## hash = hashlib.sha256('898oaFs09f'.encode('utf8'))hash.update('alvin'.encode('utf8'))print (hash.hexdigest()) # e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7 模拟撞库 1234567891011121314151617181920212223242526import hashlib# 假定我们知道hash的微信会设置如下几个密码passwds=[ 'alex3714', 'alex1313', 'alex94139413', 'alex123456', '123456alex', 'a123lex', ]def make_passwd_dic(passwds): dic=&#123;&#125; for passwd in passwds: m=hashlib.md5() m.update(passwd.encode('utf-8')) dic[passwd]=m.hexdigest() return dicdef break_code(cryptograph,passwd_dic): for k,v in passwd_dic.items(): if v == cryptograph: print('密码是===&gt;\033[46m%s\033[0m' %k)cryptograph='aee949757a2e698417463d47acac93df'break_code(cryptograph,make_passwd_dic(passwds)) hmac(加密)为了防止密码被撞库，我们可以使用python中的另一个hmac 模块，它内部对我们创建key和内容做过某种处理后再加密。 12345import hmach1=hmac.new('hello'.encode('utf-8'),digestmod='md5')h1.update('world'.encode('utf-8'))print(h1.hexdigest()) 要想保证hmac最终结果一致，必须保证： hmac.new括号内指定的初始key一样 无论update多少次，校验的内容累加到一起是一样的内容 1234567891011121314# 操作一import hmach1=hmac.new('hello'.encode('utf-8'),digestmod='md5')h1.update('world'.encode('utf-8'))print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b# 操作二import hmach2=hmac.new('hello'.encode('utf-8'),digestmod='md5')h2.update('w'.encode('utf-8'))h2.update('orld'.encode('utf-8'))print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b suprocesssubprocess 模块允许我们启动一个新进程，并连接到它们的输入/输出/错误管道，从而获取返回值。 123456789101112131415161718192021222324252627282930import subprocess'''sh-3.2# ls /Users/egon/Desktop |grep txt$mysql.txttt.txt事物.txt'''res1=subprocess.Popen('ls /Users/jieli/Desktop',shell=True,stdout=subprocess.PIPE)res=subprocess.Popen('grep txt$',shell=True,stdin=res1.stdout, stdout=subprocess.PIPE)print(res.stdout.read().decode('utf-8'))#等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grepres1=subprocess.Popen('ls /Users/jieli/Desktop |grep txt$',shell=True,stdout=subprocess.PIPE)print(res1.stdout.read().decode('utf-8'))#windows下:# dir | findstr 'test*'# dir | findstr 'txt$'import subprocessres1=subprocess.Popen(r'dir C:\Users\Administrator\PycharmProjects\test\函数备课',shell=True,stdout=subprocess.PIPE)res=subprocess.Popen('findstr test*',shell=True,stdin=res1.stdout, stdout=subprocess.PIPE)print(res.stdout.read().decode('gbk')) #subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码 logging日志级别 CRITICAL：50，特别严重的问题，导致程序不能再继续运行时使用，一般很少使用，如:磁盘空间为空。FATAL = CRITICAL ERROR：40，程序出错误时使用，如:IO操作失败 WARNING：30，默认，程序未按预期运行时使用，但并不是错误，如:用户登录密码错误，FATAL = CRITICAL INFO：20，程序正常运行时使用 DEBUG：10，程序调试bug时使用 NOTSET：0，不设置 日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL 1234567import logginglogging.debug(&apos;调试debug&apos;)logging.info(&apos;消息info&apos;)logging.warning(&apos;警告warn&apos;)logging.error(&apos;错误error&apos;)logging.critical(&apos;严重critical&apos;) 全局配置logging.basicConfig()：通过具体参数来更改logging模块默认行为，指定全局配置，针对所有logger有效，控制打印到文件中，参数如下 filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。 filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。 format：指定handler使用的日志显示格式。可能用到的格式化串如下 %(name)s：Logger的名字 %(levelno)s：数字形式的日志级别 %(levelname)s：文本形式的日志级别 %(pathname)s：调用日志输出函数的模块的完整路径名，可能没有 %(filename)s：调用日志输出函数的模块的文件名 %(module)s：调用日志输出函数的模块名 %(funcName)s：调用日志输出函数的函数名 %(lineno)d：调用日志输出函数的语句所在的代码行 %(created)f：当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d：输出日志信息时的，自Logger创建以 来的毫秒数 %(asctime)s：字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(thread)d：线程ID。可能没有 %(threadName)s：线程名。可能没有 %(process)d：进程ID。可能没有 %(message)s：用户输出的消息 datefmt：指定日期时间格式。 level：设置rootlogger的日志级别。 stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 123456789101112131415161718192021222324import logginglogging.basicConfig(filename='access.log', format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p', level=10)logging.debug('调试debug')logging.info('消息info')logging.warning('警告warn')logging.error('错误error')logging.critical('严重critical')'''access.log内容:2017-07-28 20:32:17 PM - root - DEBUG -test: 调试debug2017-07-28 20:32:17 PM - root - INFO -test: 消息info2017-07-28 20:32:17 PM - root - WARNING -test: 警告warn2017-07-28 20:32:17 PM - root - ERROR -test: 错误error2017-07-28 20:32:17 PM - root - CRITICAL -test: 严重criticalpart2: 可以为logging模块指定模块级的配置,即所有logger的配置''' Formatter，Handler，Logger，Filter对象 logger：产生日志的对象。然后交给Filter过滤，然后交给不同的Handler输出 Filter：过滤日志的对象，不常用 Handler：接收日志然后控制打印到不同的地方，FileHandler用来打印到文件中，StreamHandler用来打印到终端。 Formatter：可以定制不同的日志格式对象，然后绑定给不同的Handler对象使用，以此来控制不同的Handler的日志格式 12345678910111213141516171819202122232425# logger对象logger=logging.getLogger(__file__)# Handler对象h1=logging.FileHandler('t1.log') # 打印到文件h3=logging.StreamHandler() # 打印到终端# Formatter对象formmater1=logging.Formatter('%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p',)formmater3=logging.Formatter('%(name)s %(message)s',)# 为Handler对象绑定格式h1.setFormatter(formmater1)h3.setFormatter(formmater3)# 将Handler添加给logger并设置日志级别logger.addHandler(h1)logger.addHandler(h3)logger.setLevel(10)# 测试logger.debug('debug')logger.info('info')logger.warning('warning')logger.error('error')logger.critical('critical') logger是第一级过滤，然后是filter和handler，我们可以给logger和handler同时设置level Logger的继承Logger=logging.getLogger([name])：name是这个Logger实例的名称，默认root。 Logger.name查看Logger实例的名称。 name：使用.分隔的多级结构。比如：名称为foo的logger，那么诸如foo.bar、foo.bar.baz和foo.bam这样的logger都是它的子logger。 子logger会自动继承父logger的定义和配置。 使用相同的名称多次调用logging.getLogger([name])方法，会返回同一个logger对象的引用。在同一个Python解释器进程的多个module内都有效 应用程序可以在一个module中定义一个父logger，然后在其他module中继承这个logger，而不必把所有的logger都配置一遍。 123456789101112131415161718192021222324252627282930313233import loggingformatter=logging.Formatter('%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p',)ch=logging.StreamHandler()ch.setFormatter(formatter)logger1=logging.getLogger('root')logger2=logging.getLogger('root.child1')logger3=logging.getLogger('root.child1.child2')logger1.addHandler(ch)logger2.addHandler(ch)logger3.addHandler(ch)logger1.setLevel(10)logger2.setLevel(10)logger3.setLevel(10)logger1.debug('log1 debug')logger2.debug('log2 debug')logger3.debug('log3 debug')'''2022-08-15 16:27:29 PM - root - DEBUG -1: log1 debug2022-08-15 16:27:29 PM - root.child1 - DEBUG -1: log2 debug2022-08-15 16:27:29 PM - root.child1 - DEBUG -1: log2 debug2022-08-15 16:27:29 PM - root.child1.child2 - DEBUG -1: log3 debug2022-08-15 16:27:29 PM - root.child1.child2 - DEBUG -1: log3 debug2022-08-15 16:27:29 PM - root.child1.child2 - DEBUG -1: log3 debug''' 应用 logging配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879"""logging配置"""import osimport logging.config# 定义三种日志输出格式 开始standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \ '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s'# 定义日志输出格式 结束logfile_dir = os.path.dirname(os.path.abspath(__file__)) # log文件的目录logfile_name = 'all2.log' # log文件名# 如果不存在定义的日志目录就创建一个if not os.path.isdir(logfile_dir): os.mkdir(logfile_dir)# log文件的全路径logfile_path = os.path.join(logfile_dir, logfile_name)# log配置字典LOGGING_DIC = &#123; 'version': 1, 'disable_existing_loggers': False, 'formatters': &#123; 'standard': &#123; 'format': standard_format &#125;, 'simple': &#123; 'format': simple_format &#125;, &#125;, 'filters': &#123;&#125;, 'handlers': &#123; #打印到终端的日志 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' &#125;, #打印到文件的日志,收集info及以上的日志 'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'standard', 'filename': logfile_path, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 &#125;, &#125;, 'loggers': &#123; # getLogger([name])未找到，默认使用key=''的配置，因此不同logger名的logger对象都能共用这段配置 # 应用场景，logging.getLogger(__name__)，不同的文件__name__不同，使用统一配置，又保证了打印日志时标识信息不同 '': &#123; 'handlers': ['default', 'console'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', 'propagate': True, # 向上（更高level的logger）传递 &#125;, &#125;,&#125;def load_my_logging_cfg(): logging.config.dictConfig(LOGGING_DIC) # 导入上面定义的logging配置 logger = logging.getLogger(__name__) # 生成一个log实例 logger.info('It works!') # 记录该文件的运行状态if __name__ == '__main__': load_my_logging_cfg() 使用 12345678910111213141516171819202122232425复制代码"""MyLogging Test"""import timeimport loggingimport my_logging # 导入自定义的logging配置logger = logging.getLogger(__name__) # 生成logger实例def demo(): logger.debug("start range... time:&#123;&#125;".format(time.time())) logger.info("中文测试开始。。。") for i in range(10): logger.debug("i:&#123;&#125;".format(i)) time.sleep(0.2) else: logger.debug("over range... time:&#123;&#125;".format(time.time())) logger.info("中文测试结束。。。")if __name__ == "__main__": my_logging.load_my_logging_cfg() # 在你程序文件的入口加载自定义logging配置 demo() re(正则)模块提供的方法 findall(regStr,str)：返回所有满足匹配条件的结果,放在列表里 search(regStr,str).group()：只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。 match(regStr,str)：在字符串开始处进行匹配，同search+^ split(regStr,str)：按匹配的内容分割 sub(regStr,replaceStr,str,n)：替换内容，不传n，则默认替换所有 subn(regStr,replaceStr,str,n)：同sub，不同在于返回元祖，第一项为替换后结果，第二项为总共替换的个数 compile(regStr)：重用正则对象 1234567891011121314import rere.findall('e','ccec aaae bbbe') # ['e', 'e', 'e']re.search('e','ccec aaae bbbe').group() # 'e're.match('e','ccec aaae bbbe') # Nonere.split('[ab]','abcd') # ['', '', 'cd']re.sub('a','A','ccec aaae bbbe') # 'ccec AAAe bbbe're.sub('a','A','ccec aaae bbbe',1) # 'ccec Aaae bbbe're.sub('a','A','ccec aaae bbbe',2) # 'ccec AAae bbbe're.subn('a','A','ccec aaae bbbe') # ('ccec AAAe bbbe', 3)obj=re.compile('\d&#123;2&#125;')obj.search('abc123eeee').group() # 12obj.findall('abc123eeee') # ['12'] 包 一种把模块组织到一起的方法，即创建一个包。包就是一个含有__init__.py文件的文件夹，文件夹内可以组织子模块或子包 1234567pool/ #顶级包├── __init__.py ├── futures #子包│ ├── __init__.py│ ├── process.py│ └── thread.py└── versions.py #子模块 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错 创建包的目的不是为了运行，而是被导入使用，包的本质是模块的模块的一种形式 导入包 包就是一个包含有init.py文件的文件夹 导入包本质就是在导入init.py文件。 包属于模块的一种，因而包以及包内的模块均是用来被导入使用的，而绝非被直接执行。首次导入包（如import pool）同样会做三件事： 产生一个名称空间 运行包下的init.py文件，将运行过程中产生的名字都丢到1的名称空间中 在当前执行文件所在的名称空间中得到一个名字pool，该名字指向init.py的名称空间，例如pool.xxx和pool.yyy中的xxx和yyy都是来自于pool下的init.py，也就是说导入包时并不会导入包下所有的子模块与子包 关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如import 顶级包.子包.子模块,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。 包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间 import包，产生的名称空间的名字同样来源于文件，即包下的init.py，导入包本质就是在导入init.py文件 绝对导入与相对导入包内的模块之间互相导入的方式有两种 绝对导入：以顶级包为起始 相对导入：.代表当前文件所在的目录，..代表当前目录的上一级目录，依此类推 123456789# 绝对导入from pool import versions # pool下的__init__.py# 相对导入# 操作pool下的__init__.py，保证pool.futuresfrom . import futures #或from pool import futures#操作futrues下的__init__.py，保证pool.futures.processfrom . import process #或from pool.futures import process 相对导入只能在包内部使用，用相对导入不同包下的模块是非法的，而且取上X级不能出包 无论是import还是from-import，但凡是在导入时带点的，点的左边必须是包,否则语法错误 使用语句中的点代表的是访问属性，m.n.x ----&gt; 向m要n，向n要x；导入语句中的点代表的是路径分隔符，import a.b.c --&gt; a/b/c，文件夹下a下有子文件夹b，文件夹b下有子文件或文件夹c，所以导入语句中点的左边必须是一个包 from 包 import * 在使用包时同样支持from pool.futures import * ，毫无疑问*代表的是futures下init.py中所有的名字， 通用是用变量__all__来控制*代表的意思 12# futures下的__init__.py__all__=['process','thread'] 类(class) 类的定义与实例化12345678910111213141516class Student: # 类的命名应该使用“驼峰体” school='清华大学' # 数据 #该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值 def __init__(self,name,sex,age): self.name=name self.sex=sex self.age=age def choose(self): # 功能 print('%s is choosing a course' %self.name) # 每实例化一次Student类就得到一个学生对象，会产生对象的名称空间，同样可以用__dict__查看stu1=Student('李建刚','男',28)stu2=Student('王大力','女',18)stu3=Student('牛嗷嗷','男',38)print(stu1.__dict__) # &#123;'name': '李建刚', 'sex': '男', 'age': 28&#125; 属性访问类属性与对象属性 对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址 属性查找顺序：对象在访问属性时，会优先从对象本身的dict中查找，未找到，则去类的dict中查找 类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数 12345678910111213# 访问数据属性，等同于Student.__dict__['school']Student.school # 查看，等同于obj1.__dict__['name']stu1.name# 访问数据属性，等同于Student.__dict__['school']Student.choose# 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址print(id(Student.school)) # 4301108704print(id(stu1.school)) # 4301108704print(id(stu2.school)) # 4301108704print(id(stu3.school)) # 4301108704 绑定方法 类中定义的函数绑定给对象，内存地址不同 绑定到对象的方法特殊之处在于，绑定给谁就由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法init也是一样的道理） 绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的。 12345678910# 类中定义的函数绑定给对象，内存地址不同print(id(Student.choose)) # 4335426280print(id(stu1.choose)) # 4300433608print(id(stu2.choose)) # 4300433608print(id(stu3.choose)) # 4300433608stu1.choose() # 等同于Student.choose(stu1)stu2.choose() # 等同于Student.choose(stu2)stu3.choose() # 等同于Student.choose(stu3) 封装 隐藏属性 隐藏数据属性是为了限制类外部对数据的直接操作 隐藏函数属性是为了隔离复杂度 Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），__属性名__，但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成_类名__属性名的形式 1234567891011121314151617class Foo: __N=0 # 变形为_Foo__N def __init__(self): # 定义函数时，会检测函数语法，所以__开头的属性也会变形 self.__x=10 # 变形为self._Foo__x def __f1(self): # 变形为_Foo__f1 print('__f1 run') def f2(self): # 定义函数时，会检测函数语法，所以__开头的属性也会变形 self.__f1() #变形为self._Foo__f1()print(Foo.__N) # 报错AttributeError:类Foo没有属性__Nobj = Foo()print(obbj.__x) # 报错AttributeError:对象obj没有属性__xprint(obbj._Foo__x) # 10 在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字_类名__属性 在类内部是可以直接访问双下滑线开头的属性的，比如self.__f1()，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。 变形操作只在类定义阶段发生一次,在类定义之后的赋值操作，不会变形。 开放接口类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制 12345678910111213class Teacher: def __init__(self,name,age): #将名字和年纪都隐藏起来 self.__name=name self.__age=age def tell_info(self): #对外提供访问老师信息的接口 print('姓名:%s,年龄:%s' %(self.__name,self.__age)) def set_info(self,name,age): #对外提供设置老师信息的接口，并附加类型检查的逻辑 if not isinstance(name,str): raise TypeError('姓名必须是字符串类型') if not isinstance(age,int): raise TypeError('年龄必须是整型') self.__name=name self.__age=age 类内的装饰器@property装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果 123456789101112class People: def __init__(self,name,weight,height): self.name=name self.weight=weight self.height=height @property def bmi(self): return self.weight / (self.height**2)obj=People('lili',75,1.85)# 触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果obj.bmi # 21.913805697589478 @setter12345678910111213141516class Foo: def __init__(self,val): self.__NAME=val #将属性隐藏起来 @property def name(self): return self.__NAME @name.setter def name(self,value): if not isinstance(value,str): #在设定值之前进行类型检查 raise TypeError('%s must be str' %value) self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME# 触发name.setter装饰器对应的函数name(f,’Egon')f.name='LiLi' # 触发name.setter对应的的函数name(f,123),抛出异常TypeErrorf.name=123 @deleter1234567891011class Foo: def __init__(self,val): self.__NAME=val #将属性隐藏起来 @property def name(self): return self.__NAME @name.deleter def name(self): raise PermissionError('Can not delete')# 触发name.deleter对应的函数name(f),抛出异常PermissionErrordel f.name @classmethod见 绑定到类的类方法 @staticmethod见 非绑定方法 继承 继承是一种创建新类的方式，用来解决类与类之间代码冗余问题，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类 类的内置属性__bases__可以查看类继承的所有父类 不建议使用多继承，有可能会引发可恶的菱形问题，扩展性变差，如果不可避免，应该使用Mixins，见下文 12345678910111213class ParentClass1: #定义父类 passclass ParentClass2: #定义父类 passclass SubClass1(ParentClass1): #单继承 passclass SubClass2(ParentClass1,ParentClass2): #多继承 passprint(SubClass2.__bases__) # (&lt;class '__main__.ParentClass1'&gt;, &lt;class '__main__.ParentClass2'&gt;) 在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类 在Python3中所有的类都是新式类，即使没有显式地继承object，也会默认继承该类 属性查找对象自己的dict&gt;&gt;子类&gt;&gt;父类，复杂情况见下文 父类如果不想让子类找到自己的属性，可以采用双下划线开头的方式将属性设置为私有的 菱形问题多继承，即一个子类是可以同时继承多个父类的，可能引发著名的 Diamond problem菱形问题(或称钻石问题，有时候也被称为“死亡钻石”) 123456789101112131415161718192021# A中有一个方法，B和/或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的class A(object): def test(self): print('from A')class B(A): def test(self): print('from B')class C(A): def test(self): print('from C')class D(B,C): passobj = D()obj.test() # 结果为：from B 继承原理对于定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如 12# 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法D.mro() # [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择,选择第一个父类 由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去 由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去 经典类与新式类区别 多继承结构为非菱形结构，查找属性按深度优先 多继承结构为菱形结构 经典类，深度优先，obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object 新式类，广度优先，obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object Mixins机制(多继承的正确打开方式)mixins机制核心：就是在多继承背景下尽可能地提升多继承的可读性。使用Mixin类实现多重继承要非常小心。Mixins机制本质仍是多继承，但同样遵守”is-a”关系 首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀 其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类 然后，它不依赖于子类的实现 最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了） 通常Mixin结果的类放在其他父类的左边 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路 1234567891011121314151617181920class Vehicle: # 交通工具 pass class FlyableMixin: def fly(self): ''' 飞行功能相应的代码 ''' print("I am flying") class CivilAircraft(FlyableMixin, Vehicle): # 民航飞机 pass class Helicopter(FlyableMixin, Vehicle): # 直升飞机 pass class Car(Vehicle): # 汽车 pass # ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路 派生与方法重用子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，在子类派生的新方法中重用父类的功能。 调用具体某个类的函数。这种方式和继承没有关系 super()：调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找。这种方式依赖于继承，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找 在Python2中super的使用需要完整地写成super(自己的类名,self) 12345678910111213class Teacher(People): def __init__(self,name,sex,age,title): People.__init__(self,name,age,sex) #调用的是函数,因而需要传入self self.title=title def teach(self): print('%s is teaching' %self.name)class Teacher(People): def __init__(self,name,sex,age,title): super().__init__(name,age,sex) #调用的是绑定方法，自动传入self self.title=title def teach(self): print('%s is teaching' %self.name) 两种方式的区别：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找 123456789101112131415161718class A: def test(self): print('from A') super().test()class B: def test(self): print('from B')class C(A,B): pass# 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”print(C.mro()) # [&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;]obj=C()obj.test()# from A# from B 组合在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Course: def __init__(self,name,period,price): self.name=name self.period=period self.price=price def tell_info(self): print('&lt;%s %s %s&gt;' %(self.name,self.period,self.price)) class Date: def __init__(self,year,mon,day): self.year=year self.mon=mon self.day=day def tell_birth(self): print('&lt;%s-%s-%s&gt;' %(self.year,self.mon,self.day)) class People: school='清华大学' def __init__(self,name,sex,age): self.name=name self.sex=sex self.age=age #Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码class Teacher(People): #老师是人 def __init__(self,name,sex,age,title,year,mon,day): super().__init__(name,age,sex) self.birth=Date(year,mon,day) #老师有生日 self.courses=[] #老师有课程，可以在实例化后，往该列表中添加Course类的对象 def teach(self): print('%s is teaching' %self.name) python=Course('python','3mons',3000.0)linux=Course('linux','5mons',5000.0)teacher1=Teacher('lili','female',28,'博士生导师',1990,3,23) # teacher1有两门课程teacher1.courses.append(python)teacher1.courses.append(linux) # 重用Date类的功能teacher1.birth.tell_birth() # 重用Course类的功能for obj in teacher1.courses: obj.tell_info() 多态性 多态性指的是可以在不用考虑对象具体类型的情况下而直接使用对象， 本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象 Python中一切皆对象，本身就支持多态性 好处在于增强了程序的灵活性和可扩展性 123456789# 我们可以在不考虑三者类型的情况下直接使用统计三个对象的长度s.__len__()l.__len__()t.__len__()# Python内置了一个统一的接口len(s)len(l)len(t) 鸭子类型：我们完全可以不依赖于继承，只需要制造出外观和行为相同对象，同样可以实现不考虑对象类型而使用对象，这正是Python崇尚的“鸭子类型”（duck typing）：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子”。比起继承的方式，鸭子类型在某种程度上实现了程序的松耦合度 抽象类硬性限制子类必须有某些方法名 12345678910111213import abc# 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod # 该装饰器限制子类必须定义有一个名为talk的方法 def talk(self): # 抽象方法中无需实现具体的功能 passclass Cat(Animal): # 但凡继承Animal的子类都必须遵循Animal规定的标准 def talk(self): passcat=Cat() # 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化 绑定方法与非绑定方法 ​类中定义的函数分为两大类 绑定方法 绑定到对象的对象方法(默认) 绑定到类的类方法(加上装饰器@classmethod)：专门给类用的，自动传入的第一个参数是类本身 1234567891011121314151617# 配置文件settings.py的内容HOST='127.0.0.1'PORT=3306# 类方法的应用import settingsclass MySQL: def __init__(self,host,port): self.host=host self.port=port @classmethod def from_conf(cls): # 从配置文件中读取配置进行初始化 return cls(settings.HOST,settings.PORT)# 绑定到类的方法print(MySQL.from_conf) # &lt;bound method MySQL.from_conf of &lt;class ‘__main__.MySQL'&gt;&gt;conn=MySQL.from_conf() # 调用类方法，自动将类MySQL当作第一个参数传给cls 非绑定方法(加上装饰器@staticmethod)：也称静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值 12345678910111213141516import uuidclass MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): return uuid.uuid1()conn=MySQL('127.0.0.1',3306)print(conn.id) # 100365f6-8ae0-11e7-a51e-0088653ea1ec# 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法print(MySQL.create_id) # &lt;function MySQL.create_id at 0x1025c16a8&gt;print(conn.create_id) # &lt;function MySQL.create_id at 0x1025c16a8&gt; 总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。 反射机制 反射机制指的是在程序的运行状态中，对于任意一个类，都可以知道这个类的所有属性和方法；对于任意一个对象，都能够调用他的任意方法和属性。这种动态获取程序信息以及动态调用对象的功能称为反射机制。 dir：获取任意一个类或者对象的属性列表，列表中全为字符串格式 hasattr、getattr、setattr、delattr：Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Teacher: def __init__(self,full_name): self.full_name =full_namet=Teacher('Egon Lin')# 列表中查看到的属性全为字符串print(dir(t)) #['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'full_name']# hasattr(object,'name')# 按字符串'full_name'判断有无属性t.full_namehasattr(t,'full_name') # True# getattr(object, 'name', default=None)# 等同于t.full_name,不存在该属性则返回默认值Nonegetattr(t,'full_name',None) # 'Egon Lin'# setattr(x, 'y', v)# 等同于t.age=18setattr(t,'age',18)# delattr(x, 'y')# 等同于del t.agedelattr(t,'age') # 反射的应用class FtpServer: def serve_forever(self): while True: inp=input('input your cmd&gt;&gt;: ').strip() cmd,file=inp.split() if hasattr(self,cmd): # 根据用户输入的cmd，判断对象self有无对应的方法属性 func=getattr(self,cmd) # 根据字符串cmd，获取对象self对应的方法属性 func(file) def get(self,file): print('Downloading %s...' %file) def put(self,file): print('Uploading %s...' %file)&gt;&gt;&gt; server=FtpServer()&gt;&gt;&gt; server.serve_forever()input your cmd&gt;&gt;: get a.txtDownloading a.txt...input your cmd&gt;&gt;: put a.txtUploading a.txt... 内置方法Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发。 __str__：会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型 12345678910class People: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return '&lt;Name:%s Age:%s&gt;' %(self.name,self.age) #返回类型必须是字符串p=People('lili',18)#触发p.__str__()，拿到返回值后进行打印print(p) # &lt;Name:lili Age:18&gt; __del__：会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制del方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作 12345678class MySQL: def __init__(self,ip,port): self.conn=connect(ip,port) # 伪代码，发起网络连接，需要占用系统资源 def __del__(self): self.conn.close() # 关闭网络连接，回收系统资源 # 在对象obj被删除时，自动触发obj.__del__()obj=MySQL('127.0.0.1',3306) __call__：如果想让一个对象可以加括号调用，需要在该对象的类中添加这个方法。 12345678910class Foo: def __call__(self, *args, **kwargs): print(self) print(args) print(kwargs) obj=Foo()#1、要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法，该方法会在调用对象时自动触发#2、调用obj的返回值就是__call__方法的返回值res=obj(1,2,3,x=1,y=2) 对象()-&gt;类内的call 类()-&gt;自定义元类内的call 自定义元类()-&gt;内置元类call 元类 用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type，调用元类type(class_name,class_bases,class_dic)，type参数(类的关键组成部分)如下 class_name：类名:,class_name=&#39;StanfordTeacher&#39; class_bases：基类们，class_bases=(object,) class_dic：类的名称空间，类的名称空间是执行类体代码而得到的 class关键字创建类的过程 自定义元类来控制类的产生自定义元类可以控制类的产生过程，类的产生过程其实就是元类的调用过程 一个类没有声明自己的元类，默认他的元类就是type 除了使用内置元类type，我们也可以通过继承type来自定义元类，然后使用metaclass关键字参数为一个类指定元类 只有继承了type类的类才是元类 StanfordTeacher类的产生过程StanfordTeacher=Mymeta(‘StanfordTeacher’,(object),{…})，调用Mymeta就是调用type.__call__，type.__call__函数干了3件事 先造一个空对象=&gt;StanfordTeacher,调用Mymeta类内的__new__方法 再调用Mymeta这个类内的__init__方法，完成初始化对象的操作 返回初始化好的对象 只要是调用类，那么会一次调用类内的__new__和类内的__init__ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类 def __init__(self,class_name,class_bases,class_dic): print(self) #&lt;class '__main__.StanfordTeacher'&gt; print(class_name) # StanfordTeacher print(class_bases) #(&lt;class 'object'&gt;,) print(class_dic) #&#123;'__module__': '__main__', '__qualname__': 'StanfordTeacher', '__init__': &lt;function StanfordTeacher.__init__ at 0x102af5e40&gt;, 'say': &lt;function StanfordTeacher.say at 0x102af5ee0&gt;&#125; super(Mymeta, self).__init__(class_name, class_bases, class_dic) # 重用父类的功能 if class_name.islower(): raise TypeError('类名%s请修改为驼峰体' %class_name) if '__doc__' not in class_dic or len(class_dic['__doc__'].strip(' \n')) == 0: raise TypeError('类中必须有文档注释，并且文档注释不能为空') def __new__(cls, *args, **kwargs): # 造Mymeta的对象 print(cls,args,kwargs) # class '__main__.Mymeta'&gt; ('StanfordTeacher', (&lt;class 'object'&gt;,), &#123;'__module__': '__main__', '__qualname__': 'StanfordTeacher', '__init__': &lt;function StanfordTeacher.__init__ at 0x102af5e40&gt;, 'say': &lt;function StanfordTeacher.say at 0x102af5ee0&gt;&#125;) &#123;&#125; return super().__new__(cls,*args, **kwargs) def __call__(self, *args, **kwargs): # Mymeta.__call__=》干了3件事 # 1、Mymeta.__call__函数内会先调用StanfordTeacher内的__new__ people_obj=self.__new__(self) # 2、Mymeta.__call__函数内会调用StanfordTeacher内的__init__ self.__init__(people_obj,*args, **kwargs) # print('people对象的属性：',people_obj.__dict__) people_obj.__dict__['xxxxx']=11111 # 3、Mymeta.__call__函数内会返回一个初始化好的对象 return people_obj # StanfordTeacher=Mymeta('StanfordTeacher',(object),&#123;...&#125;)class StanfordTeacher(object,metaclass=Mymeta): """ 类StanfordTeacher的文档注释 """ school='Stanford' def __init__(self,name,age): self.name=name self.age=age def say(self): print('%s says welcome to the Stanford to learn Python' %self.name)teacher=StanfordTeacher('xxx',18) 编码 ASCII –&gt; GB2312 –&gt; GBK1.0 –&gt; GB18030ASCII –&gt; UNICODE –&gt; UTF-8 unicode：一个字符占2字节 UTF-8：对unicode的压缩和优化，可变长的字符编码集 python2中默认为ASCII，因为Python2的盛行是早于unicode，需要声明编码类型，文件首行写入# coding:utf-8，python3中默认为utf-8 文件处理 12345678# 1. 打开文件，由应用程序向操作系统发起系统调用open(...)，操作系统打开该文件，对应一块硬盘空间，并返回一个文件对象赋值给一个变量ff=open('a.txt','r',encoding='utf-8') #默认打开模式就为r# 2. 调用文件对象下的读/写方法，会被操作系统转换为读/写硬盘的操作data=f.read()# 3. 向操作系统发起关闭文件的请求，回收系统资源f.close() close(资源回收)打开一个文件包含两部分资源： 操作系统打开的文件 应用程序的变量f 操作完毕一个文件时，必须把与该文件的这两部分资源回收 12345# del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件无法关闭，白白占用资源f.close() # 回收操作系统打开的文件资源# print(f)# f.read() # 变量f存在，但是不能再读了del f # 回收应用程序级的变量 with(上下文管理)在执行完子代码块后，with 会自动执行f.close()，回收操作系统打开的文件资源 1234567with open('a.txt','w') as f: pass# 可同时打开多个文件，用逗号分隔开即可with open('a.txt','r') as read_f,open('b.txt','w') as write_f: data = read_f.read() write_f.write(data) open(操作系统打开文件)open(url,mode,encoding)：操作系统打开文件(即对应一块硬盘空间)，并返回一个文件对象(又称文件句柄) url：文件路径 mode: 文件的操作模式，值如下 r：只读，默认模式。在文件不存在时则报错,文件存在时文件内指针直接跳到文件开头 w：只写。在文件不存在时会创建空文档，文件存在会清空文件，文件指针跑到文件开头 a：只追加写。在文件不存在时会创建空文档,文件存在会将文件指针直接移动到文件末尾 x：只写。不常用，不可读；在文件不存在时会创建空文档，文件存在则报错 +:与r/w/a之一结合使用，如&#39;r+&#39;、&#39;rb+&#39;、&#39;r+b&#39;，可读可写。在平时工作中，一般不用可读可写的模式 t：默认模式，&#39;r&#39;代表&#39;rt&#39;，必须与r/w/a之一结合使用，如&#39;rt&#39;、&#39;wt&#39;、&#39;at&#39;，文本模式，读写文件都是以字符串（unicode）为单位的，只能针对文本文件，必须指定encoding参数 b：必须与r/w/a之一结合使用，如&#39;rb&#39;、&#39;wb&#39;、&#39;ab&#39;，二进制模式，读写文件都是以bytes/二进制为单位的，可以针对所有文件，一定不能指定encoding参数 encoding：指定操作文本文件的字符编码。如果没有指定编码，那么打开文本文件的默认编码是操作系统规定的，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。文件以什么编码存的，就要以什么编码打开。 windows路径分隔符\有转义问题，解决：open(r&#39;C:\a.txt\nb\c\d.txt&#39;) w 模式与 a 模式的异同： 相同点：在文件不关闭的情况下，连续的写入，后写的内容一定跟在前写内容的后面 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后。以w模式重新打开文件，则会清空文件内容 t 模式只能用于操作文本文件,无论读写，都应该以字符串为单位，而存取硬盘本质都是二进制的形式，当指定 t 模式时，内部帮我们做了编码与解码b模式对比t模式: 在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便 针对非文本文件（如图片、视频、音频等）只能使用b模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# rinp_name=input('请输入你的名字: ').strip()inp_pwd=input('请输入你的密码: ').strip()with open(r'db.txt',mode='r',encoding='utf-8') as f: for line in f: # 把用户输入的名字与密码与读出内容做比对 u,p=line.strip('\n').split(':') if inp_name == u and inp_pwd == p: print('登录成功') break else: print('账号名或者密码错误')# wwith open('b.txt',mode='w',encoding='utf-8') as f: f.write('你好\n') f.write('我好\n') f.write('大家好\n') f.write('111\n222\n333\n')# aname=input('username&gt;&gt;&gt;: ').strip()pwd=input('password&gt;&gt;&gt;: ').strip()with open('db1.txt',mode='a',encoding='utf-8') as f: info='%s:%s\n' %(name,pwd) f.write(info)# twith open('a.txt',mode='rt',encoding='utf-8') as f: res=f.read() print(type(res)) # 输出结果为：&lt;class 'str'&gt;with open('a.txt',mode='wt',encoding='utf-8') as f: s='abc' f.write(s) # 写入的也必须是字符串类型# bwith open('1.mp4',mode='rb') as f: data=f.read() print(type(data)) # 输出结果为：&lt;class 'bytes'&gt;with open('a.txt',mode='wb') as f: msg="你好" res=msg.encode('utf-8') # res为bytes类型 f.write(res) # 在b模式下写入文件的只能是bytes类型# 拷贝文件src_file=input('源文件路径: ').strip()dst_file=input('目标文件路径: ').strip()with open(r'%s' %src_file,mode='rb') as read_f,open(r'%s' %dst_file,mode='wb') as write_f: for line in read_f: # print(line) write_f.write(line) 操作文件的方法读/写文件，应用程序对文件的读写请求都是在向操作系统发送，由操作系统控制硬盘把输入读入内存、或者写入硬盘 读 read：读取所有内容，执行完该操作后，文件指针会移动到文件末尾 参数:类型int，同一时刻读入多少到内存中，t模式下代表多少字符，b模式下代表多少Bytes readline：读取一行内容，光标移动到第二行首部 readlines：读取每一行内容，存放于列表中 12345678with open(r'g.txt',mode='rt',encoding='utf-8') as f: res1=f.readline() res2=f.readline() print(res2)with open(r'g.txt',mode='rt',encoding='utf-8') as f: res=f.readlines() print(res) read与freadlines都是将内容一次性读入内容，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式 12345678910111213# 方式一：同一时刻只读入一行内容到内存中with open('a.txt',mode='rt',encoding='utf-8') as f: for line in f: print(line)# 方式二：同一时刻只读入固定Bytes到内存中with open('1.mp4',mode='rb') as f: while True: # 同一时刻只读入1024个Bytes到内存中 data=f.read(1024) if len(data) == 0: break print(data) 写 write：写入内容，参数是字符串，需要自己写换行符 writelines：写入内容，参数是列表 1234567891011# 针对文本模式的写,需要自己写换行符f.write('1111\n222\n') # 针对b模式的写,需要自己写换行符f.write('1111\n222\n'.encode('utf-8'))# 文件模式f.writelines(['333\n','444\n']) # b模式 f.writelines([ bytes('333\n',encoding='utf-8'), '444\n'.encode('utf-8')]) 其他文件对象上的方法 readable：文件是否可读 writable：文件是否可写 flush：立刻将文件内容从内存刷到硬盘 tell：查看当前文件指针距离文件开头的位置 seek：主动控制文件内指针的移动，详见下文章节控制文件内指针移动 文件对象上的属性 closed：文件是否关闭 encoding：文件字符编码，如果文件打开模式为b，则没有该属性 name：文件名 控制文件内指针移动 seek：主动控制文件内指针的移动 第一个参数：指针移动的字节数，单位Bytes 第二个参数：模式控制，值如下 0：代表指针移动的字节数是以文件开头为参照的，默认模式 1：指针移动的字节数是以当前所在的位置为参照的 2：针移动的字节数是以文件末尾的位置为参照的 tell：查看当前文件指针距离文件开头的位置，单位Bytes 0模式可以在t或者b模式使用,而1跟2模式只能在b模式下用 文件内指针的移动都是Bytes为单位的,唯一例外的是t模式下的read(n),n以字符为单位 0模式 由于在t模式下，会将读取的内容自动解码，所以必须保证移动指针后读取的内容是一个完整字符，否则解码失败 1234567891011121314# a.txt用utf-8编码，内容如下（abc各占1个字节，中文“你好”各占3个字节）# abc你好with open('a.txt',mode='rt',encoding='utf-8') as f: # 参照文件开头移动了3个字节 f.seek(3,0) # 查看当前文件指针距离文件开头的位置 print(f.tell()) # 3 # 从第3个字节的位置读到文件末尾 print(f.read()) # '你好'with open('a.txt',mode='rb') as f: f.seek(6,0) print(f.read().decode('utf-8')) # '好' 1模式1234567with open('a.txt',mode='rb') as f: # 从当前位置往后移动3个字节，而此时的当前位置就是文件开头 f.seek(3,1) print(f.tell()) # 3 # 从当前位置往后移动4个字节，而此时的当前位置为3 f.seek(4,1) print(f.tell()) # 7 2模式123456789101112131415161718192021# a.txt用utf-8编码，内容如下（abc各占1个字节，中文“你好”各占3个字节）# abc你好with open('a.txt',mode='rb') as f: # 参照文件末尾移动0个字节， 即直接跳到文件末尾 f.seek(0,2) print(f.tell()) # 9 # 参照文件末尾往前移动了3个字节 f.seek(-3,2) print(f.read().decode('utf-8')) # '好'import timewith open('access.log',mode='rb') as f: f.seek(0,2) while True: line=f.readline() if len(line) == 0: # 没有内容，等0.5s后重新读取日志 time.sleep(0.5) else: print(line.decode('utf-8'),end='') 文件修改 硬盘空间是无法修改的,硬盘中数据的更新都是用新内容覆盖旧内容 内存中的数据是可以修改的 12345678910111213141516# 文件a.txt内容如下'''张一蛋 山东 179 49 12344234523李二蛋 河北 163 57 13913453521王全蛋 山西 153 62 18651433422'''with open('a.txt',mode='r+t',encoding='utf-8') as f: f.seek(9) f.write('&lt;妇女主任&gt;')# 文件修改后的内容如下'''张一蛋&lt;妇女主任&gt; 179 49 12344234523李二蛋 河北 163 57 13913453521王全蛋 山西 153 62 18651433422''' 文件修改方式一将文件内容发一次性全部读入内存,然后在内存中修改完毕后再覆盖写回原文件 优点: 在文件修改过程中同一份数据只有一份 缺点: 会过多地占用内存 12345with open('db.txt',mode='rt',encoding='utf-8') as f: data=f.read()with open('db.txt',mode='wt',encoding='utf-8') as f: f.write(data.replace('aaa','bbb')) 文件修改方式二以读的方式打开原文件,以写的方式打开一个临时文件,一行行读取原文件内容,修改完后写入临时文件…,删掉原文件,将临时文件重命名原文件名 优点: 不会占用过多的内存 缺点: 在文件修改过程中同一份数据存了两份 123456789import oswith open('db.txt',mode='rt',encoding='utf-8') as read_f,\ open('.db.txt.swap',mode='wt',encoding='utf-8') as wrife_f: for line in read_f: wrife_f.write(line.replace('aaa','bbb'))os.remove('db.txt')os.rename('.db.txt.swap','db.txt') 异常异常是程序发生错误的信号。程序一旦出现错误，便会产生一个异常，若程序中没有处理它，就会抛出该异常，程序的运行也随之终止。 异常特征 异常的追踪信息 异常的类型 语法上的错误SyntaxError，SyntaxError: invalid syntax 逻辑错误，常见如下 TypeError：数字类型无法与字符串类型相加，如1+&#39;2&#39; ValueError：当字符串包含有非数字的值时，无法转成int类型，如int(&#39;hello&#39;) NameError：引用了一个不存在的名字 IndexError：索引超出列表的限制，如[&#39;egon&#39;,&#39;aa&#39;][3] KeyError：引用了一个不存在的key，如{&#39;name&#39;:&#39;egon&#39;}[&#39;age&#39;] AttributeError：引用的属性不存在，如 123class Foo: passFoo.x ZeroDivisionError：除数不能为0，如1/0 异常的内容 异常处理为了保证程序的容错性与可靠性，即在遇到错误时有相应的处理机制不会任由程序崩溃掉，我们需要对异常进行处理，处理的基本形式为 12345678910111213try: 被检测的代码块except 异常类型1 as e： 检测到异常，就执行这个位置的逻辑except 异常类型2 as e: pass......except Exception as e: 其他类型的异常统一用此处的逻辑处理else: 如果被检测的子代码块没有异常发生，则会执行else的子代码finally: 无论被检测的子代码块有无异常发生，都会执行finally的子代码 else必须跟在except之后，不能单独存在，只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块 可以使用try-except-finally、try-finally的形式。无论被检测的代码块是否触发异常，都会执行finally的子代码块，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件、关闭数据库连接等 1234567891011121314151617181920212223try: print('start...') print(x) # 引用了一个不存在的名字，触发异常NameError print('end...')except NameError as e: # as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因 print('异常值为：%s' %e)print('run other code...') # 执行结果为# start...# 异常值为：name 'x' is not defined# run other code...def convert_int(obj): try: res=int(obj) except (ValueError,TypeError): print('argument must be number or numeric string') res=None return res convert_int('xxx') # argument must be number or numeric stringconvert_int(&#123;'n':1&#125;) # argument must be number or numeric string 主动触发异常raise后必须是一个异常的类或者是异常的实例 123456789101112class Student: def __init__(self,name,age): if not isinstance(name,str): raise TypeError('name must be str') if not isinstance(age,int): raise TypeError('age must be int') self.name=name self.age=age stu1=Student(4573,18) # TypeError: name must be strstu2=Student('xxx','18') # TypeError: age must be int 自定义异常在内置异常不够用的情况下，我们可以通过继承内置的异常类来自定义异常类 12345678910111213class PoolEmptyError(Exception): # 可以通过继承Exception来定义一个全新的异常 def __init__(self,value='The proxy source is exhausted'): # 可以定制初始化方法 super(PoolEmptyError,self).__init__() self.value=value def __str__(self): # 可以定义该方法用来定制触发异常时打印异常值的格式 return '&lt; %s &gt;' %self.value class NetworkIOError(IOError): # 也可以在特定异常的基础上扩展一个相关的异常 pass raise PoolEmptyError # __main__.PoolEmptyError: &lt; The proxy source is exhausted &gt;raise NetworkIOError('连接被拒绝') # __main__.NetworkIOError: 连接被拒绝 断言断言语句assert expression，断定表达式expression成立，否则触发异常AssertionError，与raise-if-not的语义相同，如下 12345678age='18' # 若表达式isinstance(age,int)返回值为False则触发异常AssertionErrorassert isinstance(age,int) # 等同于if not isinstance(age,int): raise AssertionError 队列和堆栈两种数据结构 队列：FIFO,先进先出 堆栈：LIFO,后进先出 猴子补丁属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。核心就是用自己的代码替换所用模块的源代码。 功能：拥有在模块运行时替换的功能, 例如: 一个函数对象赋值给另外一个函数对象(把函数原本的执行的功能给替换了) 优缺点：采用猴子补丁之后，如果发现不符合预期，那也可以快速撤掉补丁。带了便利的同时也有搞乱源代码的风险 应用场景：如果我们的程序中已经基于json模块编写了大量代码了，发现有一个模块ujson比它性能更高，但用法一样，我们肯定不会想所有的代码都换成ujson.dumps或者ujson.loads,那我们可能会想到这么做import ujson as json，但是这么做的需要每个文件都重新导入一下，维护成本依然很高。此时我们就可以用到猴子补丁了。只需要在入口处加上，之所以在入口处加，是因为模块在导入一次后，后续的导入便直接引用第一次的成果 12345678import jsonimport ujsondef monkey_patch_json(): json.__name__ = 'ujson' json.dumps = ujson.dumps json.loads = ujson.loadsmonkey_patch_json()]]></content>
      <categories>
        <category>Python</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[baidu地图-web]]></title>
    <url>%2F2019%2F04%2F09%2Fbaidu%E5%9C%B0%E5%9B%BE-web%2F</url>
    <content type="text"><![CDATA[百度地图 JavaScript API v3.0 免费，接口无使用次数限制 兼容IE 6.0+，Android和iPhone 所有类都在BMap这个对象上，如：BMap.Map、BMap.Control、BMap.Overlay。 密钥只支持浏览器类型的ak。 异步加载123456789function initialize() &#123; var mp = new BMap.Map('map'); &#125;function loadScript() &#123; var script = document.createElement("script"); // 在引用脚本的时候添加callback参数，当脚本加载完成后callback函数会被立刻调用 script.src = "http://api.map.baidu.com/api?v=3.0&amp;ak=您的密钥&amp;callback=initialize"; document.body.appendChild(script); &#125; 基础类地理坐标点Point1234var point = new BMap.Point(116.404/*lng 纬度*/, 39.915/*lat 经度*/);var otherPoint=new BMap.Point(116.404, 39.915);//判断坐标点是否相等，当且仅当两点的经度和纬度均相等时返回truepoint.equals(otherPoint);// true 相对左上角的像素坐标点Pixel1234var pixel=new BMap.Pixel(10/*x坐标(px)*/,10/*y坐标(px)*/);var otherPixel=new BMap.Pixel(10,10);// 判断坐标点是否相等，当且仅当两点的x坐标和y坐标均相等时返回truepixel.equals(otherPixel);// true 地理坐标矩形区域Bounds123var sw =new BMap.Point(lng1/*lng 纬度*/, lat1/*lat 经度*/);var ne=new BMap.Point(lng2/*lng 纬度*/, lat2/*lat 经度*/);var bounds=new Bounds(sw/*矩形区域西南角*/, ne/*矩形区域东北角*/); Bounds方法 像素矩形区域大小Size123var size=new BMap.Size(10/*width(px)*/,10/*height(px)*/);var otherSize=new BMap.Size(10,10);size.equals(otherSize);// true 核心类地图实例Map12345678910111213141516&lt;style type="text/css"&gt; #container&#123; height:100px; width:100px; &#125;&lt;/style&gt;&lt;!--容器需要有宽高--&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;script&gt; // 参数可以是元素id，也可以是DOM元素对象 var mapOption=&#123;&#125;; var map = new BMap.Map("container"/*id或DOM元素*/,mapOption); var point = new BMap.Point(116.404, 39.915); // 地图初始化，未进行初始化的地图将不能进行任何操作 map.centerAndZoom(point/*中心点坐标*/, 15/*地图展示级别*/);&lt;/script&gt; 调用构造函数时，确保容器元素已经在挂载在页面上 mapOptions 原型上的方法原型上的方法 map上的事件地图实例的事件 1234567891011var map = new BMap.Map("container");map.centerAndZoom(new BMap.Point(116.404, 39.915), 11);function zoomEndListener(e/*事件参数e获取有关信息*/)&#123; // 获取事件发生后的地图信息，如下获取地图缩放后的级别 var zoomLevel = map.getZoom(); alert("地图缩放至：" + zoomLevel + "级"); // 移除事件监听 map.removeEventListener("zoomend", zoomEndListener);&#125;// 添加事件监听map.addEventListener("zoomend",zoomEndListener); 地图样式个性化使用个性化地图编辑平台生成地图样式json，调用原型上的setMapStyleV2(JavaScriptAPI V3.0支持) 设置地图样式 控件类自定义控件Control(控制类基类)123456789101112131415161718192021222324252627282930313233// 定义一个控件类，即functionfunction ZoomControl()&#123; // 设置控件默认停靠位置 this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT/*控件定位常量*/; // 设置控件默认偏移量 this.defaultOffset = new BMap.Size(10, 10);&#125;// 通过JavaScript的prototype属性继承BMap.Control类ZoomControl.prototype = new BMap.Control();// 当调用map.addControl()方法添加自定义控件时，API会调用该对象的initialize()方法用来初始化控件，需要实现此方法ZoomControl.prototype.initialize = function(map)&#123; // 创建控件所需的DOM元素 var div = document.createElement("div"); // 添加控件内容 div.appendChild(document.createTextNode("放大2级")); // 设置样式 div.style.cursor = "pointer"; div.style.border = "1px solid gray"; div.style.backgroundColor = "white"; // 添加DOM事件，点击一次放大两级 div.onclick = function(e)&#123; map.zoomTo(map.getZoom() + 2); &#125; // 自定义控件中的DOM元素最终都应该添加到地图容器（即地图所在的DOM元素）中去 // 地图容器可以通过map.getContainer()方法获得 map.getContainer().appendChild(div); // 将控件的DOM元素return return div;&#125;// 创建自定义控件实例var myZoomCtrl = new ZoomControl();// 添加自定义控件map.addControl(myZoomCtrl); 百度地图内置控件 控件定位常量 覆盖类覆盖类型 覆盖物容器 地图提供了若干容器，供覆盖物展示，通过map.getPanes方法可以得到容器元素,覆盖关系从上到下，如下： floatPane，显示信息窗口内容 markerMouseTarget，标注点击区域层 floatShadow，信息窗口阴影层 labelPane，文本标注层 markerPane，标注层 mapPane，矢量图形层 标注1234567891011121314151617181920212223242526272829var map=new BMap.Map('container');var point=new BMap.Point(116.404, 39.915);map.centerAndZoom(point,15);// 标注点var myIcon = new BMap.Icon("markers.png", new BMap.Size(23, 25), &#123; // 当标注显示在地图上时，其所指向的地理位置距离图标左上角各偏移10像素和25像素。 anchor: new BMap.Size(10, 25), // 当需要从一幅较大的图片中截取某部分作为标注图标时，需要指定大图的偏移位置，此做法与css sprites技术类似。 imageOffset: new BMap.Size(0, 0)&#125;);var marker=new BMap.Marker(point,&#123;/*自定义图标*/icon: myIcon&#125;);map.addOverlayer(marker);// 可拖拽marker.enableDragging();// 监听拖拽marker.addEventListener("dragend", function(e)&#123; alert("当前位置：" + e.point.lng + ", " + e.point.lat);&#125;) // 标注折线var polyline = new BMap.Polyline( [ new BMap.Point(116.399, 39.910), new BMap.Point(116.405, 39.920) ], &#123;strokeColor:"blue", strokeWeight:6, strokeOpacity:0.5&#125;);map.addOverlay(polyline); 自定义覆盖物123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 定义构造函数并继承Overlayfunction SquareOverlay(center, length, color)&#123; this._center = center; this._length = length; this._color = color;&#125;// 继承API的BMap.OverlaySquareOverlay.prototype = new BMap.Overlay();// 当调用map.addOverlay方法添加自定义覆盖物时，API会调用该对象的initialize方法用来初始化覆盖物SquareOverlay.prototype.initialize = function(map)&#123; // 保存map对象实例 this._map = map; // 创建div元素，作为自定义覆盖物的容器 var div = document.createElement("div"); div.style.position = "absolute"; // 可以根据参数设置元素外观 div.style.width = this._length + "px"; div.style.height = this._length + "px"; div.style.background = this._color; // 将div添加到覆盖物容器中 map.getPanes().markerPane.appendChild(div); // 保存div实例 this._div = div; // 需要将div元素作为方法的返回值，当调用该覆盖物的show、 // hide方法，或者对覆盖物进行移除时，API都将操作此元素。 return div;&#125;// 实现draw方法，设置覆盖物的位置，当地图移动、缩放等时，API都会调用覆盖物的draw方法，用于重新计算覆盖物的位置SquareOverlay.prototype.draw = function()&#123; // 通过map.pointToOverlayPixel方法将地理坐标转换到覆盖物所需的像素坐标。 var position = this._map.pointToOverlayPixel(this._center); this._div.style.left = position.x - this._length / 2 + "px"; this._div.style.top = position.y - this._length / 2 + "px";&#125;// 当调用map.removeOverlay或者map.clearOverlays方法时，API会自动将initialize方法返回的DOM元素进行移除。// 显示和隐藏覆盖物// 自定义覆盖物会自动继承Overlay的show和hide方法，修改由initialize方法返回的DOM元素的style.display属性。// 如果自定义覆盖物元素较为复杂，您也可以自己实现show和hide方法。SquareOverlay.prototype.show = function()&#123; if (this._div)&#123; this._div.style.display = ""; &#125;&#125;SquareOverlay.prototype.hide = function()&#123; if (this._div)&#123; this._div.style.display = "none"; &#125;&#125;// 自定义其他方法 通过构造函数的prototype属性，您可以添加任何自定义的方法，比如下面这个方法每调用一次就能改变覆盖物的显示状态SquareOverlay.prototype.toggle = function()&#123; if (this._div)&#123; if (this._div.style.display == "")&#123; this.hide(); &#125; else &#123; this.show(); &#125; &#125;&#125;// 添加自定义覆盖物var map = new BMap.Map("container");var point = new BMap.Point(116.404, 39.915);map.centerAndZoom(point, 15);var mySquare = new SquareOverlay(map.getCenter(), 100, "red");map.addOverlay(mySquare); 信息窗口123456789var opts = &#123; width : 250, // 信息窗口宽度 height: 100, // 信息窗口高度 title : "Hello" // 信息窗口标题&#125;// 创建信息窗口对象var infoWindow = new BMap.InfoWindow("World", opts);// 打开信息窗口map.openInfoWindow(infoWindow, map.getCenter()); 自定义信息窗口 自定义信息窗口InfoBox 叠加图层123456789var map = new BMap.Map("l-map");var point = new BMap.Point(116.404, 39.915);map.centerAndZoom(point, 15);// 创建交通流量图层实例var traffic = new BMap.TrafficLayer();// 将图层添加到地图上map.addTileLayer(traffic);// 从地图上移除图层map.removeTileLayer(traffic); 服务类坐标转换Convertor目前国内主要坐标系种类 WGS84：大地坐标系，目前广泛使用的GPS全球卫星定位系统使用的坐标系。 GCJ02：火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标 转百度坐标 123456789101112131415161718192021// 未转换坐标var x = 116.32715863448607;var y = 39.990912172420714;var ggPoint = new BMap.Point(x,y);// 转换完成的回调函数function translateCallback (data/*TranslateResults类*/)&#123; if(data.status/*StatusCode类*/ === 0) &#123; var marker = new BMap.Marker(data.points[0]); // bm为地图实例 bm.addOverlay(marker); &#125;&#125;var convertor = new BMap.Convertor();convertor.translate( [ggPoint],// 需要转换的点坐标组成数组，上限100个点坐标 3/*from 原坐标类型*/, 5/*to 目标坐标类型*/, translateCallback//转换后的回调函数) convertor.translate坐标类型参数 TranslateResults类status 全景类Panorama展示某位置的全景视图，可以单独放置在一个div容器中，也可以放在Map类的容器中]]></content>
      <categories>
        <category>utils</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex原理]]></title>
    <url>%2F2019%2F02%2F23%2Fvuex%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[vuex是专为vue应用程序开发的状态管理模式 工作流程 原理123456789101112class Store&#123;&#125;let install=()=&gt;&#123;&#125;export default &#123; Store, install&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[准备基础判断用户是否授权wx.getUSetting(Object) 123456789101112Page(&#123; data:&#123; &#125;, onLoad: function (options) &#123; wx.getSetting(&#123; success:(e)=&gt;&#123; console.log(e) &#125; &#125;) &#125;,&#125;) 授权获取用户信息wx.getUserInfo(Object Object) 旧版在任何地方调用都会在未授权时直接弹出授权弹窗，新版只有通过点击事件触发才会弹出授权弹框 123456789101112131415161718// wxml&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;onGetUserInfo&quot;&gt; 授权&lt;/button&gt;// jsPage(&#123; data:&#123; &#125;, onLoad()&#123; // 授权后调用能获取用户信息 wx.getUserInfo() &#125; onGetUserInfo(e)&#123; console.log(e) &#125;&#125;) 数据绑定1234567891011// wxml&lt;button title=&quot;&#123;&#123;username&#125;&#125;&quot;&gt; &#123;&#123;username&#125;&#125;&lt;/button&gt;// jsPage(&#123; data:&#123; username:&apos;wx&apos; &#125;,&#125;) 条件渲染和block组件123456789101112131415161718192021222324252627282930313233343536// xml&lt;view&gt; &lt;block wx:if=&quot;&#123;&#123;isAuthorized&#125;&#125;&quot;&gt; &lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt; &lt;open-data type=&quot;userNickName&quot;&gt;&lt;/open-data&gt; &lt;/block&gt; /* else if ==&gt; wx:elif */ &lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&apos;getUserInfo&apos;&gt; 授权 &lt;/button&gt;&lt;/view&gt;// jsPage(&#123; data: &#123; isAuthorized:false &#125;, getUserInfo(e)&#123; this.setData(&#123; isAuthorized:true, &#125;) &#125;, onLoad: function (options) &#123; wx.getSetting(&#123; success:(e)=&gt;&#123; try&#123; this.setData(&#123; isAuthorized: e.authSetting[&apos;scope.userInfo&apos;] &#125;) &#125;catch(e)&#123; console.log(&apos;未授权&apos;) &#125; &#125; &#125;) &#125;,&#125;) 事件及绑定进阶]]></content>
      <categories>
        <category>微信</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[把一个复杂系统分解到多个模块(文件)进行组合以方便编码，模块内部数据与实现是私有的，只向外部暴露一些接口(方法)，好处如下 避免命名冲突 按需加载 高复用，可维护 演变过程 全局function：将不同的功能封装成不同的全局函数 缺点：命名冲突，数据不安全，而且模块之间看不出关系 命名空间(namespace)：简单对象封装 作用：减少全局变量，减少命名冲突 缺点：命名空间冲突（两个库可能会使用同一个名称），数据不安全(外部可以直接修改模块内部的数据) 匿名自执行函数(闭包)，将依赖作为参数传入 作用：模块的独立性，模块内部数据与实现是私有的，外部只能通过暴露的方法操作，依赖关系明显 缺点：依赖的加载必须有一定顺序 模块化规范，CommonJS、AMD、CMD、ES6模块化 模块化规范 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 CommonJS通过require方法来同步加载依赖的模块(只有前面依赖的模块加载完成，才会加载后面依赖的模块及其他操作)，通过module.exports导出需要暴露的接口。 在服务端，模块文件都存在本地磁盘，读取非常快，模块的同步加载适用，CommonJS直接使用在浏览器端，CommonJS模块需要提前编译打包处理 模块可以多次加载，但只在第一次加载运行，结果会被缓存，之后的加载是直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 模块加载机制：加载模块，每次加载的是个新的对象(是模块输出的浅拷贝，模块内部的变量不会被影响)，与ES6模块化有重大差异 实现require命令的基本功能是：读入并执行一个JS文件，然后返回该模块的exports对象 1234567891011121314151617let fs=require("fs");function req(moduleName)&#123; // a.js module.exports="hello" let content=fs.readFileSync(moduleName,'utf8'); /*function fn(exports,module,require,__dirname,__filename) &#123; module.exports="hello"; return module.exports &#125;*/ let fn=new Function("exports","module","require","__dirname","__filename",content+"\n return module.exports"); let module=&#123; exports:&#123;&#125; &#125; return fn(module.exports,module,req,__dirname,__filename);&#125;let str=req("./a.js"); AMD（具体实现requireJS）与CommonJS不同的地方在于异步加载依赖的模块，加载后立即执行依赖模块，解决针对浏览器环境的模块化问题(由于网络等原因，同步加载不适用)，最具代表性的实现时requireJS。 AMD的模块通过&lt;script asnyc&gt;标签异步加载（浏览器并行加载静态资源的机制），加载完成后立即执行。AMD定义模块时指定回调函数，当依赖的全部模块加载并执行完成后，回调函数才运行，所以称AMD是异步加载依赖的模块 AMD优点 可在不转换代码的情况下直接在浏览器中运行 可清楚地显示多个依赖关系，按需加载 代码可运行在浏览器环境和Node.js环境下 AMD缺点 JavaScript运行环境没有原生支持AMD，需要先导入实现了AMD的库后才能正常使用 12345678910111213141516171819202122232425262728// define 声明模块 通过require使用一个模块let factories=&#123;&#125;;function define(moduleName,dependencies,factory) &#123; factory.dependencies=dependencies; factories[moduleName]=factory&#125;function require(mods,callback) &#123; let results=mods.map(function (mod) &#123; let factory=factories[mod]; let dependencies=factory.dependencies; let exports=null; require(dependencies,function () &#123; exports=factory.apply(null,arguments) &#125;); return exports; &#125;); return callback.apply(null,results);&#125;define('name',[],function () &#123; return 'hello'&#125;);define('age',['name'],function (name) &#123; return name+0&#125;);let val=require(['age'],function (age) &#123; console.log(age); return 2&#125;); CMD（具体实现seaJS）CMD规范专门用于浏览器端。与AMD相同的是异步加载依赖的模块；不同的是依赖模块加载后不立即执行，当被使用（遇到require语句）时才执行。CMD规范整合了CommonJS和AMD规范的特点 ES6模块化ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定。 缺点是目前无法直接运行在大部分JavaScript运行环境，必须通过工具转换成标准的ES5后才能正常运行。 与CommonJS差异 CommonJS 在脚本运行完才会生成加载对象；ES6模块在代码静态解析阶段就会生成输出接口，只是一种静态定义 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 12345678910111213141516171819202122232425262728// CommonJS// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;;// main.jsvar counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3// ES6// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webGL]]></title>
    <url>%2F2018%2F10%2F06%2FwebGL%2F</url>
    <content type="text"><![CDATA[WebGL是OpenGL的一个分支，在网页中模拟三维空间 浏览器支持跟浏览器无关的部分，WebGL也有执行不了的情况。因为WebGL的标准还没有完全统一，所以硬件，OS，浏览器兼容性，以及这些东西结合之后都会对WebGL产生影响。 webGL和传统网页的区别 普通网页组成成分：HTML、JavaScript； WebGL网页组成成分：HTML5、JavaScript和GLSL ES(着色器语言 OpenGL ES)； canvas元素定义绘图区域 JavaScript内嵌GLSL ES绘制三维图形 webGL坐标变换 从三维到二维的变换等基本的， WebGL是OpenGL的一个分支，使用右手坐标系。 坐标变换，将三维的情报向二维进行变换，如照相机。由深度决定的前后关系，根据远近进行放大和缩小，都必须提前进行运算。利用WebGL可以模拟三维空间。坐标变换大致可以分为三种 模型变换：程序中的三维空间里定义了基准点，就是原点。从这个原点出发，为了知道参照物的相对位置，就需要进行必要的坐标变换。 视图变换：为了决定镜头的位置和角度所进行的坐标变换就叫做视图变换。 投影变换：定义三维空间的摄影区域。比如横向还是纵向，最远多远等。程序无法模拟无限大的空间，所以，拍摄必须有一个明确的范围。投影变幻，通过远近法则，近大远小对物体进行描画。 渲染准备canvas定义区域1&lt;canvas id="canvas" width="200px" height="200px"&gt;&lt;/canvas&gt; 准备顶点着色器和片段着色器 固定渲染管线：3D渲染所进行的一连串的计算流程。在固定渲染管线中不需要理解细节，模型，视图，投影的坐标变换都会替我们计算好。 缺点就是自由度低，不能做一些特殊处理。 WebGL中，不存在固定渲染管线 可编辑渲染管线：可以由程序员控制的坐标变换机制 着色器(Shader)：记述坐标变换的机制。WebGL中坐标变换全部由自己来做。着色器类型： 顶点着色器：处理几何图形顶点，相关处理就是坐标变换 片段着色器：处理像素，颜色处理。 着色器的处理方法着色器的代码就是简单的字符串，添加有多种做法，只要把这个着色器字符串传给程序就可以。最简单的方法：把着色器记录在HTML中，利用HTML的script标签。 1234567&lt;script id="vshader" type="x-shader/x-vertex"&gt; &lt;!--顶点着色器--&gt;&lt;/script&gt; &lt;script id="fshader" type="x-shader/x-fragment"&gt; &lt;!--片段着色器--&gt;&lt;/script&gt; 矩阵基础知识 矩阵(Matrix)：矩阵的计算效率很高，而且及其便利。矩阵与矩阵相乘根据相乘的顺序得出的结果是不同的 3D渲染使用的是4x4的矩阵，行和列都是4个元素组成 可以在矩阵中完成模型，视图，投影的所有坐标变换处理。矩阵可以坐标变换保存起来 模型变换矩阵：3D模型的位置，扩大缩小，以及旋转等 视图变换矩阵：镜头的位置，镜头的方向，以及镜头对准了哪个点（注视点）等 投影变换矩阵，显示的横竖比例和视角等 各种坐标变换的矩阵相乘。将最终得到的矩阵传给WebGL的顶点着色器。顶点着色器从中获取模型坐标，显示出来。操作坐标变换的矩阵，可以决定模型在画面上如何绘制 矩阵相乘的顺序非常的重要 顶点和多边形WebGL中最基本的图形：点、线、三角形。非常逼真的3D模型，都是用无数的三角形构造的，三角形越多，视觉效果越好 顶点连接顺序和遮挡剔除顺时针连接或是逆时针顺序连接3D渲染里，看不到的东西不绘制是减轻负担的最普通的方法。里面的东西不绘制的机制，叫做遮挡剔除。OpenGL和WebGL如果设定了遮挡剔除，只会绘制外侧的多边形，内侧的所有多边形都不绘制。而多边形在内侧还是外侧的判断通过顶点的连接顺序决定，顺时针连接顶点的多边形是在外侧，而逆时针连接的多边形在内侧。 context的初始化cavans标签123&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;/body&gt; 获取context1234var c = document.getElementById('canvas');//获取canvas元素c.width = 500; //设置宽高c.height = 300;var gl=c.getContext('webgl')||c.getContext('experimental-webgl');//获取context对象 画面初始化 gl.clear(gl.COLOR_BUFFER_BIT); COLOR_BUFFER_BIT这个常量是为了使用canvas里面指定的颜色来清空画面而定义的。 gl.clearColor(0.0, 0.0, 0.0, 1.0);——使用指定颜色清空画面（rgba格式） 着色器的说明和基础作用WebGL里有顶点着色器和片段着色器两种着色器。相互依赖的，缺一不可，并且首先被调用的是顶点着色器。都可以使用GLSL来编写 顶点着色器：跟顶点相关的所有情报都可以传给顶点着色器 片段着色器(fragment)：片段着色器操作的是颜色，决定了画面的颜色输出。像素是画面上的最小的断片(fragment) GLSL的编写基础要从WebGL一侧向着色器传递数据的时候，需要用到一些特殊的修饰符所定义的变量。 顶点作色器部分 1234567attribute vec3 position;//attribute修饰符用于声明变量position，向顶点着色器传递各个顶点的不同的信息uniform mat4 mvpMatrix;//uniform修饰符向顶点着色器传递对所有顶点来说都一样的信息，如坐标变换矩阵attribute vec4 color;varying vec4 vColor//varying修饰符，是顶点着色器和片段着色器之间的桥梁。从顶点着色器向片段着色器传递数据void main(void) &#123; gl_Position = mvpMatrix * position; //把顶点信息传给顶点着色器，必须传给变量gl_Position（必须赋值）。&#125; 片段着色器部分 12345varying vec4 vColor;//从顶点着色器将数据传到片段着色器void main(void) &#123; gl_FragColor = vColor;//片段着色器要把数据传给变量gl_FragColor(虽然不是必须赋值的，但是一般情况下都会赋值)&#125; GLSL变量类型 vec*表示的是向量，*的部分是一个2～4的数字，vec2就代表一个2维的向量。 mat*表示的是方阵，和向量一样，可以指定的范围也是2～4，如果是mat3的话，就表示一个3x3的方阵。 另外，int是整型，float是浮点型，bool是布尔型，这些都跟C语言中是一个意思。vec*和mat*中的元素，都是浮点型。 顶点缓存的基础局部坐标就是模型的各个顶点相对于原点（x，y，z都为0）的坐标。这些顶点的局部坐标，必须在WebGL程序中进行变换，然后传给顶点着色器。在WebGL中，为了处理这些顶点的信息，并将这些顶点信息保存，则需要使用顶点缓存，WebGL中的顶点缓存叫做VBO（vertex buffer object）。WebGL中还有帧缓存，索引缓存等各种缓存]]></content>
      <categories>
        <category>3D</category>
        <category>webGL</category>
      </categories>
      <tags>
        <tag>3D</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leaflet]]></title>
    <url>%2F2018%2F04%2F23%2FLeaflet%2F</url>
    <content type="text"><![CDATA[用于交互式地图的JavaScript库，38KB大小 map中心类，用于在页面上创建地图并进行操作。 1234var map = L.map('map'/*插入的DOM元素id名*/, &#123;// 配置 center: [51.505, -0.09], zoom: 13&#125;); 配置项 选项 类型 默认 描述 图示 preferCanvas Boolean false 路径是否以canvas曾现，默认以svg呈现 attributionControl Boolean true 是否添加属性控件 zoomControl Boolean true 是否添加缩放控件 closePopupOnClick Boolean true 是否单击地图时关闭弹出窗口 zoomSnap Number 1 迫使地图的缩放级别始终是此的倍数，特别是在触控放大或fitBounds()后。默认情况下，缩放级别取最接近的整数；更低值允许更细的粒度。0表示缩放级别不会取最接近的整数 zoomDelta Number 1 在zoomIn()、zoomOut()或按键+和-或使用缩放控件之后，控制缩放级别改变多少 trackResize Boolean true 地图是否自动监控浏览器窗口尺寸变化来更新自己 boxZoom Boolean true shift键+鼠标拖拽是否能将地图某局部放大 doubleClickZoom Boolean/String true 是否可以通过双击放大地图或shift+双击缩小地图（如果通过center，双击缩放将放大到视图的中心，而不管鼠标位于何处。） dragging Boolean true 是否能用鼠标或触摸拖动地图 crs CRS L.CRS.EPSG3857 要使用的坐标参照系。如果您不确定它的含义，请不要更改。 center LatLng undefined 地图的初始地理中心 zoom Number undefined 初始地图缩放级别 minZoom Number * 缩放级别最小值（如果未设置，并且地图中至少有一个GridLayer或TileLayer，会取他们minZoom中的最小值） maxZoom Number * 缩放级别最大值（如果未设置，并且地图中至少有一个GridLayer或TileLayer，会取他们maxZoom中的最大值） layers Layer[] [] 最初添加到地图的图层的数组聚合 maxBounds LatLngBounds null 当其被设置，地图会将视图限制在给定的地理范围内，如果用户]]></content>
      <categories>
        <category>utils</category>
        <category>map</category>
      </categories>
      <tags>
        <tag>utils</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG]]></title>
    <url>%2F2018%2F04%2F11%2FSVG%2F</url>
    <content type="text"><![CDATA[SVG是Scalable Vector Graphics的缩写，即缩放式矢量图形。基于XML的互联网图形标准。 优点： 使用编辑器即可编辑图形 基于XML, SVG图形可以被很容易的搜索，脚本化和压缩 缩放不影响图形质量 支持随意打印成需要的尺寸 SVG开源标准 缺点： 比正常格式图片体积大 即使小图片也可能很大 绘制基本图形矩形 元素属性 x：定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px） y：定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px） rx，ry：定义圆角半径 width：定义矩形宽 height：定义矩形高 css样式属性 fill-opacity：定义填充颜色透明度（合法的范围是：0 - 1） stroke-opacity：定义笔触颜色的透明度（合法的范围是：0 - 1） fill：定义填充颜色 stroke：定义描边颜色 stroke-width：定义描边宽度 123456789101112131415161718&lt;svg width="500" height="400"&gt;/*普通矩形*/ &lt;rect x="10" y="10" width="300" height="150" style="fill:#CCCCCC;stroke:orange;stroke-width:5px;" /*可以在样式文件中定义*/ /&gt;/*圆角矩形*/ &lt;rect x="10" y="210" rx="50" ry="100" width="300" height="150" style="fill:#CCCCCC;stroke:orange;stroke-width:5px;stroke-opacity:.5;" /&gt;&lt;/svg&gt; 圆 元素属性 cx：定义圆心的x坐标 cy：定义圆心的y坐标 r：定义半径 stroke：定义描边色 stroke-width：定义描边宽度 fill：定义填充色 fill-opacity：定义填充色透明度 1234567891011&lt;svg width="500" height="400"&gt; &lt;circle cx="150" cy="100" r="50" stroke="orange" stroke-width="5" fill="#CFCFCF" fill-opacity=".6" /&gt;&lt;/svg&gt; 椭圆 元素属性 cx：定义椭圆中心的x坐标 cy：定义椭圆中心的y坐标 rx：定义水平半径 ry：定义垂直半径 stroke：定义描边色 stroke-width：定义描边宽度 fill：定义填充色 fill-opacity：定义填充色透明度 123456789101112&lt;svg width="500" height="400"&gt; &lt;ellipse cx="150" cy="100" rx="90" ry="50" stroke="orange" stroke-width="5" fill="#CFCFCF" fill-opacity=".6" /&gt;&lt;/svg&gt; 直线 元素属性 x1：定义线条起始点x坐标 y1：定义线条起始点y坐标 x2：定义线条终止点x坐标 y2：定义线条终止点y坐标 stroke：定义描边色 stroke-width：定义描边宽度 12345678&lt;svg width="500" height="400"&gt; &lt;line x1="0" y1="0" x2="250" y2="200" style="stroke:rgba(255,0,0,.5);stroke-width:5px;" /&gt;&lt;/svg&gt; 多边形 元素属性 points ：定义多边形每个角的 x 和 y 坐标组合（x、y之间,间隔，每个点坐标之间空格间隔） stroke：定义描边色 stroke-width：定义描边宽度 stroke-opacity：定义笔触颜色的透明度（合法的范围是：0 - 1） fill：定义填充颜色 123456789&lt;svg width="500" height="400"&gt; &lt;polygon points="150,75 258,137.5 258,262.5 150,325 42,262.6 42,137.5" stroke="orange" stroke-width="5" stroke-opacity=".5" fill="rgba(250,0,0,.3)" /&gt;&lt;/svg&gt; 折线 元素属性（与多边形类似） points ：定义折线各个点的 x 和 y 坐标组合（x、y之间,间隔，每个点坐标之间空格间隔） 1234567&lt;svg width="500" height="400"&gt; &lt;polyline points="150,75 258,137.5 258,262.5 150,325 42,262.6 42,137.5" stroke="orange" stroke-width="5" fill="none" /&gt;&lt;/svg&gt; 其他强大功能绘制文字 元素属性 x：文字的x轴坐标 y：文字的y轴坐标 dx：x轴偏移坐标 dy：y轴偏移坐标 rotate：所有文字旋转角度 textlength：渲染的文字所占据长度（可用来设置文字间距） lengthAdjust：使用何种方式来渲染文字占据长度，对应值如下 spacing： spacingAndGlyphs： 123456789101112131415&lt;svg width="500" height="400"&gt; &lt;text x="30" y="30"&gt; 网站地址 &lt;/text&gt; &lt;!--rotate 针对每一个字符设置旋转角度，如果文字多于设置数值，则多于的文字使用最后一个数值定义旋转--&gt; &lt;text x="30" y="60" rotate="40,70,90"&gt; 文字旋转 &lt;/text&gt; &lt;!--可以包含一个tspan元素生成多行文字--&gt; &lt;text x="30" y="90"&gt; &lt;tspan x="30" y="100"&gt;www.gbtags.com&lt;/tspan&gt; &lt;tspan x="30" y="120"&gt;www.gbtags.com&lt;/tspan&gt; &lt;tspan x="30" y="140"&gt;www.gbtags.com&lt;/tspan&gt; &lt;/text&gt; &lt;!--可以给文字添加链接--&gt; &lt;a xlink:href="http://www.gbtags.com" target="_blank"&gt; &lt;text x="30" y="180" fill="orange" textlength="200" font-size="18"&gt;gbtags.com&lt;/text&gt; &lt;/a&gt;&lt;/svg&gt; 描边 stroke：颜色 stroke-width：粗细 stroke-linecap：描边线的末端样式 stroke-dasharray：设置虚线的格式 ， 此属性可以帮助SVG生成漂亮的素描动画效果 stroke-dashoffset：定义从哪个位置开始绘制 123456789101112131415161718192021&lt;svg width="500" height="400"&gt; &lt;g&gt; &lt;text x="30" y="30"&gt;stroke例子&lt;/text&gt; &lt;path stroke="orange" stroke-width="10" d="M 50 50 L 300 50"/&gt; &lt;/g&gt; &lt;g&gt; &lt;text x="30" y="130"&gt;stroke linecap&lt;/text&gt; &lt;path stroke="orange" stroke-linecap="butt" stroke-width="10" d="M 50 150 L 300 150"/&gt; &lt;path stroke="orange" stroke-linecap="round" stroke-width="10" d="M 50 180 L 300 180"/&gt; &lt;path stroke="orange" stroke-linecap="square" stroke-width="10" d="M 50 210 L 300 210"/&gt; &lt;/g&gt; &lt;g&gt; &lt;text x="30" y="280"&gt;stroke dasharray&lt;/text&gt; &lt;path stroke="orange" stroke-dasharray="5,5" stroke-width="10" d="M 50 300 L 300 300" /&gt; &lt;path stroke="orange" stroke-dasharray="15,15" stroke-width="10" d="M 50 330 L 300 330" /&gt; &lt;path stroke="orange" stroke-dasharray="55,15" stroke-width="10" d="M 50 360 L 300 360" /&gt; &lt;/g&gt;&lt;/svg&gt; 滤镜 feBlend：与图像相结合的滤镜 feColorMatrix：用于彩色滤光片转换 feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset：过滤阴影 feSpecularLighting feTile feTurbulence feDistantLight：用于照明过滤 fePointLight：用于照明过滤 feSpotLight：用于照明过滤 1234567891011&lt;svg&gt;&lt;!--定义滤镜--&gt; &lt;defs&gt; &lt;filter id="myfilter" x="0" y="0"&gt; &lt;feGaussianBlur in="SourceGraphic" stdDeviation="5"/&gt; &lt;/filter&gt; &lt;/defs&gt;&lt;!--使用滤镜--&gt; &lt;rect x="30" y="30" width="200" height="100" stroke="green" stroke-width="10" fill="orange" filter="url(#myfilter)"/&gt;&lt;/svg&gt; 进阶效果定义图案填充图形 patternUnits：用来定义图案使用的单位 userSpaceOnUse objectBoundingBox 1234567891011121314151617181920212223&lt;svg width="500" height="400"&gt;&lt;!--定义图案--&gt; &lt;defs&gt; &lt;pattern id="mypattern" patternUnits="userSpaceOnUse" x="10" y="10" width="100" height="100" &gt; &lt;path d="M 0 0 L 100 0 L 50 100 z" fill="#222" stroke="orange" stroke-width="5" /&gt; &lt;/pattern&gt; &lt;/defs&gt;&lt;!--使用图案--&gt; &lt;rect x="10" y="10" width="300" height="200" stroke="green" stroke-width="5" fill="url(#mypattern)" /&gt;&lt;/svg&gt; 渐变效果123456789101112131415161718192021222324&lt;svg width="500" height="400"&gt;&lt;!--线性渐变定义--&gt; &lt;defs&gt; &lt;linearGradient id="linearGradient"&gt; &lt;stop offset="0%" stop-color="#FF0000" /&gt; &lt;stop offset="100%" stop-color="#00FFF00" /&gt; &lt;/linearGradient&gt; &lt;/defs&gt;&lt;!--渐变运用--&gt; &lt;rect x="10" y="10" width="300" height="100" stroke="ORANGE" stroke-width="5" fill = "url(#linearGradient)" /&gt;&lt;!--径向渐变定义--&gt; &lt;defs&gt; &lt;radialGradient id="radialGradient"&gt; &lt;stop offset="0%" stop-color="#FF0000" /&gt; &lt;stop offset="100%" stop-color="#00FFF00" /&gt; &lt;/radialGradient&gt; &lt;/defs&gt;&lt;!--渐变运用--&gt; &lt;rect x="10" y="150" width="100" height="100" stroke="ORANGE" stroke-width="5" fill = "url(#radialGradient)" /&gt;&lt;/svg&gt; SVG图形中添加超链接 SVG中a标签属性 xlink:show = &quot;new&quot; | &quot;replace&quot; xlink:actuate = &quot;onRequest&quot; xlink:href = &quot;&lt;IRI&gt;&quot; target = &quot;_replace&quot; | &quot;_self&quot; | &quot;_parent&quot; | &quot;_top&quot; | &quot;_blank&quot; | &quot;&lt;XML-Name&gt;&quot; 123456 &lt;svg width="500" height="400"&gt; &lt;a xlink:href="http://www.gbtags.com"&gt; &lt;rect x="10" y="10" width="200" height="200" style="fill:orange;stroke-width:5;stroke:rgb(222,0,0)" /&gt; &lt;/a&gt;&lt;/svg&gt; 动画标签animate 元素属性 from：定义动画初始值 to：定义动画结束值 attributeName：定义了需要动画的属性，如cx，即横向移动效果 dur：定义动画持续时间 begin：定义动画开始方式 fill：定义动画结束后图形是否重置，值如下 freeze：动画结束后图形不会重置 remove：动画结束后移除动画效果 restart：定义如何重新开始动画 repeatCount：定义重复动画次数 repeatDru：定义动画重复总计时间 keyTimes：定义对应帧的百分比 values：定义对应帧的数值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;svg width="300" height="300"&gt;&lt;!--嵌套方式--&gt; &lt;circle r="35" cx="35" cy="105" fill="brown"&gt; &lt;animate attributeName="cx" from="35" to="200" dur="3s" begin="click" fill="freeze" /&gt; &lt;/circle&gt; &lt;!--链接参考方式--&gt; &lt;circle id="orangeball" r="35" cx="35" cy="35" fill="orange"&gt; &lt;/circle&gt; &lt;animate xlink:href="#orangeball" attributeName="cx" from="35" to="200" dur="2s" begin="click" fill="remove" id="animate-brown" /&gt; &lt;circle id="brownball" r="35" cx="35" cy="105" fill="brown"&gt; &lt;/circle&gt; &lt;animate xlink:href="#brownball" attributeName="cx" from="35" to="300" dur="2s" restart="whenNotActive"/*非活动状态下可重新开始*/ repeatCount="indefinite"/*永不停止*/ repeatDur="00:30"/*重复动画的最长持续时间，指定时间过了即停止动画*/ begin="animate-brown.begin+2s"/*复杂开始方式*/ /&gt;&lt;!--定义动画帧--&gt; &lt;animate xlink:href="#orangeball" attributeName="cx" from="35" to="265" dur="2s" begin="click" fill="freeze" keyTimes="0;0.3;0.5;0.7;1" values="35;65;245;200;265" /&gt;&lt;/svg&gt; 路径路径绘制（Path）是SVG图形绘制中比较强大的元素。使用相关代码即可生成很复杂的图形 d属性对应的字母含义 M = Moveto （移动到坐标） L = Lineto （绘制直线到坐标） H = Horizontal lineto （绘制水平直线到坐标） V = Vertical lineto（绘制垂直直线到坐标） Q = Quadratic Bézier curve（绘制二次曲线到坐标） S = Smooth curveto（绘制光滑曲线到坐标） C = Curveto（绘制三次贝纳尔曲线到坐标） T = smooth quadratic Bézier curveto（绘制光滑三次贝纳尔曲线到坐标） A = elliptical Arc（绘制椭圆弧到坐标） Z = closepath（闭合路径） 大写代表参数是绝对路径，小写则相对路径，如M和m之间有区别 Z1234567&lt;svg width="500" height="400"&gt; &lt;!-- d属性对应的字母含义见上 --&gt; &lt;path d="M 100 100 L 300 100 L 200 300 z" style="fill:orange;stroke:#222222;stroke-width:5px;" /&gt;&lt;/svg&gt; M123&lt;svg width="500" height="400"&gt; &lt;path d="M 100 100 L 200 200" stroke="orange" stroke-width="3" /&gt;&lt;/svg&gt; Q1234&lt;svg width="500" height="400"&gt; &lt;!-- 绘制二次贝塞尔曲线 --&gt; &lt;path d="M 100,200 Q 200,400 300,200" fill="none" stroke="orange" stroke-width="3" /&gt;&lt;/svg&gt; C12345&lt;svg width="500" height="400"&gt; &lt;!-- 绘制三次贝塞尔曲线 --&gt; &lt;path d="M 0,0 C 10,10 390,10 400,0" fill="none" stroke="green" stroke-width="3" /&gt; &lt;path d="M 0,0 C 200,200 200,200 400,0" fill="none" stroke="green" stroke-width="3" /&gt;&lt;/svg&gt; A 参数属性 第一个：x轴半径 第二个：y轴半径 第三个：x轴旋转 第四个：选择大弧度(1)还是小弧度(0) 第五个：表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧 第六个：x,y轴坐标 1234567891011&lt;svg width="500" height="400"&gt; &lt;!-- 椭圆弧曲线参数：A rx ry x-axis-rotation large-arc-flag sweep-flag x y --&gt; &lt;path d="M100 100 A 30 50 1 0 0 200 150 z" fill="#080" stroke="#8f8" stroke-width="5" opacity="0.5"/&gt; &lt;path d="M100 100 A 30,50 0 0,1 200,150 z" fill="#088" stroke="cyan" stroke-width="5" opacity="0.5"/&gt; &lt;path d="M100 100 A300,30 0 0,0 200,150 " fill="#880" stroke="yellow" stroke-width="5" opacity="0.5" /&gt; &lt;path d="M100 100 A300,30 0 0,1 200,150 " fill="#800" stroke-width="5" opacity="0.5"/&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>HTML</category>
        <category>SVG</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas]]></title>
    <url>%2F2018%2F04%2F06%2FCanvas%2F</url>
    <content type="text"><![CDATA[&lt;canvas&gt;是一个可以使用脚本(通常为JavaScript)在其中绘制图形的HTML元素（html5新增标签，不兼容IE9之前的浏览器）。 jCanvaScript（canvas中的jquery） Canvas元素 可以向普通的图像一样被设计（盒模型等属性），没有为其规定样式规则时，其完全透明 只有两个属性默认大小（初始宽高）：300px*150px width height 该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果绘制图像是扭曲的, 尝试在&lt;canvas&gt;的属性中明确规定宽和高，而不是使用CSS。 开始标签和结束标签之间的内容，用于在浏览器不支持&lt;canvas&gt;时，对&lt;canvas&gt;元素进行替换（支持则忽略标签中内容） 123&lt;canvas id="clock" width="150" height="150"&gt; &lt;img src="images/clock.png" width="150" height="150" alt=""/&gt;&lt;/canvas&gt; &lt;/canvas&gt;标签不可省，如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来 渲染上下文&lt;canvas&gt;元素来定义绘图区域，同时支持二维和三维，但不直接提供绘图方法，而提供上下文机制来绘图 绘制二维空间步骤 创建标签 1&lt;canvas id="canvas" width="200px" height="200px"&gt;&lt;/canvas&gt; 获取元素及二维上下文 12var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); 通过上下文提供的方法进行绘制 12ctx.fillStyle ='rgba(255,0,0,1.0)';ctx.fillRect(0,0,200,200); 绘制webgl步骤 创建标签 1&lt;canvas id="canvas" width="200px" height="200px"&gt;&lt;/canvas&gt; 获取元素及webgl上下文 12var canvas = document.getElementById('canvas');var gl = canvas.getContext('webgl'); HTMLCanvasElement 的getContext()方法语法：canvas.getContext(contextType, contextAttributes);&lt;canvas&gt;元素的属性width/height和它的样式的width/height不是同一个概念，没有关系&lt;canvas&gt;css样式中设置宽高，不是改变的画布的大小，而是将&lt;canvas&gt;中的内容大小改变了（相当于PS中图层大小改变了，而画布大小不变，canvas中默认图层大小为300px*150px）&lt;canvas&gt;行内属性width和height是决定画布大小的，不会改变&lt;canvas&gt;中的内容大小（属性默认值同样是300和150） canvas绘图类似photoshop软件绘图，只是用代码控制，先设置样式再绘制 canvas描边是将选框作为中线进行描边，中线两边的边框不占满像素格时会自动补全，如出现默认1px的边框实际显示宽度为2px的情况 context.lineJoin——设置倒角形状 参数：round(圆角)、bevel(斜角) context.fillStyle——设置填充颜色 context.strokeStyle——设置描边颜色 context.lineCap——设置线条端点样式（在线段两端加一个形状） 参数：round(半圆)、square(长方形，高度多出宽一般的值)、butt(默认，不加形状) 路径(ps中的钢笔工具)路径开始和结束标志 context.beginPath()——开始绘制路径 context.closePath()——结束绘制路径，也有闭合钢笔路径功能 context.beginPath()和context.closePath()配套使用 路径的描边和填充 context.fill()——(相当于PS中路径填充) context.stroke()——(相当于PS中路径描边) 填充或描边动作只能识别离其最近的context.beginPath()和context.closePath()，每个单独的路径的绘制过程必须写在context.beginPath()和context.closePath()之间，否则之后的填充或描边动作会覆盖之前的效果 路径的保存和恢复 context.save()——保存路径 context.restore()——恢复路径 context.save()和 context.restore()配套使用，作用是其中间的代码不影响其他代码 路径的起始点 context.moveTo(x,y)——(相当于PS中在哪开始钢笔工具) 直线 context.lineTo(x,y)——(相当于PS中设置钢笔工具的锚点) 圆弧路径 context.arc(x,y,半径,起始弧度,结束弧度,旋转方向) 弧度和角度的关系：弧度=角度*Math.PI/180（角度取值：(-180,0]+[0,180]） 方向：顺时针(false，默认)，逆时针(true)经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大 其他曲线 context.arcTo(x1,y1,x2,y2,r) con.quadraticCurveTo(dx,dy,x1,y1);——贝塞尔曲线（控制点+结束坐标） con.bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1)——贝塞尔曲线（控制点1+控制点2+结束坐标） 绘制方框 context.rect(x,y,w,h)——绘制方框路径 context.fillRect(x,y,w,h)——绘制方框路径并填充，相当于 1234context.beginPath();context.rect(x,y,w,h)context.closePath()context.fill() context.strokeRect(l,t,w,h)——绘制方框路径并描边，相当于 1234context.beginPath();context.rect(x,y,w,h)context.closePath()context.stroke() 清除画布 context.clearRect(l,t,w,h)——清楚画布的一个方块绘制区 context.clearRect(0,0,canvas.width,canvas.height)——清空画布 变换（相当于将图层相对于画布变换） context.translate(x,y)——偏移，开始绘制点的偏移（图层的左上角） context.rotate(角度*Math.PI/180)——旋转（图层左上角为旋转中心） context.scale(宽的缩放比，高的缩放比)——缩放（图层左上角为缩放中心） 插入图片context.drawImage(oImg,x,y,w,h)等图片加载完，在执行cavans操作 1234567//利用图片预加载var newImg=new Image();newImg.onload=function()&#123;//监听图片加载完成事件//cavans操作 context.drawImage(this,x,y,w,h)&#125;newImg.src="1.jpg"//图片地址 设置背景context.createPattern(oImg,平铺方式) 平铺方式：&#39;repeat&#39;、&#39;repeat-x&#39;、&#39;repeat-y&#39;、&#39;no-repeat&#39; 123456789//利用图片预加载var newImg=new Image();newImg.onload=function()&#123;//监听图片加载完成事件//cavans操作 var bg=context.createPattern(this,'repeat'); context.fillStyle=bg; context.fillRect(0,0,300,300)&#125;newImg.src="1.jpg"//图片地址 渐变线性渐变context.createLinearGradient(x1,y1,x2,y2); 1234567var obj=context.createLinearGradient(150,100,150,200);//渐变的起点和终点（相对于这个cavans画布位置）//添加颜色点obj.addColorStop(0,'red');obj.addColorStop(0.5,'yellow');obj.addColorStop(1,'blue');context.fillStyle=obj;context.fillRect(150,100,100,100); 放射性渐变context.createRadialGradient(x1,y1,r1,x2,y2,r2); 1234567var obj=context.createRadialGradient(200,200,100,200,200,150);//渐变的起始边界和终点边界，第一和第二个园的圆心坐标和半径（相对于这个cavans画布位置）//添加颜色点obj=addColorStop(0,'red');obj.addColorStop(0.5,'yellow');obj=addColorStop(1,'blue');context.fillStyle=obj;context.fillRect(0,0,400，400); 文本 context.strockeText(要添加的文字，x,y)——描边文字添加 context.fillText(要添加的文字，x,y)——填充文字添加 context.font=&#39;文字大小 文字样式&#39;——文字大小，两个参数都不能省略 context.font=&#39;60px impact&#39; context.textAlign=——文字左右居中方式 参数：&#39;start&#39;（默认,效果等同于&#39;left&#39;）、&#39;right&#39;、&#39;end&#39;、&#39;center&#39; context.textBaseline=——文字上下居中方式 参数：&#39;alphabetic&#39;（默认）、&#39;middle&#39;、&#39;top&#39;、&#39;bottom&#39; context.measureText(文字)——获取文字属性，只有宽度，没有高度 1234context.font='60px impact';context.textBaseline='top';var textWidth=context.measureText('前端').width;context.fillText('前端'，(canvas.width-textWidth)/2，(canvas.height-60)/2)；//文字水平垂直居中 阴影 shadowOffsetX=、shadowOffsetY=——x轴偏移、y轴偏移 shadowBlur=——高斯模糊值 shadowColor=——阴影颜色 像素 context.getImageData(x,y,w,h)——获取canvas指定范围内所有的像素，返回一个对象，其中属性有 width：每行的像素数量 height：每列的像素数量 data：数组，整体像素的集合（每四项代表一个像素，为像素的rgba值） context.createImageData(w,h)——创建像素 context.putImageData(获取图像,x,y)——将获取到的像素添加到指定位置 合成 context.globalAlpha=0.5——全局阿尔法值 context.globalCompositeOperation=——覆盖合成，属性值有 source-over——新的图形覆盖原有图形 destination-over——原有图形覆盖新的图形 source-atop destination-atop source-in destination-in source-out destination-out lighter copy xor 将画布导出成图像 canvas.toDataURL()——返回结果为png格式，图片背景默认透明（火狐右键可以直接导出成图像） 事件操作 context.isPointInPath(x,y)——是否在点击范围内，返回true/false，只针对最近的路径范围]]></content>
      <categories>
        <category>2D</category>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>2D</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加文章时自动打开编辑器]]></title>
    <url>%2F2017%2F10%2F26%2FHexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[每次新建文章后自动打开新增的md文件，进行编辑 首先在站点目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 将下列内容写入脚本 windows平台的Hexo用户 123456789var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + data.path);&#125;); Mac平台Hexo用户 123456789var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 scripts目录新建的JavaScript脚本文件可以任意取名。 将下列内容写入脚本 windows平台的Hexo用户 123456789var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + data.path);&#125;); Mac平台Hexo用户 123456789var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改hexo主题添加文章阅读量统计功能]]></title>
    <url>%2F2017%2F10%2F26%2F%E4%BF%AE%E6%94%B9hexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[以旧版NexT主题为例 修改主题修改主题_config.yml文件打开主题的根目录下的_config.yml文件，在任意位置添加以下内容： 1234leancloud_visitors: enable: true app_id: #&lt;AppID&gt; app_key: #&lt;AppKEY&gt; 添加lean-analytics.swig文件在主题的layout\_scripts路径下，新建一个lean-analytics.swig文件，并向里面添加以下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!-- custom analytics part create by xiamo --&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;", "&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;");&lt;/script&gt;&lt;script&gt;function showTime(Counter) &#123; var query = new AV.Query(Counter); $(".leancloud_visitors").each(function() &#123; var url = $(this).attr("id").trim(); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; if (results.length == 0) &#123; var content = $(document.getElementById(url)).text() + ': 0'; $(document.getElementById(url)).text(content); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var object = results[i]; var content = $(document.getElementById(url)).text() + ': ' + object.get('time'); $(document.getElementById(url)).text(content); &#125; &#125;, error: function(object, error) &#123; console.log("Error: " + error.code + " " + error.message); &#125; &#125;); &#125;);&#125;function addCount(Counter) &#123; var Counter = AV.Object.extend("Counter"); url = $(".leancloud_visitors").attr('id').trim(); title = $(".leancloud_visitors").attr('data-flag-title').trim(); var query = new AV.Query(Counter); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment("time"); counter.save(null, &#123; success: function(counter) &#123; var content = $(document.getElementById(url)).text() + ': ' + counter.get('time'); $(document.getElementById(url)).text(content); &#125;, error: function(counter, error) &#123; console.log('Failed to save Visitor num, with error message: ' + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); newcounter.set("title", title); newcounter.set("url", url); newcounter.set("time", 1); newcounter.save(null, &#123; success: function(newcounter) &#123; console.log("newcounter.get('time')="+newcounter.get('time')); var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time'); $(document.getElementById(url)).text(content); &#125;, error: function(newcounter, error) &#123; console.log('Failed to create'); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log('Error:' + error.code + " " + error.message); &#125; &#125;);&#125;$(function() &#123; var Counter = AV.Object.extend("Counter"); if ($('.leancloud_visitors').length == 1) &#123; addCount(Counter); &#125; else if ($('.post-title-link').length &gt; 1) &#123; showTime(Counter); &#125;&#125;);&lt;/script&gt; 修改post.swig文件 在主题的layout\_macro路径下，打开post.swig文件，找到以下内容： 1234&#123;% if not is_index and theme.facebook_sdk.enable and theme.facebook_sdk.like_button %&#125; &amp;nbsp; | &amp;nbsp; &lt;div class="fb-like" data-layout="button_count" data-share="true"&gt;&lt;/div&gt;&#123;% endif %&#125; 在其后面添加如下内容： 12345&#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;"class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt;&#123;% endif %&#125; 添加完毕之后，文件内容像这个样子： 123456789101112&#123;% if not is_index and theme.facebook_sdk.enable and theme.facebook_sdk.like_button %&#125; &amp;nbsp; | &amp;nbsp; &lt;div class="fb-like" data-layout="button_count" data-share="true"&gt;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.leancloud_visitors.enable %&#125; &lt;span id="&#123;&#123; url_for(post.path) &#125;&#125;"class="leancloud_visitors" data-flag-title="&#123;&#123; post.title &#125;&#125;"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123;__('post.visitors')&#125;&#125; &lt;/span&gt;&#123;% endif %&#125; &lt;/div&gt; &lt;/header&gt;&#123;% endif %&#125; 修改layout.swig文件 在NexT根目录的layout路径下，打开 _layout.swig文件，在&lt;/body&gt;上方添加如下内容： 123&#123;% if theme.leancloud_visitors.enable %&#125; &#123;% include '_scripts/lean-analytics.swig' %&#125; &#123;% endif %&#125; 添加完成之后，文件内容像这个样子： 123456789101112131415&#123;# LazyLoad #&#125; &lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/lazyload.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#posts").find('img').lazyload(&#123; placeholder: "&#123;&#123; url_for(theme.images) &#125;&#125;/loading.gif", effect: "fadeIn" &#125;); &#125;); &lt;/script&gt; &#123;% if theme.leancloud_visitors.enable %&#125; &#123;% include '_scripts/lean-analytics.swig' %&#125; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 修改zh-Hans.yml文件 在NexT目录的languages路径下的zh-Hans.yml文件，在post:结点下添加visitors: 阅读次数，像这个样子： 12345678post: posted: 发表于 visitors: 阅读次数 updated: 更新于 in: 分类于 read_more: 阅读全文 untitled: 未命名 toc_empty: 此文章未包含目录 配置LeanCloud注册账号（如果没有）https://leancloud.cn/dashboard/login.html#/signup 创建应用 我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开应用，点击创建新应用，如下图所示： 在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的: 创建完成之后,点击新创建的应用进入页面，创建Class来新建Class用来专门保存我们博客的文章访问量等数据 点击创建Class之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为”Counter”： 由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。 创建完成之后，我们点击设置，选择应用Key选项，复制AppID以及AppKey，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了: 在NexT主题的_config.yml文件中我们相应的位置填入即可 1234leancloud_visitors: enable: true app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz app_key: E9UJsJpw1omCHuS22PdSpKoh 后台管理当你配置部分完成之后，初始的文章统计量显示为0，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的Counter表中。我们可以修改其中的time字段的数值来达到修改某一篇文章的访问量的目的（博客文章访问量快递提升人气的装逼利器）。双击具体的数值，修改之后回车即可保存。 url字段被当作唯一ID来使用，因此如果你不知道带来的后果的话请不要修改。 title字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。 其他字段皆为自动生成，具体作用请查阅LeanCloud官方文档，如果你不知道有什么作用请不要随意修改。 Web安全因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。 选择设置的安全中心选项卡 在Web 安全域名中填入我们自己的博客域名，来确保数据调用的安全: 如果你不知道怎么填写安全域名而或者填写完成之后发现博客文章访问量显示不正常，打开浏览器调试模式，报错，可能你的安全域名填写错误，导致服务器拒绝了数据交互的请求。]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写博客]]></title>
    <url>%2F2017%2F10%2F26%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项 很多命令可以用Windows的cmd来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导 hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的 安装1npm install -g hexo-cli 初始化新建文件夹，进入后运行git Bash 1234hexo init//初始化npm install//安装组件hexo g//生成静态页面hexo server//启动服务 初始化后生成的文件和文件夹，及其作用 文件及文件夹 作用 node_modules 是依赖包 public 存放的是生成的页面 scaffolds 命令生成文章等的模板 source 用命令创建的各种文章 themes 主题 _config.yml 整个博客的配置 db.json source解析所得到的 package.json 项目所需模块项目的配置信息 默认端口：4000本地预览：http://localhost:4000 生成public文件夹，将来都是要提交到github去的 修改主题 1、进入文件夹中themes文件夹，运行git Bash 2、$ git clone 主题github地址——下载主题 如下 1git clone https://github.com/henryhuang/hexo-theme-aloha 3、修改_config.yml中的theme:xxxx属性为theme: 主题文件夹名， 4、$ hexo g——重新生成。 如果出现一些莫名其妙的问题，可以先执行$ hexo clean来清理一下public的内容，然后再来重新生成和发布。 常用hexo命令常用命令 1234567hexo new "postName" //新建文章hexo new page "pageName" //新建页面hexo generate //生成静态页面至public目录hexo server //开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy //部署到GitHubhexo help //查看帮助hexo version //查看Hexo的版本 命令缩写 1234hexo n == $ hexo newhexo g == $ hexo generatehexo s == $ hexo serverhexo d == $ hexo deploy 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.ymlSite网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词 author参数用于主题显示文章的作者。 URL网址 参数 描述 url 网址 root 网站根目录 permalink 文章的永久链接格式:year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的url设为 http://yoursite.com/blog并把root设为 /blog/。 Directory目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 Writing文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 Category &amp; Tag分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 Date / Time format日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss Pagination分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page xtensions扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 写博客新建文章在根目录下执行$ hexo new &quot;postName&quot; 会在_posts下生成相关md文件，打开写博客. 默认生成格式如下 12345---title: HTML基础date: 2017-10-25 14:53:48tags:--- 完整格式如下 12345678---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 new page &#39;postName&#39;和new &#39;postName&#39;区别$ hexo new page &#39;postName&#39;最终部署时生成hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 md文件中插入图片 1、 把主页配置文件_config.yml里的post_asset_folder:这个选项设置为true 2、npm install hexo-asset-image --save 3、等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4、最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx/图片名.jpg) xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，在合适的位置加上&lt;!--more--&gt;可以控制文章摘要长度]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人博客]]></title>
    <url>%2F2017%2F10%2F26%2F%E4%BD%BF%E7%94%A8hexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[git+nodejs+hexo 程序准备安装Gitwindow系统对应下载地址：http://gitscm.com 安装NodeJsnode版本12.16.2，高版本不兼容 安装hexo全局下安装hexo 1npm install -g hexo-cli 搭建github博客新建仓库存储库命名规范：gitHub的用户名.github.io仓库域名：gitHub的用户名.github.io 必须按照这个规则创建 每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库 注册的邮箱一定要验证，否则不会成功 生效可能需要一定时间 具体过程看文章《git》 绑定域名（可不绑） 1、有一个自己的域名，并进行配置 2、回到github项目根目录新建一个名为CNAME的文件（无后缀），填写绑定的域名 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me 配置SSH Key提交代码要拥有github权限才可以，而直接使用用户名和密码不安全，所以使用ssh key来解决本地和服务器的连接问题。 1、$ cd ~/.ssh——检查本机已存在的ssh密钥 如果提示：No such file or directory 说明本机还没有ssh密钥存在。 2、$ ssh-keygen -t rsa -C &quot;github帐号绑定邮箱&quot;——创建ssh，过程中回车3次 最终会在C:\Users里当前计算机用户下生成.ssh文件夹 3、打开C:\Users\当前计算机用户名\.ssh\id_rsa.pub文件，并复制内容 4、在github用户设置的SSH and GPC keys中，点击New SSH key按钮，将复制的内容粘贴到key输入框中，title随便，保存 5、检测是否成功$ ssh -T git@github.com，命令中的邮箱不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后出现Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.，则SSH配置成功 6、如果以前没有设置git全局下的用户名和邮箱，还需要 12git config --global user.name "git用户名"git config --global user.email "git注册邮箱" 使用hexoHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。官网： http://hexo.iogithub: https://github.com/hexojs/hexo 注意事项 很多命令可以用Windows的cmd来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导 hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的 安装1npm install -g hexo-cli 初始化新建文件夹，进入后运行git Bash 1234hexo init//初始化npm install//安装组件hexo g//生成静态页面hexo server//启动服务 默认端口：4000本地预览：http://localhost:4000生成public文件夹，将来都是要提交到github去的 详细使用hexo见本博客文章《使用hexo写博客》 上传github上传之前注意：在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 保留CNAME、README.md等文件 一些非md文件需要上传github的，可以把他们放到source文件夹下，source文件夹下的所有文件都会原样复制（除了md文件）到public目录的 上传到github 1、配置_config.yml中有关deploy的部分 正确写法 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master hexo2.x写法（已不能用） 1234deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 2、安装插件 1npm install hexo-deployer-git --save 3、在主文件夹下执行$ hexo d 通过github备份Hexo博客源文件 初次备份 在Github线上创建仓库(与本地站点文件夹同名即可) 之后步骤请见本博客《git》中”提交文件到自己的远程仓库”章节 之后更新备份，见本博客《git》]]></content>
      <categories>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专业名词]]></title>
    <url>%2F2017%2F10%2F08%2F%E4%B8%93%E4%B8%9A%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[专业名词解释 计算机基本工作原理 CPU+RAM（内存）+各种资源（显卡，光驱，键盘，GPS等外设）构成计算机 计算机运行过程（冯诺依曼体系结构）：先把要执行的程序和处理的数据先存入主存储器（内存），执行程序时将自动并按顺序的从主存储器中取出指令一条一条执行——存储程序，顺序执行程序 冯诺依曼体系结构 核心：存储程序，顺序执行 指令和数据混合存储在同一个存储器中，不加区别，都是作为内存中的数据。 EIP指针指向哪，CPU就加载那段内存中的数据 指令格式不正确，CPU会发生错误中断 在CPU保护模式中，每个内存段都有其描述，记录着这个内存段的访问权限（读、写、执行）。变相区分了内存中的数据是指令还是数据 指令和数据都能送到运算器（CPU的组成部分）中运算，由指令组成的程序是可以修改的 通过执行指令直接发出控制信号控制计算机的操作，指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在单元地址。指令计数器只有一个，一般按顺序递增，但执行顺序可按运算结果或但是外界条件而改变。 以运算器为中心，I/O设备（I：input输入；O：output输出）与存储器之间的数据传送都要经过运算器 计算机处理的数据和指令一律用二进制数表示 顺序执行程序 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成 寄存器寄存器是CPU 的组成部分，所以CPU对其读写速度最快，不需要I/O传输，用于暂时存储指令、数据和地址。32位通用寄存器如下 eax：累加和结果寄存器 ebx：数据指针寄存器 ecx：循环计数器 edx：I/O指针 esi：源地址寄存器 edi：目的地址寄存器 esp：堆栈指针 ebp：栈指针寄存器 堆栈堆栈都是一种数据按序排列的数据结构 堆 堆空间分配（操作系统 ）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表 堆缓存方式：存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以嗲用这些对象的速度要相对来得低一些 堆数据结构：堆可以被看成一棵树时，如堆排序 栈 栈空间分配（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。操作方式类似于数据结构中的栈 栈缓存方式：一级缓存，通常被调用时处于存储空间中，调用完毕立即释放，存取速度比堆快 栈数据结构：一种先进后出的数据结构 进程和线程 进程和线程都是一个CPU工作时间段的描述 进程是线程的容器 进程（包括上下文切换的程序执行时间总和）= CPU加载上下文+CPU执行+CPU保存上下文（上下文：除了CPU以外的所有构成程序的执行环境，即程序上下文） 线程是共享了进程上下文环境的，更小CPU工作时间段 并发 在操作系统的一个时间段中，有几个程序同时处于启动运行到运行完毕之间的状态，且这几个程序都在同一个处理机上运行。 并发又有伪并发和真并发 伪并发：单核处理器的并发（在单核处理器的多道程序环境中，进程被顺序执行，时间片短，表现出一种并发的外部特征） 真并发：多核处理器的并发 并发进程之间的制约关系：互斥和同步 并行 并行：在多核处理器的多道程序环境中，进程重叠执行，即同一时刻发生多个事件 在多核处理器上，程序才能实现并行处理 并发不一定并行，即并发事件不一定要同一时刻发生 互斥(并发进程间的间接制约关系)多个并发进程之间，因竞争使用临界资源而互相排斥执行的间接制约关系 例1：互斥使用资源 例2：共享变量 12345678910111213//进程P1R1=count;R1=R1+1;count=R1;//进程P2R2=count;R2=R2+1;count=R2;//R1、R2是处理机的两个通用寄存器，可以按各自独立的速度前进，所以运行顺序可能如下R1=count；R2=count;R1=R1+1;count=R1;R2=R2+1;count=R2; 同步(并发进程间的直接制约关系)在某些地方，多个并发进程需要相互等待或交换信息而产生的直接制约关系。 并发进程之间不是相互排斥临界资源，而是相互依赖的关系。同步关系就是前一个进程的输出作为后一个进程的输入；当第一个进程没有输出时，第二个进程必须等待。 具有同步关系的一组并发进程，相互发送的消息称为消息或事件 例1 例2：协作进程，用户作业程序的形式：Z=func1(x)*func2(y)，func1(x)和func2(y)均是一个复杂函数，为加速计算，采用以下方法 进程P1、P2分别计算func1(x)和func2(y) 进程P1与P2计算结果相乘，获得结果Z 异步 异步与同步是相对的 异步是进程之间彼此独立，在等待其他进程的运行时，本进程继续做自己的事，不需要等待其他进程完成后再工作 异步和多线程不是同等关系 实现异步的方式可以是多线程或者交给另外的进程处理 多线程较容易写，容易实现异步切换的思想 多线程本身还是以同步完成，但比不上异步的效率 单核和多核的不同 多核：可以同时做事情 单核：在都是独占CPU的作业中，多线程和单线程没有区别 形象举例 烧开水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟） 举杠铃100下：举杠铃100下（10分钟） 洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟） 单核处理器—同步 事情步骤：烧水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟）；举杠铃100下：举杠铃100下（10分钟）；洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟） 总时间t = 1+ 8 +1 + 10 + 1+ 5 +1 = 27（分钟） 单核处理器—异步 事情步骤：准备烧开水(1分钟) + 准备洗衣服(1分钟) + 举50下杠铃 (5分钟)+ 关洗衣机（1分钟） + 举杠铃20下（2分钟）+ 关烧水机（1分钟） + 举30下杠铃(3分钟） 总时间t = 1 + 1 + 5 + 1 + 2 + 1 + 3 = 14（分钟） 双核处理器—异步并行 事情步骤： 核1：准备烧开水（1分钟）+ 举杠铃50下（5分钟）+ 等待（3分钟）+ 关掉烧水机 （1分钟） 核2：准备洗衣服（1分钟）+ 举杠铃50下（5分钟）+ 关掉洗衣机（1分钟） + 等待（3分钟） 总时间t = 1 + 5 + 3 + 1 = 10（分钟），其中双核都等待了3分钟。 双核处理器—异步非并行 事情步骤： 核1：举杠铃100下（10分钟） 核2：准备烧开水（1分钟）+ 准备洗衣服（1分钟）+ 等待（6分钟）+ 关掉烧水机（1分钟）+ 关掉洗衣机（1分钟） 总时间t =1 + 1 + 6 + 1 + 1 = 10（分钟） 单核处理器—多线程 事情步骤： 线程1：准备烧开水（1分钟）， 等水烧开（8分钟） , 关掉烧水机（1分钟） 线程2：举杠铃100下（10分钟） 线程3：准备洗衣服（1分钟）， 等水烧开（5 分钟） , 关掉洗衣机（1分钟） CPU最理想的切换方式： 线程1：准备烧开水（1分钟）+ sleep 1 + sleep 5 + sleep 1 + sleep 2 + 关开水（1分钟） 线程2：sleep 1+ sleep 1 + 举杠铃50（5分钟）+ sleep 1 + 举杠铃20（2分钟）+ sleep1 + 举杠铃30下（3分钟） 线程3：sleep 1 + 准备洗衣服（1分钟）+ sleep 5 +关洗衣机（1分钟） 总时间：最后使用了14分钟，与异步是一样的。但实际上是不一样的，因为线程不会按照我们设想的去跑。如果线程2举杠铃先跑，整个流程的速度就下来了。 I/O Input(输入) 从文件系统中读取文件 Output(输出) 向文件系统写入文件 事件循环]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>专业名词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ejs]]></title>
    <url>%2F2017%2F03%2F27%2Fejs%2F</url>
    <content type="text"><![CDATA[制作esj渲染的模板，在原有的HTML结果基础上把我们的数据嵌套进来 1、制作esj渲染模板 js代码(流程控制标签)：&lt;%js代码%&gt; 需要输出的内容： &lt;%=变量%&gt;（原文输出HTML标签） &lt;%- %&gt;（HTML会被浏览器解析） 注释标签: &lt;%# %&gt; 对标记进行转义: % 去掉没用的空格: -%&gt; ejs中的逻辑代码全部用JavaScript 12345678910&lt;script type="text/template" id="conTemplate"&gt; &lt;%$.each(dataNum,function(index,item)&#123;%&gt; &lt;li&gt; &lt;span&gt;&lt;%=item.id%&gt;&lt;/span&gt; &lt;span&gt;&lt;%=item.name%&gt;&lt;/span&gt; &lt;span&gt;&lt;%=item.sex===1?"女":"男"%&gt;&lt;/span&gt; &lt;span&gt;&lt;%=item.score%&gt;&lt;/span&gt; &lt;/li&gt; &lt;%&#125;)%&gt;&lt;/script&gt; 2、嵌套数据123456789101112131415161718&lt;script type="text/javascript" src="ejs.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="zepto.min.js"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url : "data.json", type: "get", dataType : "json", success : function(data)&#123; // 把模板字符串获取到 var template = $("#conTemplate").html(); //使用ejs 中的render方法，向指定的模板中提供的需要的数据，ejs会把模板和字符串按照既定的规则进行解析和渲染，最后得到的数据和html结构拼在一起的字符串 var result = ejs.render(template,&#123;dataNum:data&#125;) // 把拼接好的字符串数据放在页面的容器中$(".content&gt;ul").html(result); &#125; &#125;)&lt;/script&gt; 1、获取ejs模板——curEle.innerHTML 2、使用ejs的render方法将数据和模板结构结合拼得到拼接后的字符串——ejs.render(模板字符串,数据) 3、将拼接后的字符串放入页面元素容器中——容器元素.innerHTml=拼接后的字符串]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactJS要点]]></title>
    <url>%2F2017%2F01%2F16%2FReactJS%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[react 主要用法，入门 安装$ bower install react babel --save 直接在浏览器中使用React1234&lt;script src="../bower_components/react/react.js"&gt;&lt;/script&gt; &lt;script src="../bower_components/react/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../bower_components/babel/browser.js"&gt;&lt;/script&gt; &lt;script type="text/babel" src="index.js"&gt;&lt;/script&gt; react.js是 React 的核心库 react-dom.js是提供与DOM相关的功能,会在window下增加ReactDOM属性 browser.js的作用是将JSX语法转为JavaScript语法 &lt;script&gt;中的type属性为text/babel,因为React独有的JSX语法,跟JavaScript不兼容 ReactDOM.renderReactDOM.render是React的最基本方法,用于将标签模板转为HTML语言，并插入指定的DOM节点 1234ReactDOM.render( &lt;h1&gt;hello&lt;/h1&gt;, document.getElementById('app')); jsx语法 javascript+xml(html)：这是一种可以让html和js混合书写的一种语法 react对JS作了扩展，react使用的自己的扩展的jsx语法 React元素jsx中的html标签不是简单的HTML.React元素 React元素是构建React应用的基本最小单位 每一个html标签都是一个React元素 React元素描述了界面的显示的样子 React元素并不是真实的DOM元素 &lt;h1&gt;hello&lt;/h1&gt;实际上是{type:&#39;h1&#39;,children:&#39;hello&#39;} 语法 在JS中可以直接写html代码。凡是&lt;开头的就是HTML代码 在HTML中可以显示JS变量，但是需要用{}包裹起来,花括号里其实放的是JS的表达式，JS表达一定需要有返回值 给React元素添加属性的方式就是在开始标签上加key/value值 React元素和HTMl标签使用上的一些差异 如果给元素增加类名，不能使用class，需要使用className 给元素增加行内样式，style需要等于一个对象 如果=&gt;后面是花括号，里面需要用return返回，如果小括号，则不需要用return 12345678ReactDOM.render(&lt;ul&gt; &#123;names.map((item, index) =&gt; ( &lt;li style=&#123;style&#125; className=&#123;"b" + "g"&#125; key=&#123;index&#125;&gt; &#123;item&#125; &lt;/li&gt; ) )&#125;&lt;/ul&gt;, document.querySelector('#root')); 组件什么是组件：组成页面的部件，每个组件包含自己的逻辑和样式，再将这些独立组件组合完成一个复杂的页面。 可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部 可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 组件和元素的区别和联系是什么? 组件名字必须是以大写字母开头，是为了区分React元素和组件 组件内有render方法，返回一个顶级React元素 组件的用法和React元素基本一样 如何定义组件？ 1234567891011class Hello extends React.Component&#123; //1. render方法用来指定此组件长什么样子 //2. render方法必须返回一个且只能返回一个顶级React元素 render()&#123; return &lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/div&gt; &#125;&#125;//1. 实例化Hello类的实例let hello = new Hello();//2. 调用实例上的render方法let ele = hello.render(); ele=div//3. 把个ele转成真实的DOM元素并且插入到页面中去ReactDOM.render(&lt;Hello/&gt;,document.querySelector('#root')); 组件的属性组件的属性：那些从外界传进来，组件内部只能读，不能改的数据]]></content>
      <categories>
        <category>JavaScript</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础要点]]></title>
    <url>%2F2017%2F01%2F09%2Fvue%E5%9F%BA%E7%A1%80%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[声明式渲染 组件化开发 客户端路由(vue-router) 大规模的数据状态（vuex） 构建工具（vue-cli） 全家桶系列：vue.js+vue-router+vuex+vue-cli+axios ，完整的构成了大型项目开发 vue兼容性 &lt;=ie8不支持 Vue核心知识点 组件化开发 数据变化-&gt;视图自动更新 -&gt;框架的架构模式MVVM双向数据绑定 (angular、react、vue) model 模型（数据） view 视图 viewModel 视图模式 MVVM 双向数据绑定 只有表单元素才能实现双向数据绑定 vue通过数据劫持实现数据绑定，通过Object.defineProperty()的get和set方法监听数据变化，当数据变化时执行监听的回调函数 1234567891011121314let obj = &#123;&#125;;let input = document.getElementById("input");//视图Object.defineProperty(obj,"name",&#123; // value:"lily",// 不能与get和set同时存在 // writable:false, //是否可修改，不能与get和set同时存在 configurable:false,//是否可删除 enumerable:false, //是否可枚举 可以可以通过for..in....遍历出来 get()&#123; //第一次浏览器一加载就执行，后期name属性发生变化时会重新获取 return input.value// input框的值改变时get函数触发同时改变obj.name &#125;, set(val)&#123; //设置属性值时会调用set,val就是设置的这个属性值 input.value = val;// obj.name改变时同时改变input框的值 &#125;&#125;); vue中ary[0]=&#39;aa&#39;操作数组本身不起作用，用push,pop,shift,unshift,reverse,sort,splice改变素组才能起作用 属性文本&#123;&#123;&#125;&#125;最常用的：&#123;&#123;msg&#125;&#125;——Mustache语法&#123;&#123;msg==”word”?”ok”:”no”&#125;&#125;——放置三元运算符 表达式或者函数，显示的是执行的返回结果，函数必须加()； &#123;&#123;sum()&#125;&#125;非常的暴力 任何数据变化都会导致sum重新执行 v-text&#123;&#123;&#125;&#125;是v-text的简写区别：属性默认不会显示在html上，当编译好后会自动插入到div中，&#123;&#123;&#125;&#125;直接显示在html上 v-model会将值赋予给输入框，当输入框值发生变化的时候，将值在赋予给变量。 是input标签的行间属性，能实现双向数据绑定的 v-once无属性值，表示只绑定一次，避免重复绑定 v-cloakcloak闪烁 防止闪烁配合css样式使用 123&lt;style&gt; [v-cloak]&#123;display: none;&#125;//属性选择器&lt;/style&gt; v-forv-for——要循环谁 就写在谁的身上属性值语法：value in 数组/(item,index) in 数组 12345&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(item,index) in arrs"&gt;&#123;&#123;item&#125;&#125; &#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 事件v-on用于为特点事件绑定methods中的方法v-on:click=&quot;a()&quot;可以写为@click=&quot;a&quot;等同于onclick=&quot;vm.a()&quot; @+事件@keyup、@keydown 如果需要传递参数需要加()，如果不需要则不加，否则需要自己传入event对象——event前要加$ 在原生js中必需要增加() 1&lt;button @click="a($event)"&gt;点我说我帅&lt;/button&gt; 绑定修饰符事件 多次绑定修饰符事件——@click.stop.prevent=&quot;a&quot; 1&lt;input type="text" v-model="fruit" @keyup.13="a"&gt; 修饰符 描述 .stop 阻止冒泡 .capture 捕获 先捕获在冒泡 .self 绑定事件 可以只绑定给自己 .prevent 阻止默认行为 .65 键盘事件键码值(keyCode) 动态属性绑定动态属性：:属性名=&quot;值&quot;:属性名=&quot;a&quot;——a为控制变量style 和class绑定动态属性的值： 一种是数组、一种是对象 class绑定动态属性 写到数组中都会生效，如果不加引号为控制变量，加单引号则是字符串 12&lt;div :class="[x,y,'b']"&gt;我很帅&lt;/div&gt;//x、y为控制变量，都起效，'b'为b字符串 对象中，属性名为值，属性值可以为控制变量、判断条件、true/false，0/1，都能转为boolean类型数据，true为起效，false为不起效 1&lt;div :class="&#123;a:font,b:back&#125;" class="c"&gt;vue&lt;/div&gt; 动态绑定class：动态绑定的class和以前的不产生任何冲突 style绑定动态属性属性值为对象——对象中属性名要转换为驼峰命名法，如background-color转backgroundColor对象 1&lt;div :style="&#123;backgroundColor: 'red',color:'yellow'&#125;"&gt;红的&lt;/div&gt; 数组 1&lt;div :style="[&#123;backgroundColor: 'red'&#125;,&#123;color:'yellow'&#125;]"&gt;红的&lt;/div&gt; 计算属性计算属性：&#123;&#123;sum&#125;&#125;，不能写成&#123;&#123;sum()&#125;&#125;监视涉及的数据的变化，计算出的新值。其他未涉及的数据变化，不会引起重新计算 validatev-showv-show=&quot;a&quot;——a为控制变量，转化boolean类型值，true显示，false隐藏 v-show 适合频繁切换dom元素的显示和隐藏 if使dom元素 删除或者增加 JS代码new Vue——根组件vm是vue的实例，也就是viewModel new Vue参数中的所有函数的this基本指向当前实例 new Vue参数中一般不放置箭头函数，因为我们希望this是当前实例 可以创建多个实例，但是根本不需要。 vue-devtools可以帮我们调试vue代码。 12345678910let vm=new Vue(&#123; el:'#app', data:&#123; msg:'hello word' &#125;, methods:&#123;&#125;, computed:&#123;&#125;, watch:&#123;&#125;, directives&#123;&#125;&#125;) el——设置根元素（挂载点）el：querySelector手动挂载：let vm=new Vue({...}).$mount(&#39;#app&#39;); 必须设置el或者手动挂载 template——设置根元素template:&#39;&lt;div&gt;我很帅&lt;/div&gt;&#39; 组件模板中只能有一个根元素，也必须要有一个根元素，el和template同时存在时，只有template起效，但必须设置el或者手动挂载 datadata：会被vm代理，比如console.log(vm.msg)//&#39;hello word&#39; data对象， 采用Object.defineProperty，set，get+发布订阅模式，可以实现监控数据的变化，不兼容IE8及以下版本 添加数据时，要包含所有操作控制所需要的属性，不论是否需要 视图能改变才能双向数据绑定，行间属性 v-model实现双向数据绑定的，能改变 input(text checkbox radio ) 类型 textarea,select 也能获取其值 12345&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(item,index) in arrs"&gt;&#123;&#123;item&#125;&#125;&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456let vm = new Vue(&#123; el:'#app', data:&#123; arrs:[1,2,3]; &#125;&#125;); 不能直接更改数组里的某一项（即vm.arrs[1]=3数组改变而视图不改变） 可以用新数组覆盖掉老数组 可以使用$set来强制改变，vm.$set(arr,1,3); methods（自定义的方法）methods一般放置的是函数，一般不放置箭头函数，因为我们希望this是当前实例。 computed（计算属性）计算属性，虽然叫属性 要写成函数格式，只能写同步的方法 监视涉及的数据的变化，计算出的新值。其他未涉及的数据变化，不会引起重新计算 get方法：是根据其他人的值计算出自己的值 set方法：给自己设置值时影响其他人的值 两种形式 1234567891011computed: &#123; sum()&#123; //sum其实是属性，只写一个是get方法&#125;, a:&#123; get()&#123; //当获取a的时候执行 ,当获取a值时 可以计算值赋予a console.log('get'); &#125;, set(val)&#123;//当给a设置值的时候执行,val代表要设置的值，当给a设置时执行，可以影响其他值 console.log('set'); &#125; &#125;&#125; watch 观察当值变化了就可以触发自己的函数，可以写异步的方法 默认只监控一层。子数据中的数据发生变化时不会触发watch的 深度监控—— deep: true;，子数据中的数据变化也会被监控到 123456789101112data:&#123;heart:'开心'&#125;,watch:&#123;//观察heart的变量 只要变量放生变化 就会执行，两种语法格式 heart()&#123; setTimeout(()=&gt;&#123; &#125;,2000) &#125; heart:&#123; handler()&#123; setTimeout(()=&gt;&#123; &#125;,2000); &#125; &#125; deep: true;//对象中数据变化也会被监控到&#125; directives指令，用来添加一些功能，或者可以操作dom元素自定义指令，使用时v-指令名，directives中指令名要用驼峰命名法 123456789//自定义指令 如果当前指令的值 是true 就让这个输入框获取焦点&lt;input type="text" v-model="item.title" v-auto-focus="item==c" @blur="reset" @keyup.13="reset"&gt;directives:&#123; //驼峰命名法 autoFocus(el,bindings)&#123; //el代表当前输入框，bindings是对象 value属性如果是true则获取焦点 if(bindings.value) el.focus(); &#125;&#125; 生命周期（lifyCycle） beforeCreate(data methods都不存在)、created ajax请求 beforeMount、mounted beforeUpdate、updated beforeDestroy、destroyed 12345678910111213141516171819202122232425262728let vm = new Vue(&#123; data:&#123;a:1&#125;, beforeCreate()&#123; //创建之前，用不到 alert('创建前') &#125;, created()&#123; //创建完成，只要是获取数据 都在created中获取，已经完成了数据和事件的绑定，可以调用ajax alert('创建完成') &#125;, beforeMount()&#123;//用不到 alert('挂载前') &#125;, mounted()&#123; //已经插入到div中，在这里可以获取真实dom元素 alert('挂载完成') &#125;, beforeUpdate()&#123; //只有页面更改时 才会触发update方法 alert('开始更新前') &#125;, updated()&#123; alert('更新后') &#125;, beforeDestroy()&#123; //结束定时器 或者 移除监听 alert('销毁前') &#125;, destroyed()&#123; //会自动移除所有监听 alert('销毁后') &#125;&#125;).$mount('#app');//手动挂载vm.$destroy();//手动调用销毁，要加$符 组件多个小组件组成完整的页面，提高复用性 命名规范：不能使用已经存在的标签命名组件 当使用 DOM 作为模版时 (例如，将 el 选项挂载到一个已存在的元素上)，这些元素&lt;ul&gt;，&lt;ol&gt;，&lt;table&gt;，&lt;select&gt; 限制了能被它包裹的元素，这类元素使用的组件的根元素被规定，而一些像 &lt;option&gt; 这样的元素只能出现在某些其它元素内部。 组件类型根组件new Vue1let vm=new Vue(&#123;&#125;) 全局组件Vue.component()注册全局组件 适合在任意地方使用，用它可以写公用的插件 定义特殊的HTML，赋予标签一些特殊的含义——Vue.component() Vue.component(str1,{...}) 12345678Vue.component('hello',&#123; template:'&lt;div&gt;...&lt;/div&gt;', data()&#123; return &#123;...&#125; &#125;, methods:&#123;&#125;, created:&#123;&#125;&#125;) 局部组件components注册局部组件注册在里面的就叫局部组件，局部组件只能在相邻的父级的模板中使用局部组件只能在某一个组件下使用，注册的时候，要注册在那个组件下面写法一 组件使用三部分： 引用 注册这个组件 通过标签引用 1234567891011121314151617let vm = new Vue(&#123; el: '#app', template: '&lt;div&gt;&lt;hello&gt;&lt;/hello&gt;&lt;my&gt;&lt;/my&gt;&lt;/div&gt;', components: &#123; 'hello': &#123;//局部组件，只能用于父级 template: '&lt;h1&gt;你好&lt;hello-child&gt;&lt;/hello-child&gt;&lt;/h1', components: &#123; 'hello-child': &#123;//局部组件，只能用于&lt;hello&gt;中 template: '&lt;h2&gt;我好&lt;/h2&gt;' &#125; &#125; &#125;, 'my': &#123;//局部组件，只能用于父级 template: '&lt;h1&gt;我&lt;/h1&gt;', &#125; &#125;&#125;) 写法二 组件使用三部分： 引用：将要注册的对象提到外部声明定义为变量 注册：用变量代替注册的对象，组件名和变量一致时，可以简写 在父级模板中以标签形式引用 123456789101112//变量必须使用驼峰命名法，标签不需要&lt;helloChild&gt;或&lt;hello-child&gt;都能识别，都代表helloChild对象定义的标签let helloChild = &#123;template: '&lt;h2&gt;我好&lt;/h2&gt;'&#125;;let hello = &#123; template: '&lt;h1&gt;你好&lt;hello-child&gt;&lt;/hello-child&gt;&lt;/h1&gt;', components: &#123;helloChild&#125;//定义子组件，如果&lt;my&gt;放入，也能使用&#125;;let my = &#123;template: '&lt;h1&gt;我&lt;/h1&gt;'&#125;;let vm = new Vue(&#123; el: '#app', template: '&lt;div&gt;&lt;hello&gt;&lt;/hello&gt;&lt;omy&gt;&lt;/omy&gt;&lt;/div&gt;', components: &#123;hello, 'omy':my&#125;//定义子组件，如果&lt;helloChild&gt;放入，也能使用&#125;); 变量必须使用驼峰命名法，标签不需要&lt;helloChild&gt;或&lt;hello-child&gt;都能识别，表示同一个组件 组件中属性templateVue.component(str1,{template:str2})html页面中的&lt;str1&gt;便签会被template的属性值str2替换 要有唯一的根元素，template中的元素必须有唯一的根元素 1234Vue.component('hello',&#123; template:'&lt;h1&gt;我爱你&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;' //html页面中的&lt;hello&gt;便签会被template的属性值替换&#125;) data组件中的data都是函数，返回的是对象，用于形成闭包，保证组建的独立性，返回的对象就是当前组件的数据。 如果data用对象的话就不能保证组建的独立性。因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象 123456Vue.component('hello',&#123; template:'&lt;h1&gt;我爱你&lt;span&gt;&#123;&#123;a&#125;&#125;&lt;/span&gt;&lt;/h1&gt;',//a控制变量 data()&#123; return&#123;a:'aaaa'&#125; &#125;&#125;) components注册子组件 直接在内部注册某个对象为局部组件 12345678910components: &#123; 'hello': &#123; template: '&lt;h1&gt;你好&lt;hello-child&gt;&lt;/hello-child&gt;&lt;/h1', components: &#123; 'hello-child': &#123; template: '&lt;h2&gt;我好&lt;/h2&gt;' &#125; &#125; &#125;&#125; 注册某个变量为组件 123456let helloChild = &#123;template: '&lt;h2&gt;我好&lt;/h2&gt;'&#125;;let hello = &#123; template: '&lt;h1&gt;你好&lt;hello-child&gt;&lt;/hello-child&gt;&lt;/h1&gt;', components: &#123;helloChild&#125; //定义过后，&lt;helloChild&gt;就能在&lt;hello&gt;中使用&#125; 变量必须使用驼峰命名法，标签不需要&lt;helloChild&gt;或&lt;hello-child&gt;都能识别，表示同一个组件 props接收父组件传递过来的数据，默认会把当前数据挂载在当前实例 this.m 在子组件中不能直接使用父组件的数据 值： 数组：不能校验传递内容，各项为字符串 对象：能校验传递内容 接收父组件传递的值 如果是变量、数字和boolean类型的值，需要父组件通过绑定动态属性传递，子组件通过props属性接收 1234567891011let hate = &#123; template:'&lt;h1&gt;&#123;&#123;m&#125;&#125; &#123;&#123;a&#125;&#125;&lt;/h1&gt;', props:['b',m','a'],//数组形式，不能校验传递内容&#125;;let vm = new Vue(&#123; data:&#123;msg:'我爱你'&#125;, template:`&lt;div&gt; &lt;hate b="我爱你" :m="msg" :a="1"&gt;&lt;/hate&gt; &lt;/div&gt;`, //通过m属性传递msg给子组件,传递的是变量代表的值，所以通过冒号传递 components:&#123;hate&#125;&#125;).$mount('#app');//手动挂载 验证传递内容props:{}props:{}中的属性会挂载在组件的实例上，能被this.属性名获取|键值对|作用||:–:|:–:||{required:true}或{}|是否传递了此属性||{default:&#39;xxx&#39;}|如果没有传递属性使用默认值||{type:[String,Number,Object]}|验证数字类型，数组是或的关系||{validator(val){}}|如果此函数返回true 表示通过校验，反之false，val代表当前传递过来的内容| 通过冒号传递的数字才是数字类型 123456789props:&#123; msg:&#123; /*@param val 代表当前传递过来的参数*/ validator(val) &#123; return val==='我爱你'; &#125; &#125;, flag:&#123;type:Boolean&#125;&#125; 组件间数据修改发布订阅模式$on、$emit 不能直接更改其他组件的数据，只能改自己的 child修改parent的数据 普通方法 123456789101112131415161718192021let App = &#123; template:'&lt;div&gt;&lt;button @click="change"&gt;点我啊&lt;/button&gt;&lt;/div&gt;', props:['m'], methods:&#123; change()&#123;//发布 消息给父亲 this.$emit('child-msg','我喜欢你'); &#125; &#125;&#125;;let vm = new Vue(&#123; el:'#app', data:&#123;msg:'我爱你'&#125;, // 父亲绑定一个自定义事件来监听儿子的动作this.$on('child-msg',fn)，当儿子发射事件后，执行此fn函数 template:'&lt;div&gt;&lt;App :m="msg" @child-msg="fn"/&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', methods:&#123; fn(msg)&#123; this.msg = msg; &#125; &#125;, components:&#123; App &#125;&#125;); vue方法 123456789101112131415161718let App = &#123; template:`&lt;div&gt;&#123;&#123;m&#125;&#125; &lt;button @click="change"&gt;点我啊&lt;/button&gt; &lt;/div&gt;`, props:['m'], methods:&#123; change()&#123; this.$emit('update:m','我喜欢你');//update:更改变量 &#125; &#125;&#125;;let vm = new Vue(&#123; el:'#app', data:&#123;msg:'我爱你'&#125;, // .sync相当于同步子组件传递过来的数据 template:'&lt;div&gt;&lt;App :m.sync="msg"/&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', components:&#123; App &#125;&#125;); 同级组件间修改siblings构建一个实例 通过同一个实例发射事件和监听事件缺点：一呼百应，非常冗余复杂，交互困难 123456789101112131415161718192021222324252627282930313233343536&lt;template id="A"&gt; &lt;div&gt;&#123;&#123;a1&#125;&#125; &lt;button&gt;发送Bpp&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id="B"&gt; &lt;div&gt; &#123;&#123;b1&#125;&#125; &lt;button @click="send"&gt;发送App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;let ab=new Vue();let App = &#123; template: `#A`, data() &#123; return &#123;a1: "a"&#125; &#125;, created()&#123; ab.$on("A",(val)=&gt;this.a1=val) &#125;&#125;;let Bpp = &#123; template: `#B`, data() &#123; return &#123;b1: "b"&#125; &#125;, methods:&#123; send()&#123; ab.$emit("A","A") &#125; &#125;&#125;;let vm = new Vue(&#123; el: '#app', components:&#123;App,Bpp&#125;&#125;); 插槽slot slot默认的名字name=default ,还可以定义具名slot将对应的内容插入到对应的位置 可以在slot中放置一些默认值，如果传值则替换掉 会将没有对应插槽的内容都放入默认插槽中（即没有设置具名的slot） 123456789101112131415161718192021222324&lt;div id="app"&gt;&lt;/div&gt;&lt;template id="hello"&gt; &lt;div&gt; &lt;div&gt;你好&lt;/div&gt; &lt;span&gt; &lt;slot name="you"&gt;ninini&lt;/slot&gt; &lt;slot name="my"&gt;wowowow&lt;/slot&gt; &lt;slot name="she"&gt;她&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/span&gt; &lt;/div&gt;&lt;/template&gt;let hello = &#123;template:'#hello'&#125;;let vm = new Vue(&#123; el:'#app', template:`&lt;div&gt;&lt;hello&gt; 傻瓜 &lt;p slot="my"&gt;我很好&lt;/p&gt; &lt;p slot="you"&gt;你很好&lt;/p&gt; 天才 &lt;/hello&gt;&lt;/div&gt;`, components:&#123;hello&#125;&#125;); 引用 ref 添加ref = &quot;名称&quot;行内属性，vue会自动将这个元素放到this.$refs 可以用this.$refs.名称获取具体的dom元素，以及dom元素代表的组件实例，this.$refs.名称.fn可以获取其上的数据和方法 this.$refs存储着所有的ref对象，是真实的dom元素 12345678910111213141516171819let hello = &#123; template:'&lt;h1&gt;你好&lt;/h1&gt;', methods:&#123;fn()&#123;alert(1)&#125;&#125;&#125;;let vm = new Vue(&#123; el:'#app', //给div起了一个别名 ref = "content" template:`&lt;div ref="content"&gt; &lt;button @click="change"&gt;点击变红&lt;/button&gt; &lt;hello ref="hello"&gt;&lt;/hello&gt; &lt;/div&gt;`, components:&#123;hello&#125;, methods:&#123; change()&#123; this.$refs.hello.fn();//调用实例上的方法 this.$refs.content.style.background = 'red';//设置元素样式 &#125; &#125;&#125;); 锚点和本地存储123456///监听hash值的变化let listener = function () &#123; vm.location = window.location.hash.slice(1) || 'complete'&#125;;listener(); //当页面刷新时获取一次 hash值window.addEventListener('hashchange', listener); spa 单页开发，不跳转页面hash 锚点 开发时一般用 hash获取hash值——wind·ow.location.hash.slice(1)//去除#号监听hash值的变化——window.addEventListener(&#39;hashchange&#39;, function(){}); h5 自带的api方法 没有 # 号，但是需要服务端支持，在开发时使用如果刷新页面会导致404 history.pushState 路由： 不同的路径，显示不同的内容，浏览器路径发生变化就会产生历史管理本地存储：sessionStorage、localStorage、cookie 4k]]></content>
      <categories>
        <category>JavaScript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础运用]]></title>
    <url>%2F2017%2F01%2F06%2Fwebpack%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装、命令行、基础配置 webpack是一款强大的模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理 webpack 是以commonJS的形式来书写，但对AMD/CMD的支持也很全面,方便旧项目进行代码迁移 开发便捷，能替代部分gulp的工作，比如打包、混淆压缩、图片转base64等 能被模块化的不仅仅是JS,还包括各种资源文件 less sass stylus 自动编译 扩展性强，插件机制完善，特别是支持React热插拔 可以提供端口号，实现自动刷新的功能 webpack作用自动化构建工具，把源代码转换成发布到线上的可执行JavaScript，CSS，HTML代码 代码转换：ES6编译成ES5，LESS编译成CSS。 文件优化：压缩JavaScript、CSS、HTML代码，压缩合并图片等。 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载。 模块合并：在webpack中一切文件皆模块（好处是能清晰的描述出各个模块之间的依赖关系，方便模块进行组合和打包），通过loader转换文件，Plugin注入钩子，最终输出多个模块组合成的文件。 自动刷新：监听本地源代码的变化，自动重新构建，刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 安装webpack12npm install webpack --save-dev//本地安装webpacknpm install webpack -g//全局安装webpack 不建议安装到全局，会导致版本问题，最好选用本地安装 webpack命令行 打包，如$ webpack index.js bundle.js index.js：打包的入口文件路径 bundle.js：打包后的输出文件名 命令行参数 作用 webpack 开发环境下编译 webpack -p 生产环境下编译，会压缩生成后的文件 webpack -w 开发环境下持续的监听文件&gt;变动来进行编译 webpack -d 生成map映射文件,会在控制台的Sources页签中出现存放打包前原始文件的webpack://目录，可以打断点，帮助调试 webpack index.js bundle.js -d webpack --progress 显示构建百分比进度 webpack --display-error-details 显示打包过程中的出错信息(比如 webpack寻找模块的过程) webpack --profile 输出性能数据，可以看到每一步的耗时 使用webpack配置文件下载webpack1npm install webpack --save-dev 创建初始文件夹及文件 1、创建并进入项目文件夹 2、初始化项目$ npm init -y 3、项目根目录下创建src和build目录 src：存放源码 build：存放编译打包之后的资源 4、新建文件 src/index.js build/index.html 创建webpack的配置文件 新建webpack.config.js 12345678910111213var path = require('path');module.exports = &#123; //打包的入口文件 String|Object entry: path.resolve(__dirname, 'src/index.js'), output: &#123; //配置打包结果 Object //定义输出文件路径 path: path.resolve(__dirname, 'build'), //指定打包文件名称 filename: 'bundle.js'//即输出文件路径中html文件中引入的文件 &#125;, //能让控制台的报错信息指向源代码，而非打包后的文件 devtool:"source-map",&#125;; 文件名一般不要改，如果要改，在webpack运行的时候需要通过--config这个参数指定配置文件，比如：webpack --config conf.js和webpack-dev-server --config webpack.todos.config.js --open build/index.html中加入&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 修改package.json，&quot;scripts&quot;属性值对象中加入如下代码，如果没有&quot;scripts&quot;属性，就新增 123"scripts": &#123; "build": "webpack"//加入&#125; 此时执行$ npm run build，会在build目录下会新增了一个bundle.js文件，里面就存放着打包后的目录 loader使用babel-loader来解析es6写成的模块 加载器列表 安装loader 安装babel 1npm install babel-loader babel-core --save-dev 告诉翻译如何翻译及翻译es7语法 1npm install babel-preset-es2015 babel-preset-stage-0 --save-dev 创建.babelrc文件，内容如下 1234&#123; "presets": ["es2015", "stage-0"], "plugins": []&#125; 修改webpack.config.js，module.exports加入新属性module及其值，如下 123456789101112131415module.exports = &#123; //定义了对模块的处理逻辑 Object module: &#123; //定义了一系列的加载器 Array rules: [ &#123; test: /\.js$/, //正则，匹配到的文件后缀名 // loader：String|loaders：Array，处理匹配到的文件 loader: 'babel-loader' // include：String|Array 包含的文件夹 // exclude：String|Array 排除的文件夹 &#125; ] &#125;&#125; devServerwebpack-dev-server是一个Web服务器，可以预览项目，并且当修改源码后可以实时刷新页面 安装·devServer：$ npm install webpack-dev-server --save-dev 修改package.json，&quot;scripts&quot;属性值对象中加入如下代码，如果没有&quot;scripts&quot;属性，就新增 123"scripts": &#123; "dev": "webpack-dev-server"//加入&#125; 修改webpack.config.js，module.exports加入新属性devServer及其值，如下 1234567module.exports = &#123; devServer: &#123; stats: &#123; colors: true &#125;, //显示颜色 port: 8080,//端口 contentBase: 'build',//指定静态文件的根目录 &#125;&#125; 此时执行$ npm run dev，启动此服务的时候，编译后的产出文件放在内存里,在build目录下看不见,但也不会删除原来已经有的文件，预览项目：访问http://localhost:8080 proxy模拟后台接口 修改webpack.config.js 1234567891011121314151617181920212223242526272829303132//重写urlfunction rewriteUrl(replacePath) &#123; return function (req, opt) &#123; //取得?所在的索引 var queryIndex = req.url.indexOf('?'); //取得查询字符串的内容 var query = queryIndex &gt;= 0 ? req.url.substr(queryIndex) : ""; //$1取自path匹配到的真实路径中的第一个分组 //把proxy的path替换为 '/$1\.json', req.url = req.path.replace(opt.path, replacePath) + query; &#125;;&#125;module.exports = &#123; devServer: &#123; stats: &#123; colors: true &#125;, //显示颜色 port: 8080,//端口 contentBase: 'build',//指定静态文件的根目录 proxy: [ &#123; //替换符合此正则的接口路径 path: /^\/api\/(.*)/, //目标域名端口 target: "http://localhost:8080/", //重新定向到新的地址 //$1取自path正则匹配到的真实路径的第一个分组 rewrite: rewriteUrl('/$1\.json'), //修改来源地址 changeOrigin: true &#125; ] &#125;&#125; 在浏览器输入此地址 http://localhost:8080/api/book 将会被重写向到http://localhost:8080/book.json 解析less样式文件和css样式文件 安装loader$ npm install less style-loader css-loader less-loader --save-dev less-loader负责把less源码转成css代码 css-loader负责读取css代码 style-loader负责在css代码转变成style标签并作为页内样式插入到页面中去 修改webpack.config.js，加入 123456789101112131415module.exports = &#123; module: &#123; rules: [ &#123; test:/\.css$/,//如果文件后缀是css loaders:["style-loader","css-loader"] &#125;, &#123; test:/\.less$/,//如果文件后缀是less loaders:["style-loader","css-loader","less-loader"] //或loader: 'style!css!less' &#125; ] &#125;&#125; 在src/index.js中引入less文件 设置图标文件的加载器 安装loader$ npm install url-loader --save-dev 修改webpack.config.js，加入 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test:/\.(eot|svg|woff|woff2|ttf|jpg|png|gif)$/,//如果是bootstrap中的这五种字体的话 loaders:["url?limit=8192","url-loader"]//"url?limit=8192"表示将所有小于8kb的图片都转为base64形式(其实应该说超过8kb的才使用url-loader 来映射到文件，否则转为data url形式) &#125; ] &#125;&#125; 自动刷新 修改webpack.config.js，加入 12345module.exports = &#123; devServer: &#123; inline:true//设置自动刷新 &#125;&#125; 自动产出html 创建html模板文件src/index.html 下载html-webpack-plugin插件$ npm install html-webpack-plugin --save-dev 修改webpack.config.js，加入 12345678910var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; title: '百度首页',//标题 template: './src/index.html', //模板文件 filename:'./index.html' //产出后的文件名称 &#125;) ]&#125; 自动打开浏览器 下载open-browser-webpack-plugin插件$ npm install open-browser-webpack-plugin --save-dev 修改webpack.config.js，加入 123456var openBrowserWebpackPlugin = require('open-browser-webpack-plugin')module.exports = &#123; plugins: [ new openBrowserWebpackPlugin(&#123; url: 'http://localhost:8080' &#125;)//自动访问的地址 ]&#125; 区分环境标识 在package.json中设置环境变量 12345678910//WIN系统"scripts": &#123; "publish-dev": "set BUILD_ENV=dev &amp;&amp; webpack-dev-server", "publish-prod": "set BUILD_ENV=prod &amp;&amp; webpack-dev-server"&#125;//MAC系统"scripts": &#123; "publish-dev": "export BUILD_ENV=dev &amp;&amp; webpack-dev-server", "publish-prod": "export BUILD_ENV=prod &amp;&amp; webpack-dev-server"&#125; 修改webpack.config.js，加入 12345678910var webpack = require('webpack');var definePlugin = new webpack.DefinePlugin(&#123; __DEV__: (process.env.BUILD_DEV||'dev').trim() == 'dev'&#125;);module.exports = &#123; plugins: [ definePlugin, new HtmlWebpackPlugin ]&#125; 暴露全局对象 安装暴露组件$ npm install expose-loader --save-dev 修改webpack.config.js，加入 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /jquery.js$/, loader: "expose?jQuery" &#125; ] &#125;&#125; 此时可以在在html中使用jQuery&lt;script&gt;console.log(window.jQuery);&lt;/script&gt; css文件单独加载 安装插件$ npm install extract-text-webpack-plugin --save-dev 修改webpack.config.js 123456789101112131415var ExtractTextPlugin = require("extract-text-webpack-plugin") &#123; test: /\.less/, loader:ExtractTextPlugin.extract("style-loader", "css-loader!less-loader") &#125;, &#123; test: /\.css/, loader: ExtractTextPlugin.extract("style-loader", "css-loader") &#125;plugins: [ definePlugin, new ExtractTextPlugin("bundle.css")] 应用代码和第三方代码分离 修改webpack.config.js，替换entry和output中的内容 12345678910entry: &#123; index:path.resolve(__dirname, 'src/index.js'), vendor: ['jquery'],&#125; output: &#123; path: path.resolve(__dirname, 'build'),//输出路径 filename: '[name].js' //输出动态文件名&#125;//如果没有这句话，vendor只是一个普通的入口文件而矣,有了此语句会把vendor中的模块从index中分离出来,不再包含在打包出来的index.js中,会成生一个zfvendor.js文件new webpack.optimize.CommonsChunkPlugin('vendor','zfvendor.js'), 添加哈希值 修改webpack.config.js，替换filename中的内容 1filename: '[name].[hash].js' //输出文件名 压缩资源 修改webpack.config.js，加入 123456789101112131415161718192021plugins: [new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), new webpack.optimize.MinChunkSizePlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 查找相等或近似的模块，避免在最终生成的文件中出现重复的模块 new webpack.optimize.DedupePlugin(), // 按引用频度来排序 ID，以便达到减少文件大小的效果 // webpack 1 new webpack.optimize.OccurrenceOrderPlugin(),//webpack 2：new webpack.optimize.OccurrenceOrderPlugin() new webpack.optimize.AggressiveMergingPlugin(&#123; minSizeReduce: 1.5, moveToParents: true &#125;)]]]></content>
      <categories>
        <category>工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[buffer]]></title>
    <url>%2F2017%2F01%2F05%2Fbuffer%2F</url>
    <content type="text"><![CDATA[buffer表示的是内存，大小是固定的，不能随意扩张，但是没有数组里操作长度的方法 Buffer是global上的属性，可以在全局下直接访问 读取文件都是二进制，buffer是16进制的 255 代表的16进制是ff，所以buffer的范围是0-ff之间，16进制都是以0x开头，如0xff buffer可以和字符串自由转化 支持utf_8格式 一个汉字3个字节，字母数字都是一个字节 最小单位都是以字节表示的 一个字节由8个二进制组成，1b = 8bit 进制转化buffer任意进制转任意进制toString：(0xff).toString(2)得11111111 任意进制转10进制 当前位上的值*当前进制^(当前所在位-1)累加 12345//11111111 二进制转换let total = 0;for(let i=1;i&lt;=8;i++)&#123; total+=1*Math.pow(2,i-1)&#125; parseInt()：parseInt(&#39;11111111&#39;,2)得255 base64的转换ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/当前的字节最大不超过64：38 = 46 不是将图片都转为base64，较小的图片可以转换，可以减少http请求。 base64进制转换，不算加密；md5也不是加密（不可逆） 定义buffer 通过长度来创建 123var buffer = new Buffer(6);//6个字节,随机分配buffer.fill(0); //手动填充0，0一般认为内存是干净的console.log(buffer);//&lt;Buffer 00 00 00 00 00 00&gt; 通过数组创建buffer，可以指定内容,只能放0-255之间的数，一般这种方式比较少用 12var buffer = new Buffer([0x64,200]);console.log(buffer);//&lt;Buffer 64 c8&gt; 通过字符串声明buffer 123var buffer = new Buffer('珠峰'); //一个汉字三个字节console.log(buffer[0]);//231//直接通过索引取值无法取出16进制 取出的都是10进制 slice方法 buffer上的方法slice12345var buffer = new Buffer([1,2,3]);//&lt;Buffer 01 02 03&gt;let newBuffer = buffer.slice(0,1);//&lt;Buffer 01&gt;newBuffer[0] = 100;//&lt;Buffer 64&gt;console.log(buffer); //&lt;Buffer 64 02 03&gt;//buffer中存放的是引用地址 浅拷贝：拷贝的是引用地址，当引用的地址内的数据发生变化，拷贝后的结果也会发生变化 Object.assign() 深拷贝：长得一样但内部存的地址完全不相同JSON.parse(JSON.stringify(arr))(不识别函数)递归循环 copycopy(targetBuffer, targetStart, sourceStart,sourceEnd) targetBuffer：目标buffer targetStart：目标开始 sourceStart：源的开始 sourceEnd：源的结束 1234567let buf1 = new Buffer('北京');let buf2 =new Buffer('你好');let bigBuffer = new Buffer(12);buf2.copy(bigBuffer,buf1.length);console.log(bigBuffer,bigBuffer.toString());//&lt;Buffer 00 00 00 00 00 00 e5 9f b9 e8 ae ad&gt; " 你好buf1.copy(bigBuffer,0);console.log(bigBuffer,bigBuffer.toString());//&lt;Buffer e7 8f a0 e5 b3 b0 e5 9f b9 e8 ae ad&gt; "北京你好" toStringbuffer.toString(字符串类型,sourceStart,sourceEnd) 将buffer转换成字符串类型 start、end是截取的buffer的长度 如buffer.toString(&#39;utf8&#39;,3,6) fill手动初始化buffer.fill(0); writebuffer.write(string,offset,length,encoding); concatBuffer.concat([buf1,buf2],length); 实现concat拼接 通过长度构建，判断是否传递长度,如果没传递，先算出拼接后的总长 循环每一项将每个buffer拷贝到大buffer上 拷贝后 超过拷贝的长度要被截取掉，返回最终的 12345678910111213141516171819Buffer.myConcat = function (list,totalLength) &#123; if(typeof totalLength === 'undefined')&#123; totalLength = 0; totalLength = list.reduce((prev,next)=&gt;&#123; return prev+next.length; &#125;,totalLength); &#125; let result = new Buffer(totalLength);//构建大buffer let offset = 0; //拷贝的偏移量 list.forEach(buf=&gt;&#123; if(!Buffer.isBuffer(buf))&#123; //判断是不是buffer throw new Error('not a buffer'); &#125;else&#123; buf.copy(result,offset); //将每一个buffer拷贝到大buffer上 offset += buf.length; //每次将拷贝的位置累计 &#125; &#125;); return result.slice(0,offset);//offset就是真实拷贝的长度&#125;; isBufferBuffer.isBuffer(buffer)判断是否是buffer lengthbuffer.length获取字节长度(显示是字符串所代表buffer的长度)]]></content>
      <categories>
        <category>JavaScript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise应用]]></title>
    <url>%2F2016%2F12%2F29%2FPromise%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[async await 是基于promise，fetch也是基于promise高版本浏览器自带promise 异步回调 回调地狱：多个回调函数嵌套，导致代码不够直观 并行结果：几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务 Promise实例let p1=new Promise((resolve,reject)=&gt;{}) 12345678let p1=new Promise((resolve,reject)=&gt;&#123;resolve()&#125;)p1.then(()=&gt;&#123; //这个就是resolve回调 console.log("这个就是resolve")&#125;,()=&gt;&#123; //这个就是reject回调 console.log("这个就是reject")&#125;).then(data=&gt;data,error=&gt;error).catch(error=&gt;&#123;&#125;) resolve，reject都是函数 resolve：调用后，Promise对象会变成成功态，同时传递一个参数用于后续成功后的操作（作为后面then的resolve回调的传参） reject：调用后，Promise对象会变成失败态，同时传递一个参数用于后续错误处理的操作（作为后面then的reject回调的传参或作为后面catch的回调函数的传参） resolve，reject只能执行其中一个 模拟Promise ES5 1234567891011121314151617181920function Promise(fn) &#123; fn((data)=&gt; &#123; this.success(data); &#125;, (error)=&gt; &#123; this.error(); &#125;);&#125;Promise.prototype.resolve = function (data) &#123; this.success(data);&#125;Promise.prototype.reject = function (error) &#123; this.error(error);&#125;Promise.prototype.then = function (success, error) &#123; this.success = success; this.error = error;&#125; ES6 1234567891011121314151617181920212223class Promise &#123; constructor(fn) &#123; fn((data)=&gt; &#123; this.success(data); &#125;, (error)=&gt; &#123; this.error(); &#125;); &#125; resolve(data) &#123; this.success(data); &#125; reject(error) &#123; this.error(error); &#125; then(success, error) &#123; this.success = success; this.error = error; console.log(this); &#125;&#125; Promise原型上的方法thenPromise原型上有then方法 12345let createPromise=newPromise((resolve,reject)=&gt;&#123;...&#125;);let returnPromise=createPromise.then( (data)=&gt;&#123;&#125;,// resolve (error)=&gt;&#123;&#125; // reject); 返回值（如returnPromise）是一个新的Promise实例，因此可以链式调用 then的参数 第一个参数，resolve回调函数，Promise实例（如createPromise）为成功态时调用 第二个参数，reject回调函数，Promise实例（如createPromise）为失败态时调用 只有resolve回调或reject回调执行过程中throw一个error，then的返回值returnPromise才为失败态，否则returnPromise为成功态 链式调用中，resolve回调或reject回调的返回值作为下一次then或者catch方法的回调函数的传参 catchPromise实例上有catch方法 Promise实例为失败态时，catch方法的回调函数才被调用 返回值是一个新的Promise实例（returnPromise），可以链式调用，但一般情况下，catch只在末尾出现 如果catch方法的回调函数执行过程中没有throw一个error，则returnPromise为成功态，否则为失败态 123456p1.then((a) =&gt; &#123; console.log(a); b++; &#125;).catch((e)=&gt;&#123;//如果某一步出错，则会进入 console.log("终于还是被发现了",e); &#125;) all参数：一个promise实例的数组 返回值：一个promise实例 参数各项promise实例都为成功态时，返回值才会是成功态；有一个为失败态，返回值就为失败态 向后传递的参数是数组，由参数各项promise实例的resolve或reject传参组成 无论参数各项promise实例完成顺序如何，向后传递的参数数组顺序都和其自身一致 123456789101112131415161718function read(filename) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filename, 'utf8', function (err, data) &#123; if (err)return reject(err); resolve(data); &#125;); &#125;)&#125;Promise.all([ read('name.txt'), read('age.txt')]).then( ([name,age])=&gt; &#123;//['北京',100] //按照请求的顺序 返回的结果组成的数组，可以使用解构赋值 console.log(name,age);//'北京' 100&#125;).catch( function (err) &#123;//如果某一步出错，则会进入 &#125;); race参数：一个promise实例的数组 返回值：一个promise实例 参数各项promise实例都为失败态时，返回值才会是失败态；有一个为成功态，返回值就为成功态 向后传递的参数是数组，由参数各项promise实例的resolve或reject传参组成 无论参数各项promise实例完成顺序如何，向后传递的参数数组顺序都和其自身一致 resolve 参数为值(对象、数组、字符串等)时，返回值为一个Promise实例，参数作为向后传递的参数 参数为Promise实例时，返回值为参数自身 返回值都是成功态 reject参数：通常为抛出的错误信息 返回值：一个失败态的Promise实例]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2016%2F12%2F23%2FES6%2F</url>
    <content type="text"><![CDATA[let和const、解构赋值、字符串方法扩展、数组方法扩展、函数扩展、对象扩展、新数据结构、类、Promise es6是JavaScript的一种新的规范，兼容各个浏览器最新的版本 ES6转ES5 npm init -y 初始化配置文件 npm install babel-cli -g npm install babel-preset-es2015 npm install babel-preset-stage-0 创建. babelrc文件 babel a.js --out-file b.js 监听 指定目录的转译babel 文件夹名 --out-dir 文件夹名 监听转译babel 文件夹名 -wd 文件夹名 结束监听 ctrl+c y 回车 作用域变量var的问题 var没有块级作用域，变量是通过闭包进行隔离的，定义后在当前闭包中都可以访问，如果变量名重复，就会覆盖前面定义的变量，并且也有可能被其他人更改 var在for循环标记变量共享，一般在循环中使用的i会被共享，其本质上也是由于没有块级作用域造成的 let 不存在变量提声(没有预解释) 12console.log(str);//str is not definedlet str="hello" 12345let num2 = "123";if(true)&#123; console.log(num2) //该虽然不进行变量提声,但是作用域形成后,先把所有的变量过滤一遍,一旦发现不合法直接报错,当前作用域下代码不执行了，所以结果为num2 is not defined let num2 =15;&#125; 在同一块级作用域下，声明的变量，不能重复声明。不同的块级作用域可以多次声明 12345var num = 1;let num = 2; //报错 let 不管是var 还是function都不可重复声明&#123; let num=2;// 不会报错&#125; 暂时性死区:在一个作用域下不可以使用未被定义的变量 在es6中，let声明的变量，只在当前的作用域（块级作用域——被大括号包起来的代码块）内有效 123456if(true)&#123; var num1 = "hello"; let num2 = "world"; console.log(num1,num2)//"hello" "world"&#125;console.log(num2); // num2 is not defined let定义的变量不会当做全局window的属性 const 上述let的特点const都符合 声明的变量是一个常量(静态变量:只赋值一次,不能重新赋值)，而变量的值本身是可以改变的 12const names = ['zfpx1'];names.push('zfpx2'); 只要声明了必须赋值 const定义的变量不会当做全局window的属性 块级作用域(私有作用域)块级作用域 ：被大括号包起来的代码块{表示一个块级作用域(私有作用域)} let声明的变量，只在当前的块级作用域内有效，如果下级作用域没声明变量向上级作用域的查找 块级作用域内function声明的变量，在全局作用域下只声明不定义 块级作用域可以多层嵌套 在for循环中 ，用let声明的变量，不会泄露成全局的变量（首先形成父作用域，循环体 循环一次，形成一个子作用域） if中条件是上一级作用域，{}中是私有作用域 在严格模式下，只能在顶层作用域和函数内声明，其他情况 if代码块，for循环代码块都会报错 如果想用{}表示对象千万不要写在行首,非要写记住加上()包起来 es6中自执行函数123&#123;执行代码&#125; 解构赋值数组的解构赋值 基本用法 12let [x,y]=[1,2];console.log("x=%s,y=%s",x,y);//x=1,y=2 嵌套 123let ary1=[[[[[2]]]],[[[3]]]];let [[[[[n]]]],[[[m]]]]=ary1;console.log(n, m);//2,3 省略赋值 12let [,,x1]=[1,2,3];console.log(x1);//3 不定参数(必须在最后) 123let ary2=[1,2,3,4,5];let [,,,...x2]=ary2;console.log(x2);//[4,5] 默认值（只有在解构赋的值为undefined的情况下,才会走默认值,否则不会走默认值） 123456789101112let [ d=(function () &#123; console.log("哈哈哈"); return "d" &#125;)(), dd, ddd=(function () &#123; console.log("嘿嘿嘿"); return "d" &#125;)()]=[undefined,2,undefined];//"哈哈哈" "嘿嘿嘿"console.log(dd);//2 对象结构赋值 基本用法 变量名=属性名 12let &#123;a,b&#125;=&#123;a:"a",b:"b"&#125;;console.log(a, b);//"a" "b" 变量名!=属性名 12let &#123;a:x,b:y,c&#125;=&#123;a:"a",b:"b",c:"c"&#125;;console.log(x, y, c);//"a" "b" "c" 嵌套 12let &#123;a:[,m],b:n&#125;=&#123;a:[1,2],b:"bb"&#125;;console.log(m, n);//2 "bb" 默认值（只有在解构赋的值为undefined的情况下,才会走默认值,否则不会走默认值） 1let &#123;name:mm,s:f="f"&#125;=&#123;name:"qq",s:undefined&#125;; 其他结构赋值 赋值不是一个对象,使用Object()，将其他数据类型变成对象,再解构赋值 1234let &#123;__proto__&#125;=1;console.log(__proto__);//Numberlet &#123;length:le&#125;="12345";console.log(le);//5 字符串=&gt;数组解构赋值 1234let [l,k,g,p,u]="12345";console.log(l, k, g,p,u);//1 2 3 4 5let str="12345";console.log([...str]);//["1","2","3","4","5"] 用途 函数,形参的赋值 function fn1([x = 1, y]) {};fn1([, 2]); function fn2( y,x = 1) {};fn2(2); function ff1({x=0,y=0}={}) {} function ff2({x,y}={x:0,y:0}) {} 12345function fn3(...arg) &#123; //...将非数组变成数组 console.log(arg);&#125;fn3(1,2,3,4,5)` 交换变量 123let x1=10,x2=20;[x1,x2]=[x2,x1];console.log(x1, x2);//20 10 字符串扩展方法includesstr.includes(&quot;a&quot;,2) 返回值：true/false 第二个参数：开始查找的索引 默认是0 startsWith/endsWith是不是以什么字符作为开头/结尾 返回值：true/false 第二个参数：开始查找的索引 默认是0 new Function(&quot;形参&quot;,&quot;函数体&quot;)123456var ff=new Function("a","console.log(a);return 1");//等同于function ff (a)&#123; console.log(a); return 1&#125; repeat(num)将字符串重复num次返回 num是小数:向下取整 2.9 =&gt;2 负数:报错 12let ss1="123";console.log(ss1.repeat(2.9));//"123123" for of输出每一个字符 12345var foo = "look";for(let key of foo)&#123; console.log(key)&#125;//"l" "o" "o" "k" 模板字符串反引号包裹 支持(保留)换行和空格 想要表示本身的意思就给他转义一下\ 12`1 \n 1` ${变量} 12345function fn() &#123; return "哈哈哈"&#125;let s2 = `大家好:$&#123;fn()&#125;`;console.log(s2);//"大家好:哈哈哈" 带标签（函数）的模板字符串，标签可以接收两种参数 第一个参数，是模板字符串里每个部分的字符串组成的数组 其余的参数，是模板字符串里的变量的值 123456var name = 'zfpx',age = 8;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`;// 控制台 ['',' is ',' old!'] ['zfpx', 8] 数组扩展Array原型上的方法copyWithin(n,m1,m2)用数组自己的一部分替换自己的某部分 n:开始替换的索引 必填 m1:开始读取的位置,默认值0 可选 m2:读取结束的位置,默认值length 可选 (不包括m2) 12let ary = [1, 2, 3, 4, 5];console.log(ary.copyWithin(3, 2, 3));//[1, 2, 3, 3, 5] fill(val,n,m)常用来数组的初始化 n,m：可选的 123let ary1 = Array(7).fill(1);console.log(ary1);//[1, 1, 1, 1, 1, 1, 1]console.log(ary1.fill("a", 2, 4));//[1, 1, "a", "a", 1, 1, 1] find(fn)ary.find(function(item,index){return x})获取满足条件的具体项（获取一个后不在继续查找） x：true/false 返回值：找到的第一个满足条件的项——item 12let arr=[1,23,3432,52];arr.find((item,index)=&gt;item&gt;3);//23 findIndex(fn)先遍历数组,执行函数fn，一旦这个函数返回true，停止查找,返回当前项的索引 includesary.includes(x)判断一个数组中有没有某一项 返回值：boolean类型——true/false 第二个参数:表示开始查找的索引 12let arr=[1,23,3432,52];arr.includes(52);//true someary.some(function(item,index){return x})检测是否含有满足条件的项（回调函数中有一次return true则some返回值为true） x：true/false 返回值：boolean类型——true/false 12let arr=[1,23,3432,52];arr.some((item,index)=&gt;item&gt;3);//true reduceary.reduce(function(prev,next){return x},y) x：下次回调函数的prev形参值 y：第一次回调函数的prev形参值。 不设置y，y默认为ary[0]，从ary[1]开始作为next执行回调函数 返回值：叠加后的结果 1234let arr=[1,2,3,4,5];arr.reduce((pre,next)=&gt;&#123; return pre+next;//下次的pre&#125;,0);//0+1+2+3+4+5 123456let ary=[ &#123;price:30&#125;, &#123;price:40&#125;, &#123;price:50&#125;];ary.reduce((prev,next)=&gt;prev+next.price,0);//必须加0，确保prev为数字 filterary.filter(function(item,index){return x})过滤，满足条件的项就放到新数组中 x：true/false 返回true则放入新数组 返回值：过滤后的新数组 12let arr=[1,23,3432,52];arr.filter(item=&gt;item&lt;3);//[1] map映射 映射出一个新的数组，map函数中的返回值将会作为数组里的新项 返回值：新数组 12let arr=[1,2,3];arr.map(item=&gt;`&lt;li&gt;$&#123;item&#125;&lt;li&gt;`);//``反引号 Array上的方法Array.from()将类数组/数组变成一个新的数组 Array.of()这个方法的出现是为了弥补Array()的不足 Array(x,y...)变成一个数组返回 Array(1, 2, 3)变成[1,2,3] Array(n)代表数组的长度length Array(3)变成[,,,](3个空位) Array.of(n)变成一个数组返回 Array.of(10)变成[10] 索引 in 数组console.log(0 in [])false 遍历方法 遍历值 123for (var val of ary) &#123; console.log(val);&#125; 遍历索引 123for (var key of ary.keys()) &#123; console.log(key);&#125; 全都遍历出来 123for(var [key ,val] of ary.entries())&#123; console.log("key:%s,val:%s",key,val);&#125; 数组的空位 在ES5中遍历数组的方法很多,每种方法对空位的处理不一致,大部分都是直接省略空位,跳过去 在ES6提供的遍历的方法都会讲空位处理为undefined 函数扩展参数 es6 直接可以在形参里面赋值（默认值），如果实参传入undefined，函数的参数等于默认值 null 可以改变默认值fn(null,2); 剩余操作符可以把其余的参数的值都放到一个数组里面 12345let rest = function(a,...rest)&#123; console.log(a,rest);&#125;rest(1,2,3);// 1 [2,3] 展开操作符传参展开操作符...，放在数组前可以把数组每一项作为参数进行传参，可以取代apply 123// ...可以替代applyvar m1 = Math.max.apply(null, [8, 9, 4, 1]);var m2 = Math.max(...[8, 9, 4, 1]); 箭头函数形参=&gt;函数体如果不传参,或者多个参数，就使用一个圆括号包起来，如 1234567let fn = () =&gt;&#123; console.log(arguments) if(a === 1)&#123; return "hello world" &#125; return "huanying"&#125; 箭头函数中，没有arguments这个对象 不可以当做构造函数，不可以new 命令 函数体内的this对象，指向定义所在对象，不是函数执行所在的对象 箭头函数一般常用来当做参数,也就是一般是回调函数 匿名函数的name属性 普通的匿名函数 name为&quot;&quot; 特殊1：name为anonymous 1console.log(new Function("a", "return a").name);//"anonymous" 特殊2：name为bound fn 12let ff=fn.bind(null);console.log(ff.name);//"bound fn" 对象扩展obj[属性名] 对象内的属性名必须是字符串，如果你写其他的,就会默认调用toSting转为字符串 属性名可是使用简单的表达式 写在[]中 __proto__属性对象中直接设置__proto__属性，能直接设置对象的原型 123456var obj1 = &#123;name:'z1'&#125;;var obj3 = &#123; __proto__:obj1&#125;console.log(obj3.name);// z1console.log(Object.getPrototypeOf(obj3)); super在对象中super代表原型，能通过其调用原型上的属性或方法 123456789101112let person =&#123; eat()&#123; return 'milk'; &#125;&#125;let student = &#123; __proto__:person, eat()&#123; return super.eat()+' bread' &#125;&#125;console.log(student.eat());// 'milk bread' 扩展方法Object.is(a,b)也是三个等号判断 主要是解决NaN和NaN相等的问题，console.log(Object.is(NaN, NaN));得true Object.assign(obj1,obj2)将obj2合并到obj1上 返回obj1 obj2中相同属性名会覆盖obj1 setPrototypeOf和getPrototypeOf Object.setPrototypeOf(obj,objOther)，将一个指定的对象的原型设置为另一个对象或者null Object.getPrototypeOf(obj)，获取对象的原型 123456789var obj1 = &#123;name:'z1'&#125;;var obj2 = &#123;name:'z2'&#125;;var obj = &#123;&#125;;Object.setPrototypeOf(obj,obj1);console.log(obj.name);// z1console.log(Object.getPrototypeOf(obj));// &#123;name:'z1'&#125;Object.setPrototypeOf(obj,obj2);console.log(obj.name); // z2console.log(Object.getPrototypeOf(obj)); 集合(Set、Map和Symbol数据结构)SetSet有点像数组,不过跟数组不一样的是，Set里面不能有重复的内容 new Set(数组/类数组) 返回值：去重后的类似数组的对象 size表示大小 addadd(val) 返回值是增加后的set 不能添加之前已经有的项 hashas(val)判断里面有没有这一项 返回值是true/false deletedelete(val)判删除某一项 返回值是true/false true：删除成功 false：没删除(里面没有这一项) clear()清空 没有返回值 遍历 遍历属性值 123for (var val of set1.values()) &#123; console.log(val);&#125; 遍历属性名/索引 123for (var key of set1.keys()) &#123; console.log(key);&#125; 全都遍历出来 123for(var [key ,val] of set1.entries())&#123; console.log("key:%s,val:%s",key,val);&#125; Mapnew Map([[键,值],[键,值]])Map数据结构中的键(属性名)可以是任何数据类型的 size表示大小 setset(key,val) 返回值是增加后的map对象 getget(key)获取某一项 返回值是属性值 遍历 遍历属性值 123for (var val of map1.values()) &#123; console.log(val);&#125; 遍历属性名/索引 123for (var key of map1.keys()) &#123; console.log(key);&#125; 全都遍历出来 123for(var [key ,val] of map1.entries())&#123; console.log("key:%s,val:%s",key,val);&#125; Symbol是一种新的原始数据类型,表示独一无二的一个值;通过Symbol函数生成的 类Class1234567891011class Fn&#123; // 定义构造函数，new实例时，自动调用 constructor(a,b)&#123; this.x = a;// 给实例添加私有属性 this.y = b; &#125; // 给当前这个类的原型新增新增方法 sum()&#123; console.log("1") &#125;&#125;; ES7中，私有属性可以直接在类里面定义 1234567&gt; class Animal &#123;&gt; name = 'Jack';&gt; constructor() &#123;&#125;&gt; &#125;&gt; let aa = new Animal();&gt; console.log(aa.name); // Jack&gt; 存取器getter和setter getter，使用get修饰符修饰，改变属性的读取行为 setter，使用set修饰符修饰，改变属性的读取行为 修饰符是一些关键字，用于限定成员或类型的性质 12345678910111213141516class Person &#123; constructor()&#123; this.hobbies = []; &#125; set hobby(hobby)&#123; this.hobbies.push(hobby); &#125; get hobby()&#123; return this.hobbies; &#125;&#125;let person = new Person();person.hobby = 'basketball';// 调用set hobby('basketball')person.hobby = 'football';// 调用set hobby('football')console.log(person.hobby);// 调用 get hobby()// [ 'basketball', 'football' ] 静态方法static使用static修饰符修饰的方法，不需要实例化类就能使用 1234567class Person &#123; static add(a,b)&#123; return a+b; &#125;&#125;console.log(Person.add(1,2));// 3 ES7中，可以使用static定义静态属性 123456&gt; class Animal &#123;&gt; static num = 42;&gt; constructor() &#123;&#125;&gt; &#125;&gt; console.log(Animal.num); // 42&gt; 继承 使用extends关键字实现继承 子类中使用super关键字来调用父类的构造函数和方法。 1234567891011// 类B 继承 类A的私有属性和原型上的方法class B extends A&#123; constructor(b)&#123; super() //代表调用父类构造函数constructor this.aa = 18//子类中没有this,这个对象是从父类A中继承过来 &#125; sayHi() &#123; return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi() &#125;&#125; Object.setPrototypeOf(Child.prototype,Parent.prototype); 迭代器(Iterator)迭代器有一个next方法。 next每次执行时，返回一个对象，对象里面有两个属性 value，表示返回的值 done，布尔值类型，表示是否迭代完成 1234567891011121314151617181920212223242526272829function buy(books) &#123; let i = 0; return &#123; next()&#123; let done = i == books.length; let value = !done ? books[i++] : undefined; return &#123; value: value, done: done &#125; &#125; &#125;&#125;// buy等价于// function* buy(books)&#123;// for(var i=0;i&lt;books.length;i++)&#123;// yield books[i];// &#125;// &#125;let iterators = buy(['js', 'html']);var curr;do &#123; curr = iterators.next(); console.log(curr);&#125; while (!curr.done);// &#123; value: 'js', done: false &#125;// &#123; value: 'html', done: false &#125;// &#123; value: undefined, done: true &#125; 生成器(Generator)生成器用于创建迭代器 1234567891011121314function* buy(books)&#123; for(var i=0;i&lt;books.length;i++)&#123; yield books[i]; &#125;&#125;let buying = buy(['js','html']);var curr;do &#123; curr = buying.next(); console.log(curr);&#125; while (!curr.done);// &#123; value: 'js', done: false &#125;// &#123; value: 'html', done: false &#125;// &#123; value: undefined, done: true &#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm和yarn]]></title>
    <url>%2F2016%2F12%2F23%2Fnpm%E5%92%8Cyarn%2F</url>
    <content type="text"><![CDATA[npm命令行、发布包、yarn命令行npm用于第三方模块安装 全局使用 (命令行)全局安装全局调用 全局安装npm库的包：npm install -g 需要在环境变量PATH中添加全局包路径，如C:\Users\cindy.liu\AppData\Roaming\npm，否则全局包命令不能识别 将本地脚本添加到全局node_modules下，并且能全局执行：npm link 本地脚本第一行需要指定脚本的解释程序：#! /usr/bin/env 解释程序。如#! /usr/bin/env node，用node执行脚本 在package.json的bin中配置全局命令及对应的本地脚本相对路径 12345678910111213&#123; "name": "mypack", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123;&#125;, "bin": &#123; "mypack": "bin/mypack.js" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 执行npm link http-serverhttp-server在npm下做了一个映射 当在命令下执行命令时 会去npm下查找，并没有安置的全局的环境变量中 12345npm install http-server -gnpm install -g nrm //帮你切换源头nrm lsnrm test //测试网络nrm use taobao //使用淘宝源 本地使用 (安装到当前目录在代码中使用) package.json不能有注释,项目名字不能有中文 不能有特殊字符 不能有大写 安装之前需要初始化npm ini不需要t -y 下载第三方模块 开发依赖：开发时用的，上线就不要了，如less，npm install less --save-dev 项目依赖：开发时用的，上线时也需要，如jquery，npm install jquery --save 安装全部依赖npm install 卸载依赖npm uninstall xxx --save-dev/--save 指定版本安装npm install jquery@2.1.0 --save 查看当前模块的版本号npm info jquery yarn 安装全局yarnnpm install yarn -g 初始化文件yarn init -y 增加项目依赖yarn add jquery 增加开发依赖yarn add less --dev 删除模块yarn JavaScript 包管理工具 jquery 安装全部依赖yarn install 发布包 登录账号，保证当前在npm上 12nrm use npmnpm addUser //如果没有则是注册 有了则是登录]]></content>
      <categories>
        <category>工具</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node]]></title>
    <url>%2F2016%2F12%2F23%2FNode.js%2F</url>
    <content type="text"><![CDATA[Node.js是一个让JS可以运行在浏览器之外的服务器端的平台，NODE是一个环境 它实现了诸如文件系统、模块、包、操作系统API，网络通信等核心JS没有或不完善的功能 它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用单线程，异步式I/O，事件·驱动式的程序设计模型 NODE采用的是谷歌的Ｖ8 引擎来渲染js的（运行速度快、稳定，编写的js代码不需要兼容的问题） Node.js 安装检测PATH环境变量是否配置了Node.js 点击开始菜单,点击运行 输入 cmd 输入命令 path 输出结果 如果有node的路径的话就表示配置正确，可以在命令行下执行node命令检查node.js版本node -v 手工配置环境变量 打开资源管理器 在计算机上点击右键，显示菜单后点击属性 选择高级系统设置 选择高级页签下的环境变量 在用户变量中找到path,如果没有就新建一个 在path的最前面添加node.js的安装路径，如 C:\Program Files\nodejs Node.js的优点 Nodejs基于Javascript语言 统一公共类库，代码标准化 Nodejs选择了目前最快的浏览器内核V8做为执行引擎 Nodejs的社区非常活跃 Node概念什么是回调 异步编程基本的方法，需要异步处理的时候一般采用后续传递的方式。 将后续逻辑作为函数参数中作为起始函数的参数。 同步和异步 同步是指发起调用之后主线程只能挂起,调用者主动等待这个调用的结果 异步是指发起调用之后主线程可以做别的事情,被调用者通过通知来告知调用者结果 什么是IO Input(输入) 从文件系统中读取文件 Output(输出) 向文件系统写入文件 什么是单线程/多线程 单线程指程序按顺序执行，前面流程执行完毕之后后面的流程才能执行到 多线程指同时可以执行多个任务，比如一边看电视，一边睡觉,通过系统线程上下文切换来弥补同步式IO调用时的时间开销 Node单线程指的是主线程是单线程的，所有阻塞的部分交给一个线程池处理，然后这个主线程通过一个队列跟线程池协作 什么是事件循环 管理异步动作、定时器和回调函数的机制叫事件环 异步的时候就会压入到这个队列，然后不停读取事件，事件发生后会把对应的回调加入队列 队列按加入的顺序依次执行，由普通函数和回调函数组成。 全局对象Global 在普通浏览器下执行js ，浏览器提供全局环境，全局对象是window NODE环境下的全局js对象是Global 默认在node中文件执行时套了一个闭包函数 node.js文件中 的this被更改了,为了实现模块化，在此函数中将this指向改掉了，全局this是{}，定时器中this指向自己 1console.log(this);//&#123;&#125; 我们声明的属性 不会自动挂载在global上，不会自动污染全局变量 全局对象 console 123console.time('a');for(var i = 0;i&lt; 100;i++)&#123;&#125;console.timeEnd('a');//for循环执行时间 exports require module _filename _dimame setTimeout setImmediate：立即执行，不能设置时间 ，但是异步的 process进程属性 process.pid process.env：在开发时会设置环境变量 123456let url = '';//上线时，不会设置node_env 所以会自动采用下面的路径if(process.env.NODE_ENV=='DEV')&#123; url = 'http://localhost:3000';&#125;else&#123; url = 'http://www.baidu.com';&#125; 方法 process.kill(process.pid)：杀死进程 process.cwd() process.chdir() process.nextTick()——异步 NODE模块 js没有模块系统，不支持封闭作用域或依赖管理 js没有标准库，没有文件系统API js没有包管理系统，不能自动加载和安装依赖 实现模块化的规范 CMD seajs 就近依赖，需要在引入即可 AMD requirejs 依赖前置，先引进来，先定义好在使用 commonjs、nodejs 基于文件读写的，天生自带模块化 CommonJS 是javascript模块化编程的一种规范，主要是在服务器端模块化的规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 文件加载缓存加载模块后会缓存，多次加载后得到同一对象 查看模块缓存console.log(require.cache); 查询模块绝对路径require.resolve(&#39;./test.js&#39;); 查看单个的模块缓存require.cache[require.resolve(&#39;./test.js&#39;)] 删除模块缓存require.cache[require.resolve(&#39;./test.js&#39;)]; 内置模块httpfs文件系统，操作文件、目录 fs.writeFile(文件路径,写入内容字符串,&quot;utf-8&quot;,function (err) {}) fs.exists(文件路径,function (err, data) {})判断文件是否存在，存在执行函数 fs.readFile(文件路径, &#39;utf8&#39;, function (err, data) {}) 读取的文件必须存在 读取时默认读出的内容都是buffer类型 读取文件不能比内存大 淹没可用内存，边读边写，而不是全部读到内存中，流 1234567function copy(source,target,callback) &#123; fs.readFile(source, function (err,data) &#123; //如果有错误调用callback传递错误 if(err) return callback(err); fs.writeFile(target,data,callback)&#125;)&#125; url url.parse () 第二个参数true时，方法的返回对象的query属性值为对象， url地址?后面的值当成键值对存储到这个对象中；不加true是字符串，加true就变成一个对象 util提供了很多方法, util.inherits(Child,Parent);：只继承父类公有属性 util.isArray(new RegExp())：判断类型的方法，isArray、isRegExp、isDate、isError… eventsnode自带事件库，公有方法on once remove 自定义模块 一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，通过闭包的形式产生独立作用域 如果需要提供一些方法给其他的用 模块导出：exports / module.exports 其他模块引用：require require()的返回值 并不是exports对象，是module.exports，module.exports = exports = {} 123let a = 1;exports = a//模块没有导出a变量值//正确写法：module.exports = a或exports.a=a或module.exports.a=a 第三方模块npm 是node的第三方管理模块工具 第三方模块可以直接引用模块名字会自动去当前目录下查找，找到对应的package.json中的main文件将其引入，如果找不到会去上级目录查找，到根目录未找到则报错 流流是一组有序的，有起点和终点的字节数据传输手段 它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理 流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流。 readStream将对象数据读取为流数据，当监听data事件后，开始发射数据 创建可读流var rs = fs.createReadStream(path,[options]); path：读取文件的路径 options： flags：打开文件要做的操作,默认为&quot;r&quot; encoding：默认为null start：开始读取的索引位置 end：结束读取的索引位置 highWaterMark：读取缓存区大小，默认的大小64kb 监听data事件rs继承了事件库eventsrs.on(&#39;data&#39;, function (data) {}); 会默认发布data事件，将数据传入到callback中，直到数据读干 data是buffer类型，将buffer拼接起来 监听end事件rs.on(&#39;end&#39;, function () {});当文件读取完毕后执行此方法 监听error事件rs.on(&#39;error&#39;,function (err) {}); 其他操作 rs.pause();：暂停data事件的触发 rs.resume();：恢复流的读取，继续开始data事件的触发 rs.setEncoding(&#39;utf8&#39;);：设置编码 writeStream创建可写流var ws = fs.createWriteStream(path,[options]); path：写入的文件路径 options： flags：打开文件要做的操作,默认为&quot;w&quot; encoding：默认为utf8 highWaterMark：写入缓存区的大小，默认大小16kb write方法var flag=ws.write(chunk,[encoding],[callback]); chunk：写入的数据buffer/string encoding：编码格式chunk为字符串时有用，可选 callback：写入成功后的回调 flag：flag代表是否还能写入，如果你给我的已经沾满了我的预期，那就返回false，否则返回true end方法ws.end(chunk,[encoding],[callback]);调用该方法关闭文件，迫使系统缓存区的数据立即写入文件中。不能再次写入，文件关闭后不能调用write方法 pipe方法可读流.pipe(可写流)： 异步的 并且是读一点写一点，防止淹没可用内存 12345678function copy(source,target) &#123; let rs = fs.createReadStream(source, &#123;highWaterMark:4&#125;); let ws = fs.createWriteStream(target, &#123;highWaterMark:1&#125;); rs.pipe(ws);&#125;copy('1.txt','3.txt'); 创建服务1234567891011121314151617var http = require('http');//创建一个服务,变量server就是我们创建出来的那个服务var server=http.createServer(function (req,res) &#123;//当客户端向服务器这个端口号发送一个请求,并且当前的服务已经成功接收到这个请求后会执行这个函数//req(请求):存放的是客户端请求的信息,包含客户端访问服务器url,问号传参的方式//res(响应):服务器响应给客户端的信息 var urlObj = url.parse(request.url);// url.parse 把request的属性url的属性值转换成对象 var pathname = urlObj.pathname; if(pathname === "/index.html")&#123; var content=fs.readFileSync("./index.html","utf-8"); res.end(content); &#125;&#125;)//监听当前的服务server.listen(8080,function()&#123; //当服务创建成功并且8080端口号也监听成功后执行这个回调函数 console.log("server is success");&#125;); 设置响应头123res.setHeader('Content-type','text/plain;charset=utf8');res.statusCode = 200;res.writeHead(200,&#123;'Content-type':'text/plain;charset=utf8'&#125;); 可以返回html文件 12var fs = require('fs');fs.createReadStream('./index.html').pipe(response); 需要根据路径返回不同的内容，根据内容类型，设置content-type属性 请求信息 请求路径console.log(req.url); 请求方法console.log(req.method); 请求头信息console.log(req.headers); http服务12345678910111213141516var http = require('http');var fs = require('fs');http.createServer(function (request,response) &#123; if(request.url=='/hello.html')&#123; response.setHeader('Content‐type','text/html;charset=utf8'); fs.createReadStream('./hello.html').pipe(response); &#125;else if(request.url=='/favicon.ico')&#123; response.statusCode = '404'; response.end(''); &#125;else if(request.url=='/style.css')&#123; response.setHeader('Content‐type','text/css;charset=utf8'); fs.createReadStream('./style.css').pipe(response); &#125;else if(request.url=='/index.js')&#123; response.setHeader('Content‐type','application/x‐javascript;charset=utf8') fs.createReadStream('./index.js').pipe(response);&#125;).listen(8080) 路径参数当访问路径时带有查询参数,无法访问到正确路径url 可以通过问号传参?后面的是参数 &amp; 把每一组参数分开 1234567891011121314Url &#123; protocol: 'http:', //协议 slashes: true, //是否有// auth: null, //用户名密码 host: 'zhidao.baidu.com', //主机 port: null, //80 端口 hostname: 'zhidao.baidu.com', //主机名 hash: null, //hash值 search: '?lm=0&amp;rn=10&amp;pn=0&amp;fr=search&amp;ie=gbk&amp;word=asdasd', //路径和和hash值之间的 query: 'lm=0&amp;rn=10&amp;pn=0&amp;fr=search&amp;ie=gbk&amp;word=asdasd', //如果true转换成对象 pathname: '/search', //路径 path: '/search?lm=0&amp;rn=10&amp;pn=0&amp;fr=search&amp;ie=gbk&amp;word=asdasd', //路径+查询字符串 href: 'http://zhidao.baidu.com/search?lm=0&amp;rn=10&amp;pn=0&amp;fr=search&amp;ie=gbk&amp;word=asdasd'&#125; 改造服务123456789var urlObj = url.parse(request.url,true);var pathname = urlObj.pathname;if(pathname=='/')&#123; response.setHeader('Content‐type','text/html;charset=utf8'); fs.createReadStream('./index.html').pipe(response);&#125;else if(pathname=='/style.css')&#123; response.setHeader('Content‐type','text/css;charset=utf8'); fs.createReadStream('./style.css').pipe(response);&#125; 合并冗余代码1234567891011121314151617181920212223var http = require('http');var fs = require('fs');var url = require('url');var path = require('path');var mime = &#123; '.html':'text/html', '.js':'application/x‐javascript', '.css':'text/css',&#125;http.createServer(function (request,response) &#123; var urlObj = url.parse(request.url,true); var pathname = urlObj.pathname; if(pathname=='/')&#123; response.setHeader('Content‐type','text/html;charset=utf8'); fs.createReadStream('./index.html').pipe(response); &#125;else if(pathname=='/favicon.ico')&#123; response.statusCode = 404; response.end(''); &#125;else&#123; response.setHeader('Content‐type',mime[path.extname(pathname)]+';charset=utf8') fs.createReadStream('.'+pathname).pipe(response); &#125;&#125;).listen(8080); 使用mime模块$ npm install mime安装mime 12345678910111213141516171819202122var http = require('http');var fs = require('fs');var url = require('url');var path = require('path');var mime = require('mime');http.createServer(function (request,response) &#123; var urlObj = url.parse(request.url,true); var pathname = urlObj.pathname; if(pathname=='/')&#123; response.setHeader('Content‐type','text/html;charset=utf8'); fs.createReadStream('./index.html').pipe(response); &#125;else &#123; var flag = fs.existsSync('./' + pathname); if (flag) &#123; response.setHeader('Content‐type', mime.lookup(pathname) + fs.createReadStream('.' + pathname).pipe(response); &#125; else &#123; response.statusCode = 404; response.end(); &#125; &#125;&#125;).listen(8080);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基础]]></title>
    <url>%2F2016%2F12%2F21%2Fless%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础教程+基础知识点less 是一种css预处理语言，让咱们更加方便和更好地维护，less 提供了变量、函数、嵌套，功能函数 安装及转义为CSS 1、安装npm install less --save 查看版本lessc -v 2、转义命令： lessc index.less index1.css将index.less文件转义为index1.css文件 监听（开发过程中使用）less文件改变时，页面随之变动，不需要转义和刷新 12345678910111213&lt;link rel="stylesheet/less" href="index.less"&gt;&lt;!--html页面引入less文件--&gt;&lt;script type="text/javascript"&gt; var less = &#123; env: "development", poll :1000 &#125;&lt;/script&gt;&lt;script type="text/javascript" src="less.min.js"&gt;&lt;/script&gt;&lt;!--html页面引入less.min.js文件--&gt;&lt;script type="text/javascript"&gt; // 开启less的监听模式 less.watch();//less的方法&lt;/script&gt; 语法嵌套1234567891011121314.box1&#123;//父元素 //父元素样式 margin:20px auto; width :200px; height:200px; background: #000000; .gray &#123;//子元素 //子元素样式 background : #000000; &#125; &amp;:hover&#123;//伪类，&amp;代表.box1 .transformScale(2); &#125;&#125; &amp;该运算符 是让当前的选择器和父级选择器按照特定的规则进行拼接 1234567891011.box&#123; &amp;:hover&#123; width:100px; &#125; &amp;-top&#123; height:300px; &#125; &amp; + &amp;-top&#123; width:100px; &#125; &#125; @定义变量语法：@变量名:值 变量不仅可以存储共用的属性值，还可以存储url、选择器 12@color: red;//定义.box1&#123;background-color:@color&#125;//使用 作用域在less中定义了一个命名空间，就创建一个作用域，在这个私有作用域中使用的变量首先看一下自己的作用域看有没有，没有的话，向上一级查找（类似于js作用域） 1234567.gray1&#123;color:@color&#125;//无法获取变量.box &#123; @color: #eee; .gray &#123; color: @color; &#125;&#125; 调用其他作用域中的样式12345678.public&#123; width:100px; height:100px; .gray&#123; background: #008CD7; &#125; &#125;.box&#123;.public&gt;.gray&#125;//public就是命名空间，它里面的方法gray，都是这个空间下的样式，调取里面的方法 调用其他样式方法 直接嵌套写{}中.box2{.transformScale(2)} 使用extend 可以写到括号中，引用另一个类型的样式.nav:extend(.public){} 括号外面，引用另一个类型的样式.nav{&amp;:extend(.public);} 函数123456789101112131415161718//定义函数.transition(@property:all,@duration:1s,@time-function:linear,@delay:0s)&#123; -webkit-transition: @arguments; -moz-transition: @arguments; -ms-transition: @arguments; -o-transition: @arguments; transition: @arguments;&#125;.transformScale(@val:1)&#123; -webkit-transform: scale(@val); -moz-transform: scale(@val); -ms-transform: scale(@val); -o-transform: scale(@val); transform: scale(@val);&#125;;//调用函数.box1&#123;.transition(@duration:3s)&#125;.box2&#123;.transformScale(2)&#125; 语法：.函数名(@变量名:变量默认值,@变量名:变量默认值){属性名:@变量名} 在less函数中，可以调用@arguments，代表所有参数 在less函数中，还有返回值，像js中的函数一样 1234567.average(@a,@b)&#123; @result:((@a+@b)/2);&#125;.box&#123; .average(16px,20px); padding:@result;&#125; 函数不需要传参数，可以不加括号，仍然可以调用，但转译之后的css，还是会存在这个样式的 !important在方法的后面加！important ,可以让所有的属性都继承，且在当前less文件中权重最高 123nav ul &#123; .function()!important;&#125;//代表继承`function`函数所有样式，并且这些样式权重最高 常用的条件运算符&gt;、&lt;、&gt;=、&lt;= 条件下使用函数iscolor、isnumber、isstring、iskeyword、isurl、ispixel、ispercentage 12345678.min (@a,@b:1) when (isnumber(@b))&#123; background: #008CD7;&#125;#box&#123; width:100px; height:100px; .min(@a:1,@b:2)&#125;]]></content>
      <categories>
        <category>CSS</category>
        <category>less</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和DOS常用命令]]></title>
    <url>%2F2016%2F12%2F20%2Flinux%E5%92%8CDOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[DOS (disk operating system) : 磁盘操作系统 DOS 有一个默认的打开路径 ： 作用： 内部或外部命令 ，可以运行程序， 批量处理文件 使用 执行命令，找到对应文件，去磁盘下找到文件，按着shift键，右击鼠标在此处打开命令行窗口 window+r键打开cmd 操作文件 linux DOS 作用 cd 目录相对路径 cd 目录相对路径 进入目录下 cd ../ 返回上级目录 cd ./ 返回当前目录 cd / 返回根目录 cd E: 进入指定磁盘 ls dir 查看当前文件夹下的目录 ls -l 查看当前文件夹下的目录详细信息 ls -a 查看当前文件夹下的目录(包括隐藏文件) ls -la 查看当前文件夹下的目录详细信息(包括隐藏文件) mkdir 目录名 mkdir 目录名 新建目录 touch 文件名.后缀名 创建文件（可以创建无文件名的文件，如.babelrc），不会重复后缀名 cat 文件名 more 文件名 查看文件内容 cp 文件名 路径 copy 文件名 路径 复制文件 mv 文件名 路径 move 文件名 路径 移动文件 rm 文件名 del 文件名 删除文件 rm -r 文件名 递归删除（把当前文件夹及其所有后代文件都遍历删除） rm -f 文件名 强制删除(不管文件有没有用到) rm -rf 文件名 递归强制删除（无法还原，删除要慎重慎重慎重） mv 文件名 新文件名 ren 文件名 新文件名 文件重命名 diff 文件名1 文件名2 fs 文件名1 文件名2 比较文件内容 pwd chdir 查看当前路径 grep 字串 文件名 find 字串 文件名 在文件中寻找字串 编辑内容 linux 作用 vi 文件名 修改文件 i 进入命令模式，可修改 esc +:wq 保存并退出 esc +:q! 强制退出 其他 linux DOS 作用 clear cls 清屏 exit exit 关闭和退出 date date 显示或设置日期 echo 执行代码 echo 执行代码 把输出回显到屏幕 echo 内容&gt;文件名 把内容放到文件中，如果没有则创建文件（新存放的内容替换原有内容） echo 内容&gt;&gt;文件名 把内容放到文件中，如果没有则创建文件（在原有内容后新增内容） mke2fs或mformat 网盘名: format 网盘名: 格式化软盘 man 命令/? 显示命令帮助 date time 显示时间 free men 显示已被使用的内存 ctrl + c 终止当前运行的DOS命令 ping www.baidu.com -t 查看当前自己的网络状况 ipconfig/ ipconfig -all 看自己电脑的IP地址 mac下命令行 http://www.iterm2.com/ http://ohmyz.sh/ homebrew brew install git brew install node http://brew.sh/index_zh-cn.html]]></content>
      <categories>
        <category>工具</category>
        <category>cmd</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flexbox]]></title>
    <url>%2F2016%2F12%2F19%2Fflexbox%2F</url>
    <content type="text"><![CDATA[Flexible Box（简称flexbox）布局，是CSS3提供的一种全新的CSS布局方式，拥有很多新的布局特性。 支持任意方向的布局（左，右，下及其上） 支持视觉上的反向和重新布局 支持自适应各种不同空间 可以针对容器对齐 拥有统一的高度 容器属性 采用Flex布局的元素，称为Flex容器（flex container）。它的所有子元素自动成为容器成员，称为Flex项目（flex item）。 容器有主轴和交叉轴组成 12display: flex;display: -webkit-flex; //Safari仍旧需要使用特定的浏览器前缀 flex-direction属性 flex-direction属性来定义布局中子元素的布局方向（主轴方向） 值有column-reverse、column、row、row-reverse。默认值row。效果依次如下 缺省布局（横向布局）flexbox布局中，如果修改子元素宽度，比如，宽度设为300px，不会溢出父元素容器的最大宽度，只会自适应父元素，除非父元素的宽度变化，子元素才会修改自身的宽度来适应。 1234dispaly:flex;display:-webkit-flex;flex-direction: row; //这是布局方向的缺省值 -webkit-flex-direction: row; 纵向布局通过设置flex-direction为column，可以设置flexbox的整体布局为纵向 1234display:flex;display:-webkit-flex;flex-direction:column;-webkit-flex-direction:column; 对齐方式12align-items:flex-end;//纵向布局中水平对齐，flex-end表示居右；横向布局中垂直对齐，表示居下justify-content:flex-end;//纵向布局中垂直对齐，flex-end表示居下；横向布局中水平对齐，表示居右 主轴方向对齐 justify-content——设置主轴方向上的对齐方式 值flex-start、flex-end、center、space-between、space-around，，默认值flex-start 在横向布局中，效果如下 交叉轴方向对齐align-items设置单行在交叉轴方向上的对齐方式 值flex-start、flex-end、center、stretch、baseline，默认值stretch 在横向布局中，效果如下 align-content设置多行在交叉轴方向上的对齐方式，不换行时该属性不起作用。flex-wrap必须设置为wrap和wrap-reverse。 值flex-start、flex-end、center、space-between、space-around，默认值stretch 在横向布局中，效果如下 换行 flex-wrap——设置是否换行 值，如下。默认值nowrap nowrap——不换行 wrap——换行，第一行在上方 wrap-reverse——换行，第一行在下方 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 项目属性排列顺序order——定义项目的排列顺序。数值越小，排列越靠前，默认为0。 项目放大比例flex-grow——定义项目放大比例，默认为0（即使存在剩余空间，也不放大） 当所有项目的flex-grow都为1时，将等分剩余空间，如图 当一个项目flex-grow为2时，其余都为1时，前者占据的剩余空间将比其他项多一倍。，如图 项目缩小比例flex-shrink——定义项目的缩小比例。默认值1（空间不足，项目将缩小） 伸缩项目的基准值flex-basis——定义伸缩项目的基准值，剩余空间按比例进行伸缩（浏览器根据这个属性，计算主轴是否有多余空间）。默认值auto（即项目本来大小）。 flexflex属性是flex-grow, flex-shrink 和flex-basis的简写。flex:&lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt; &lt;&#39;flex-basis&#39;&gt;。后面两个属性可选。默认值0 1 auto flex:auto=&gt;flex:1 1 auto flex:none=&gt;flex:0 0 auto flex:1=&gt;flex:1 1 0% 优先使用flew属性 单个项目交叉轴方向对齐方式align-self——允许单个项目有与其他项目不一样的交叉轴方向对齐方式。默认值auto 值auto、flex-start、flex-end、center、baseline、stretch 计算拉伸的主轴空间计算 先根据各个项目大小计算出剩余的空间 计算出扩展系数总和 每个项目占据空间=本身大小+(项目的扩展系数/扩展系数总和)乘以总剩余空间 收缩的主轴空间计算 计算总的溢出的内容 计算出所有项目基准值乘以收缩系数的总占用值 计算每个项目基准值乘以收缩系数的值每个项目占据空间=本身大小-(项目占用值/总占用值)乘以溢出的内容 兼容性 flex容器123456789101112display: box;/* OLD - Android 4.4- */display: -webkit-box;/* OLD - iOS 6-, Safari 3.1-6 */display: -moz-box;/* OLD - Firefox 19- (buggy but mostly works) */display: -ms-flexbox;/* TWEENER - IE 10 */display: -webkit-flex;/* NEW - Chrome */display: flex;/* NEW, Spec - Opera 12.1, Firefox 20+ */ 主轴设置12345678/* 09版 */-webkit-box-orient: vertical;//横向排列时值是horizontal/* 12版 */-webkit-flex-direction: column;-moz-flex-direction: column;-ms-flex-direction: column;-o-flex-direction: column;flex-direction: column; 排列顺序12345678910webkit-box-ordinal-group: 1;/* OLD - iOS 6-, Safari 3.1-6 */-moz-box-ordinal-group: 1;/* OLD - Firefox 19- */-ms-flex-order: 1;/* TWEENER - IE 10 */-webkit-order: 1;/* NEW - Chrome */order: 1;/* NEW, Spec - Opera 12.1, Firefox 20+ */ 交叉轴方向对齐12345678/* 09版 */ -webkit-box-align: center;/* 12版 */-webkit-align-items: center;-moz-align-items: center;-ms-align-items: center;-o-align-items: center;align-items: center; 主轴方向对齐12345678/* 09版 */-webkit-box-pack: center; /* 12版 */ -webkit-justify-content: center; -moz-justify-content: center; -ms-justify-content: center; -o-justify-content: center; justify-content: center; 换行12345678/* 09版 *//*-webkit-box-lines: multiple;*//* 12版 */-webkit-flex-wrap: wrap;-moz-flex-wrap: wrap;-ms-flex-wrap: wrap;-o-flex-wrap: wrap;flex-wrap: wrap; 项目123456789101112-webkit-box-flex: 1;/* OLD - iOS 6-, Safari 3.1-6 */-moz-box-flex: 1;/* OLD - Firefox 19- */width: 20%;/* For old syntax, otherwise collapses. */-webkit-flex: 1;/* Chrome */-ms-flex: 1;/* IE 10 */flex: 1;/* NEW, Spec - Opera 12.1, Firefox 20+ */]]></content>
      <categories>
        <category>CSS</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2016%2F11%2F21%2FjQuery%2F</url>
    <content type="text"><![CDATA[原生JS封装成的一个库，zepto是jQuery的移动端小型化版本 版本 jquery-1.xxx （第一个版本，兼容所有浏览器） jquery-2.xxx （第二个版本，在IE6，7，8下不兼容） jquery-3.xxx （第三个版本，在IE6，7，8下不兼容） jQuery原理123jQuery = function( selector, context ) &#123; return new jQuery.fn.init( selector, context );&#125;; selector : 是个参数，选择器context: 上下文window.jQuery = window.$ = jQuery;jQuery 是一个方法，又是一个类$(&quot;.first&quot;) 是一个jQuery实例 extend扩展jQuery 方法123456jQuery.fn.extend(&#123; aa:function () &#123; console.log(1) &#125;&#125;);$(".first li").aa() jQuery 的extend 方法 ，是用来扩展jQuery 的方法 jQuery选择器DOM 是元素节点组成的 原声js中获取元素对象的方式document.getElementsByClassName(&quot;first&quot;) 在IE6、7、8下不兼容document.getElementById(&quot;div&quot;);兼容IE6、7、8document.getElementsByTagName(&quot;*&quot;) （获取document下所有元素对象）兼容IE6、7、8 基本选择器 参数 描述 &quot;#first&quot; 通过ID名来获取 &quot;.first&quot; 通过类名来获取 &quot;div&quot; 通过标签名来获取 &quot;#first,.oUl&quot; 并集选择 层级选择器 参数 描述 #first .oUl 获取后代所有元素对象 &quot;#first&gt;.oUl&quot; 获取下一级的元素对象（紧邻的父子关系） &quot;#first+&quot; 获取同级下紧邻的弟弟元素对象 &quot;.first+div&quot; 获取同级下紧邻的div标签的弟弟元素对象 &quot;.first~ &quot; 获取同级下所有的弟弟元素对象 &quot;.first~div&quot; 获取同级下所有div标签的弟弟元素对象 基本筛选器排除 参数 描述 &quot;:not(selector)&quot; 去除所有与给定选择器匹配的元素 操作索引 参数 描述 &quot;.first:first&quot; 第一个class名为first的元素 &quot;.first:last&quot; 最后一个class名为first的元素 &quot;.first:even&quot; 索引为偶数的class名为first的元素 &quot;.first:odd&quot; 索引为奇数的class名为first的元素 &quot;.first:eq(0)&quot; 索引为0的class名为first的元素 &quot;.first:gt(2)&quot; 索引大于2的class名为first的元素 &quot;.first:lt(2)&quot; 索引小于2的class名为first的元素 内容 参数 描述 &quot;:contains(&#39;珠峰&#39;)&quot; 获取所有元素内容包含“珠峰”的元素 &quot;:empty&quot; 获取所有不包含子元素或文本的空元素 &quot;:parent&quot; 获取所有包含子元素或文本的非空元素 &quot;:has(.first)&quot; 获取所有后代元素中包含类名为first元素的元素 可见性 参数 描述 &quot;:hidden&quot; 获取所有不可见元素，type为hidden &quot;:visible&quot; 获取所有可见元素 属性 参数 描述 &quot;[attribute]&quot; 获取带有attribute属性的元素 &quot;[attribute=value]&quot; 获取attribute属性值为value的元素 &quot;[attribute^=value]&quot; 获取attribute属性值以value开始的元素 &quot;[attribute$=value]&quot; 获取attribute属性值以value结尾的元素 &quot;[attribute*=value]“ 获取attribute属性值包含value的元素 子元素 参数 描述 &quot;:first-child&quot; 查找父元素中第一个子元素是某类型的的元素 &quot;:first-of-type&quot; 查找父元素中第一个某类型的子元素 &quot;:last-child&quot; 查找父元素中最后一个子元素是某类型的的元素 &quot;:last-of-type&quot; 查找父元素中最后一个某类型的子元素 &quot;:nth-child&quot; 查找父元素中第n个子元素是某类型的的元素 &quot;:nth-of-type&quot; 查找父元素中第n个某类型的子元素 &quot;:nth-last-child&quot; 查找父元素中倒数n个子元素是某类型的的元素 &quot;:nth-of-type&quot; 查找父元素中倒数n个某类型的子元素 &quot;:only-child&quot; 查找父元素中唯一的子元素是某类型的的元素 &quot;:only-of-type&quot; 查找父元素中唯一的某类型的子元素 表单选择器（type属性值） 参数 描述 &quot;:input&quot; &quot;:text&quot; &quot;:password&quot; &quot;:password&quot; &quot;:radio&quot; &quot;:checkbox&quot; &quot;:submit&quot; &quot;:image&quot; &quot;:button&quot; &quot;:reset&quot; &quot;:file&quot; 表单过滤器选择器 参数 描述 &quot;:enabled&quot; &quot;:disabled&quot; &quot;:checked&quot; &quot;:selected&quot; 其他 参数 描述 &quot;:header&quot; 获取所有h1~h6的标题元素 &quot;:animated&quot; 匹配所有正在执行动画效果的元素 &quot;:focus&quot; 匹配当前获取焦点的元素 &quot;:image&quot; 匹配所有图像域 &quot;:animated&quot; 匹配所有正在执行动画效果的元素 常用方法属性操作方法 参数 描述 &quot;toggleClass &quot;addClass &quot;removeClass &quot;attr &quot;removeAttr zepto(移动端的小型的jQuery)zepto和jQuery的不同 jQuery zepto 在PC端使用，里面包含了大量的对于IE低版本浏览器的兼容处理 应用于移动端开发，对IE版本浏览器不支持 提供了很多的选择器，以及DOM的操作方法 实现了部分常用的选择器和方法 动画的方法：animate、hide、show、toggle、slide、Down、slideUp、slideToggle、fadeIn、fadeOut、fadeToggle… 只有animate zepto常用的事件操作tap、singleTap、doubleTap、longTap、swipe、swipeUp、swipeDown、swipeLeft、swipeRight]]></content>
      <categories>
        <category>JavaScript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX和JSONP]]></title>
    <url>%2F2016%2F11%2F17%2FAJAX%E5%92%8CJSONP%2F</url>
    <content type="text"><![CDATA[AJAX、JSONP原理、同源非同源区别、同步异步、GET和POST区别 JSONP和AJAX相同，都是客户端向服务器发送请求；给服务器传递数据，从服务端获取数据的方式； AJAX 属于同源策略 JSONP 属于非同源（跨域请求） 同源和非同源的区别 协议 域名或者IP 端口号 以上的三个条件完全相同属于同源策略，使用AJAX获取数据，只要一个不一样属于非同源吗，我们使用JSONP获取数据 AJAX(同源策略)async javascript and xml ：异步的js和xml一种用于创建快速动态网页的技术 创建一个ajax 的对象var xhr=new XMLHttpRequest(); 这种方式在IE6及以下的低版本浏览器是不兼容的 初始化xhr.open(&quot;get&quot;,&quot;./data.txt&quot;,true) 请求方式 方法 用法 GET 向服务器 获取资源 POST 向服务器 发送数据 DELETE 从服务器上 删除资源 HEAD 仅向服务器获取响应头 ,不要响应体 PUT 更新 服务器上的一个资源 OPTOINS 获取服务器上可以支持的方法 GET和POST区别 资源大小限制。浏览器对URL有长度限制，所以GET将数据拼接在URL后端query部分，数据有大小限制；而POST将数据放在请求主体里，数据没有大小限制 GET可以看到发送给服务器的数据，而POST不会看到，所以一般情况下GET不安全，POST相对安全一些； GET主要从服务器拉取数据，POST主要将数据发送到服务器 GET请求会出现缓存，POST是没有缓存的 在项目中怎么让GET请求不让其走缓存：在URL的末尾加一个随机数xhr.open(&quot;get&quot;,&quot;/index.html?_=&quot;+Math.random()) 同步异步 true：异步,，默认是true false：同步 ajax对象监听12345xhr.onreadystatechange=function () &#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; data=xhr.responseText &#125;&#125; 给xhr这个ajax 对象的onreadystatechange这个属性绑定一个方法，监听状态的改变（只要状态发生改变就会执行） readyStateajax对象状态值 值 含义 0(unsent) 对象已建立，但是尚未初始化（尚未调用open方法） 1(opened) 已初始化，未发送（尚未调用send方法） 2(headers_received) send方法已调用，响应头和响应状态已经返回 3(loading) 服务器正在进行处理，响应体下载中，这时通过responseBody和responseText获取部分数据会出现错误 4(done) 数据接收完毕,整个请求过程已经完毕，此时可以通过通过responseXml和responseText获取完整的回应数据 status和statusTextstatus：从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）statusText：伴随状态码的字符串信息 状态码 解释 200或者以2开头 响应体的内容已经成功返回 301 永久重定向/永久转移 302 临时重定向/临时转移 303、307 重定向到一个负载不大的服务器上（服务器的负载均衡或失联） 404 客户端访问的地址不存在 500 服务器错误 503 服务器已经超负荷 responseText和responseXMLresponseText：从服务器进程返回数据的字符串形式。responseXML：从服务器进程返回的DOM兼容的文档数据对象。 发送请求xhr.send()send中参数： 参数是请求主体中传递给服务器的内容 同步和异步JS 是单线程的，不能同时执行两个任务，定时器是异步编程，事件的绑定都是异步编程的 Ajax中的同步： 当ajax这个任务开始的时候，xhr.send(),一直需要到readyState ===4的时候这个任务才算结束；此时才可以处理其他的事情 Ajax的异步 ： 当ajax这个任务开始的时候，xhr.send(), 不需要到readyState ===4；我们依然可以执行其他的任务，并且只有当其他的任务完成后，我们来看当前的readyState是否等于4 谷歌浏览器下识别定时器最小的时间单位5-6ms;定时器设置成0，定时器不会马上执行 定时器设定好时间，不一定到时间就执行，如果当前的浏览器的线程被占用，定时器就需要等到浏览器另一个线程结束才可以执行 如果有多个定时器，如果执行下面的代码定时器已经到达时间，先执行时间短的那个定时器 ajax异步优缺点优点 1、页面无刷新，在页面内与服务器通信，给用户的体验非常好。 2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 4、基于标准化（xml和json）的并被广泛支持的技术，不需要下载插件或者小程序。 5、进一步促进页面和数据的分离。 缺点 1、AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性。 2、AJAX只是局部刷新,所以页面的后退按钮是没有用的。 3、对流媒体还有移动设备的支持不是太好等。 4、对搜索引擎的支持比较弱。 JSONP(非同源、跨域请求)JSON原理&lt;script&gt;不管是否是同源还是非同源，都能拉取到相应的数据，只要给src一个合理的路径，&lt;script&gt;标签都可以吧对应的内容请求到 首先把需要的数据对应的那个请求地址赋值给&lt;script&gt;的src属性 把当前页面中的某一个函数名当做参数值，传递给服务器（url的问号传参：?） 当服务器接受到这个请求的后，需要进行特殊的处理，把你传进来的函数名和你需要的数据拼接成一个字符串 比如： 传进去的函数名是fn，它准备好的数据fn([{&quot;hello&quot;：&quot;你好&quot;}]) 服务器把准备的的数据通过HTTP 协议返回给我们客户端，客户端发现其实就是让定义的这个方法fn执行，而且还给fn传递一些数据，数据是我们需要的 12345678&lt;script&gt; function fn (data) &#123; console.log(data) &#125;&lt;/script&gt;&lt;script charset="utf-8" src="http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&amp;callback=fn"&gt;&lt;/script&gt;&lt;!--控制台输出数据--&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>http</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2016%2F11%2F15%2Fhttp%2F</url>
    <content type="text"><![CDATA[超文本传输协议 ，除了可以传输文本，还可以传输其他的东西 XML (自定义的标签) 客户端给服务器的内容和服务器给客户端的内容都是通过http协议进行传输的 服务器能在特定IP(服务器)的特定端口上监听客户端的请求，并根据请求的路径返回相应结果都叫服务器 服务器可以是专业服务器也可以是个人电脑 防篡改：web服务器一旦被攻击，在内网的服务器在0.0n秒会覆盖在web服务器上 负载均衡：把一些用户做分流 vpn：翻墙 客户端只要能向 IP(服务器) 的特定 端口 发起请求 并 接受响应 的都叫客户端 可以是mac、iphone、ipad、apple等等 数据的传递 可以把服务器硬盘上已经有的静态文件发送给客户端 也可以由服务器经过逻辑处理生成的动态内容 返回给客户端，比如 当前时间 一个http事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成 http和httpshttp 人与人之间通信，需要一种传输手段 (声波)和一种彼此都懂的 语言 （比如普通话） 要让这些形形色色的机器能够通过网络进行交互，我们就需要指明一种协议 (比如HTTP/HTTPS)和一种数据封装格式 (比如 HTML/JSON) http指的就是指的就是这种协议+数据格式的交流体系。 https确保安全的HTTPSHTTP+加密+认证+完整性保护=HTTPS 网站的访问流程发送请求 浏览器(或其它客户端如微信)向服务器发出一个HTTP请求 先把域名解析为IP地址 chrome缓存1分钟(chrome://netinternals/#dns) 搜索操作系统缓存 读取本地host文件 发起DNS系统调用 运营商DNS缓存 客户端通过特定端口向服务器发起TCP三次握手,建立了TCP连接 连接建立后浏览器就可以发送HTTP请求 了 服务器接收到HTTP请求，解析请求的路径和参数，经过后台的一些处理之后生成完整响应页面 服务器将生成的页面作为HTTP响应体 ，根据不同的处理结果生成响应头 ，发回给客户端 服务器的端口号（0-65535）https：默认的端口是443；http : 默认的端口都是80ftp ： FTP 默认去找服务器的21端口 得到相应 客户端（浏览器）接收到HTTP 响应,从请求中得到的HTTP 响应体里是HTML代码，于是对HTML代码开始解析 解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向服务器发送请求 浏览器解析HTML包含的内容，用得到的 CSS 代码进行外观上的进一步渲染 ，JS 代码也可能会对外观进行一定的 处理 当用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画 交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新）,一般不是跳转就是通过 JS 代码(响应某个动作或者定时)向服务器发送 AJAX 请求 服务器再把客户端需要的资源返回，客户端用得到的资源来实现动态效果或修改DOM结构 。 请求方式发送HTTP的方法有许多种，最常用的便是GET和POST，下面就这两种进行详细地说明。 GETGET方法用来请求访问URI所指定的资源，（我想访问你的某个资源）并不对服务器上的内容产生任何作用结果； 每次GET的内容都是相同的。 GET方式把请求所需要的参数放到URL中，直接就可以在URL中看见，有大小限制。 POSTPOST方法用来传输实体主体，目的并不是获取响应的主体内容，（我要把这条信息告诉你） POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。 GET和POST总结 GET用于获取某个内容 POST用于提交某种数据请求。 按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式； 而针对某一内容的查询，为了快速的响应，可以使用GET方式。 其他常用方法 方法 用法 GET 向服务器 获取资源 POST 向服务器 发送数据 DELETE 从服务器上 删除资源 HEAD 仅向服务器获取响应头 ,不要响应体 PUT 更新 服务器上的一个资源 OPTOINS 获取服务器上可以支持的方法 常见的状态码 状态码 解释 200或者以2开头 响应体的内容已经成功返回 301 永久重定向/永久转移 302 临时重定向/临时转移 303、307 重定向到一个负载不大的服务器上（服务器的负载均衡或失联） 404 客户端访问的地址不存在 500 服务器错误 503 服务器已经超负荷 查询字符串]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端事件]]></title>
    <url>%2F2016%2F11%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[click、load、scroll、blur 、focus、change、touch事件类型、gesture事件类型 clickclick在移动端 是属于单击事件，不是点击事件，移动端的浏览器在识别click的时候，只有确定当前是单击才会执行 在移动端是使用click会存在300ms 延迟，浏览器在第一次点击结束后，等300ms看是否触发了第二次点击，如果是第二次点击了，就不属于click了，没有点击第二次，才属于click； 解决导致的300ms延迟的问题： 1234&lt;script type="text/javascript" src="fastclick.min.js"&gt;&lt;/script&gt;&lt;script&gt; FastClick.attach(document.body);&lt;/script&gt; touch事件类型 （处理单手指操作） touchstart：使用touchstart实现点击的操作 touchmove：只有当触摸发生移动才会执行 touchend：只有当触摸结束时才会执行 touchcancel：可由系统进行的触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch的行为，则可以触发该事件 touchEvent属性： type：事件类型 target：事件源 cancelBubble：阻止冒泡传播机制 returnValue：阻止默认行为 touches：手指信息的集合 touches获取到值的必备条件：只有手指还在屏幕上才可以获取到 changedTouches：所以在touchend事件中获取离开瞬间鼠标的这个信息只能使用changedTouches获取 tap事件类型触碰事件，我目前还不知道它和touch的区别，一般用于代替click事件 tap：手指碰一下屏幕会触发 longTap：手指长按屏幕会触发 singleTap：手指碰一下屏幕会触发 doubleTap：手指双击屏幕会触发 swipe事件类型滑动事件 swipe：手指在屏幕上滑动时会触发 swipeLeft：手指在屏幕上向左滑动时会触发 swipeRight：手指在屏幕上向右滑动时会触发 swipeUp：手指在屏幕上向上滑动时会触发 swipeDown：手指在屏幕上向下滑动时会触发 gesture事件类型（处理多手指的操作） gesturestart：当有两根或多根手指放到屏幕上的时候触发 gesturechange：当有两根或多根手指在屏幕上，并且有手指移动的时候触发 gestureend：当倒数第二根手指提起的时候触发，结束gesture]]></content>
      <categories>
        <category>JavaScript</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>web</tag>
        <tag>webView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS表单事件汇总]]></title>
    <url>%2F2016%2F11%2F13%2FJS%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[JS表单事件汇总 事件 描述 onabort 当用户终止正在打开的网页时产生该事件。 onblur 某元素失去活动焦点时产生该事件。例如鼠标在文本框中点击后又在文本框外点击时就会产生。 onchange 当网页上某元素的内容发生改变时产生。例如在文本框中输入文本后又在文本框外点击时就会产生。 onclick 单击网页上的某元素时产生 ondblclick 双击网页上的元素时产生 onerror 浏览器在打开网页的过程中发生错误时产生该事件 onfinish 滚动文本条中的文本完成一次滚动时产生的事件 onfocus 网页上的元素获得焦点时产生该事件 onkeydown 按下任意键时产生该事件 onkeypress 按下任意键时并释放该键产生的事件 onkeyup 释放按下的按键产生该事件 onload 网页或图象调入完成后产生该事件 onmousedown 在网页的某元素上按下鼠标时产生该事件 onmousemove 在网页的某元素上移动鼠标时产生该事件 onmouseout 从网页的某元素移出鼠标时产生该事件 onmouseover 鼠标移入网页的某元素时产生该事件 onmouseup 释放按下的鼠标时产生该事件 onreset 复位表格时产生该事件 onresize 改变浏览器时产生该事件 onselect 选择文本框中的文本时产生该事件 onstart 滚动文本条中的文本开始滚动时产生该事件 onsubmit 提交表单时产生该事件 onunload 从当前的网页退出时产生该事件]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github基础]]></title>
    <url>%2F2016%2F10%2F07%2Fgithub%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[gitHub是一个面向开源及私有软件项目的托管平台，只支持git作为唯一的版本库格式进行托管 1、新建存储库 1 2 自带一个分支master 2、创建分支.gif) 3、修改某分支上的文件 在xxx分支上，点击xxx文件。 点击文件视图的右上角的铅笔图标。 进行编辑 编写一个描述更改的提交消息。 单击提交更改按钮。 4、申请合并分支（打开拉请求） 1、点击拉请求选项卡，然后从拉取请求页面，单击新建请求按钮 .gif) 2、在“ 示例比较”框中，选择更改的分支与要合并上去的分支进行比较。 3、查看比较页面上的差异更改，确保它们是您要提交的 4、点击创建创拉请求按钮 5、给你的拉请求一个标题，并写一个简短的描述你的更改。 5、合并您的拉请求 1、单击绿色合并拉取请求按钮将更改合并到master。 2、单击确认合并。 3、继续删除分支，因为它的更改已被合并，并且紫色框中的删除分支按钮。]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基础]]></title>
    <url>%2F2016%2F10%2F06%2Fgit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[git常用命令 提交文件到自己的远程仓库本地文件准备 1、git init——初始化git（添加.git文件夹） 2、touch .gitignore——添加忽略文件，没有后缀 3、touch README.md——添加README.md文件，一般每个项目都会有README.md文件 .gitignore是需要提交到github上的 忽略文件：不需要传输共享的文件（常见如.idea、node_modules、.DS_Store） 空文件夹不会被提交 一般会在空文件夹下 创建.gitkeep文件，保证空文件夹也可以提交 关联、取消关联、查看远程仓库 命令 作用 git remote add 别名 地址 关联远程仓库 git remote -v 查看远程仓库 git remote rm 别名 取消关联远程仓库 for example： 123git remote add origin https://github.com/liuxinyi1992/gitExamplegit remote rm origin 向远程仓库提交代码 1、保证本地 工作区、暂存区、历史区版本一致 如果线上线下版本不统一，执行2，不然不需要 2、git pull 仓库别名 分支名 3、git push 仓库别名 分支名 强制覆盖掉线上文件（不建议用）1git push origin master --force 发布静态页 发布到指定的分支上gh-pages 将要发布的静态页推送到此分支上即可 1234git checkout -b gh-pagesgit add .git commit -m 'static page'git push origin gh-pages 获取别人仓库文件线上——fork 叉子 可以将别人的代码，变成自己的代码，别人代码更新不会导致自己的仓库代码更新，可以更改这个人的代码发送合并请求 线下——克隆仓库1git clone 别名 地址 同步线上代码$ git remote update 仓库别名——打通和这个仓库的通道$ git pull 仓库别名 分支名——拉取仓库的代码 SSH配置单个SSH-Key window用户目录下新建.ssh目录：c:\Users\userName\.ssh cmd进入.ssh文件夹下：cd c:\Users\userName\.ssh 生成ssh-key：ssh-keygen -t rsa -C &quot;yourEmail1@163.com&quot; 输入ssh-key文件名及保存路径，不填回车默认当前目录下保存为id_rsa 输入密码，不设置则不填回车即可 确认密码，没有密码不填回车即可 必须以系统管理员权限运行cmd，否则不能生成ssh-key文件 复制.pub文件内容，去GitHub等平台添加ssh-key 多个SSH Key 同单个ssh-key配置，生成第二个ssh-key 注意Enter file in which to save the key:这一步一定要重新命名，否则会覆盖原来的ssh-key 在.ssh目录下创建config文件，如下配置每一个ssh-key Host：名称，最好与仓库默认SSH地址git@${Host}:xxx/xxx.git中Host部分一致，一般即与HostName一致 HostName：平台域名或IP IdentityFile：ssh-key文件绝对路径 User：用户名 123456789101112# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile C:/Users/popfisher/.ssh/company_rsa User git# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile C:/Users/popfisher/.ssh/id_rsa_github User git 检查是否配置成功：ssh -T git@github.com @后面是Host 需要管理员权限执行，过程中需要输入yes 出现最后一行就代表配置成功 本地操作设置本地git用户名和邮箱 命令 作用 git config --list git config --global user.name 用户名 用户名 git config --global user.email 邮箱 邮箱 初始化git(添加.git)和删除.gitwho are you——告诉git的管理范围 初始化时 切记不要在桌面初始化 具体到某个文件夹内,不能git套git 命令 作用 git init 初始化git(添加.git) rm -rf .git 删除.git 工作区、暂存区、历史区本地提交版本，工作区-&gt;暂存-&gt;历史区，依次提交 添加到暂存区 命令 作用 git add . 将所有文件添加到暂存区 git add -A 将所有文件添加到暂存区 git add 文件名 将某个文件添加到暂存区 添加到历史区 命令 作用 git commit -m&#39;名称&#39; 将所有文件添加到历史区创建新版本 git commit -a -m&#39;名称&#39; 将所有文件添加到暂存区和历史区创建新版本（连写提交） 使用连写提交前，这个文件必须先提交过一次才可以 查看版本信息 命令 作用 git log 查看版本信息 git log --grep 名称 查看这个名称的版本信息 git log --author 用户名或邮箱 查看这个用户名或邮箱的版本信息 git reflog 查看所有日志 git log --graph 查看提交树 比较工作区、暂存区、历史区的不同 命令 作用 git diff 比较工作区和暂存区 git diff --cached 比较暂存区和历史区的不同 git diff master 比较工作区和历史区的不同 回滚 命令 作用 git checkout 文件名 用暂存区回滚工作区的内容 git reset HEAD 文件名 暂存区恢复前一个版本并且回滚工作区内容 git reset --hard 版本id 用历史区区某个版本回滚暂存区和工作区内容 查看状态 命令 作用 git status 查看状态 红色——工作区更改，未提交暂存区和历史区绿色——更改已提交暂存区，未提交历史区没有颜色——工作区、暂存区、历史区内容一致 分支分支管理 默认没有分支，只有提交过（添加到历史区）才拥有分支 只要提交一次就有分支了 分支的增删改查 命令 作用 git branch 查看分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换 git branch -D dev 删除分支 分支开发 在开发时，需要将内容提交到具体的分支上才可以 在某个分支上提交后在更改，想切换分支，是不允许的（分支上的工作区，暂存区，历史区内容一致才能切换），解决办法： 第一种，提交到历史区后在切换 第二种，暂存起来，git reset --hard 版本id用历史区的某个版本将工作区和暂存区覆盖掉，此时没有修改就可以切换了 合并分支 命令 作用 git merge 要合并的分支名 合并分支 合并前切换回要保留的分支如果有冲突修复冲突 在次提交 暂存 命令 作用 git stash 暂存更改 git statsh pop 恢复暂存 简单示意图]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2016%2F10%2F04%2FDOM%2F</url>
    <content type="text"><![CDATA[浏览器中的javascript引擎使JS代码有调用DOM接口和CSSOM接口的能力 DOM的映射 映射：在js中，操作元素集合，元素集合中的每一项和页面中DOM结构的元素是一一对应的； 只能当页面结构中的元素改变时，元素集合类数组（）中的项才会改变（如顺序，数据等）全局只需获取一次，当页面结构中元素增删时，获取的元素集合类数组中的相应项一样会增删 DOM的回流机制页面中删除元素，新增元素，元素换位置，浏览器都要对页面DOM的结构进行重新的计算，非常消耗性能。 重绘在JS中，改变元素的样式（css），浏览器需要对元素进行重新的渲染，这就叫重绘 表格元素获取12345var oTab=document.getElementById("tab");var tHead=oTab.tHead;//获取表头（唯一）var oThs=tHead.rows[0].cells;//获取表头中第一行的所有列（类数组）var tBody=oTab.tBodies[0];//var rows=tBody.rows;//第一个body中所有行（类数组） tHead：获取表头rows：获取行cells：获取表格中某一行的列tBodies[0]：获取表格中的第一个body 数据绑定字符串拼接12345var str = "";for(var i=0;i&lt;data.length;i++)&#123; str += "&lt;li&gt;" +data[i]+"&lt;/li&gt;";&#125;oUl.innerHTML += str; 添加节点缺点：添加多个节点引发多次回流，消耗性能 文档碎片优点 ： 引发一次回流 12345678var frg = document.createDocumentFragment();// 创建一个文档碎片 for(var i=0;i&lt;data.length;i++)&#123; var li =document.createElement("li"); li.innerHTML = data[i];// 绑定数据 frg.appendChild(li); &#125; oUl.appendChild(frg); frg = null;//手动释放内存 JS盒模型（只读属性，不可以设置 ） clientWidth/clientHeight：padding+内容 clientTop/clientLeft：border-top/border-left offsetWidth/offsetHeight：clientWidth/clientHeight+border左右/上下 scrollWidth/scrollHeight 在内容没有溢出的情况下：scrollWidth/scrollHeight=clientWidth/clientHeight 有溢出的情况下： scrollWidth/scrollHeight=溢出内容的宽/高+clientWidth/clientHeight(=padding-left/top+正式内容宽高) 偏移量偏移量：当前元素的边框外边缘距离父级参照物的边框内边缘的距离 在xp系统的IE8浏览器中，偏移量是当前元素的边框外边缘距离父级参照物的边框外边缘的距离 参照物：offsetParent（父级参照物）如果不做任何处理的情况下，元素对象对应的父级参照物默认都是body 在IE7下，如果给body的子元素加上定位，那么当前元素的父级参照物就是HTML，如果不加定位，那么还是body offsetLeft/offsetTop：左偏移/上偏移（只读属性）当前元素（左/上）边框距离父级参照物的距离修改父级参照物：想让谁成为其他元素的父级参照物，，就在它的css属性中加上position属性 scrollTop/scrollLeft（读写属性，可以修改设置）scrollTop：是滚动条卷去的高度scrollLeft：是滚动条卷去的宽度 documentElement/body 不同浏览器识别不同，都要写 获取元素自定义属性getAttribute通过名称获取属性的值 1curEle.getAttribute("自定义属性名") js中获取样式（只读）oDiv.style.attr：只针对行内样式 弊端：只能获取行内式中&lt;style&gt;样式，无法获得css中样式 getComputedStylewindow.getComputedStyle(元素对象)[&quot;属性名&quot;]：获取浏览器计算的样式 不兼容IE6，7，8 currentStyle(只兼容IE)元素对象.currentStyle[&quot;属性名&quot;] onload加载成功时执行方法 123imgNew.onload=function () &#123; img.src=trueAddress;&#125;; 事件事件 ： 浏览器天生给元素提供了一些事件 事件 描述 onclick onmouseover onmouseout onmouseenter onmouseleave onmousemove onload onscroll onmousewheel 鼠标滚轮滚动出发 onfocus 获取鼠标焦点 onblur 失去鼠标焦点 onresize 改变窗口大小 onmousedown 鼠标按下 onmouseup 鼠标抬起 onkeydown 键盘按下 onkeyup 键盘抬起 如果没有绑定任何方法，那么事件是执行了，只是什么都没做 DOM0级事件onclick、onmouserover、onmousemove…这些方法绑定到当前的元素上，只能给元素对象的一个事件行为绑定一个方法，第二次绑定会把第一次绑定的覆盖掉 1234567oBox.onclick = function (e) &#123; console.log(1)&#125;oBox.onclick = function (e) &#123; console.log(2)&#125;//结果只输出2 DOM2级事件1234567oBox.addEventListener("click",function (e) &#123; console.log(1)&#125;,false)oBox.addEventListener("click",function (e) &#123; console.log(2)&#125;,false)//结果输出1 2 元素通过原型链找到EVentTarget 这个类的原型上的addEventListener方法，可以给一个行为绑定多个方法 参数 ： 第一个： 事件的行为，这个参数前面不带“on” 第二个 ： 要给事件绑定的方法 true / false false：事件进行冒泡传播时进行操控的 true：是在事件捕获阶段进行操控的 先捕获，然后在冒泡传播 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt; &lt;div id="center"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var outer = document.getElementById("outer") var inner = document.getElementById("inner") var center = document.getElementById("center") var body =document.body; body.addEventListener("click",function () &#123; console.log("body","冒泡") &#125;,false) body.addEventListener("click",function () &#123; console.log("body","捕获") &#125;,true) outer.addEventListener("click",function () &#123; console.log("outer","冒泡") &#125;,false); outer.addEventListener("click",function () &#123; console.log("outer","捕获") &#125;,true) inner.addEventListener("click",function () &#123; console.log("inner","冒泡") &#125;,false) inner.addEventListener("click",function () &#123; console.log("inner","捕获") &#125;,true) center.addEventListener("click",function () &#123; console.log("center","冒泡") &#125;,false); center.addEventListener("click",function () &#123; console.log("center","捕获") &#125;,true)&lt;/script&gt;//body 捕获 -&gt; outer 捕获 -&gt; inner 捕获 -&gt; center 冒泡 -&gt; center 捕获 -&gt; inner 冒泡 -&gt; outer 冒泡 -&gt; body 冒泡 removeListener：给一个行为解绑方法 IE678 下不兼容 兼容IE6，7，8浏览器的2级事件绑定方法绑定方法：attachEvent移除绑定：detachEvent 参数： 第一个参数： 加”on” 第二个：要绑定或解绑的方法 DOM2级兼容问题 顺序： 标准浏览器中，给一个元素的一个事件行为绑定多个方法，方法执行的顺序和绑定顺序是一致的，但是IE678 是乱序的 this： 标准浏览器方法中的this指向当前被绑定的元素，但是iE678this指向window 重复： 标准浏览器对一个元素的一个事件行为绑定多次同一个的方法（空间地址相同），浏览器会把重复的过滤掉，但是IE678是不进行过滤处理的，绑定了重复的方法也都会执行 事件对象e事件对象：在绑定事件的时候，浏览器会默认给当前绑定方法传进一个参数（这个参数一般用e来接收）,这个参数是一个对象数据类型的值，里面包含了当前点击的一些信息 在IE678下，事件对象没有在绑定的这个方法的参数中，而是放在全局下的window的一个属性上 ，属性名是event 事件源e.target事件绑定在哪个元素对象上，那么元素对象就是当前事件的事件源——e.target 在IE678 不兼容的，事件源是window.event.srcElement 鼠标点击位置 clientX : 当前鼠标点击的位置，距离浏览器窗口左边的距离 clientY： 当前鼠标点击的位置，距离浏览器窗口上边的距离 pageX: 当前鼠标点击的位置，距离页面左边或者是body 的左边的距离(在IE678 下不存在) pageY: 当前鼠标点击的位置，距离页面顶部或者是body 的顶端的距离(在IE678 下不存在) 1234e = e || window.event;e.target=e.target||e.srcElement;e.pageX = e.pageX || (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft));e.pageY = e.pageY || (e.clientY + (document.documentElement.scrollTop|| document.body.scrollTop)); 事件默认行为&lt;a&gt;标签点击，实现连接自动跳转，这是&lt;a&gt;的默认的事件行为 组织事件默认行为12e = e || window.event;e.preventDefault? e.preventDefault():e.returnValue=false; 或者return false 在IE678 下面不存在preventDefault 这个方法，但是存在returnValue这个属性 事件传播机制事件的冒泡传播机制：当触发center的click事件时，父级的click事件也会跟着触发，依次向上，依次触发 先捕获，然后在冒泡传播 阻止事件的冒泡传播12e = e||window.event;e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true; onmouseenter和onmouseover onmouseenter会默认阻止事件的冒泡传播机制 onmouseover 不会默认阻止事件的冒泡传播机制 onmouseout和onmouseleave onmouseleave会默认阻止事件的冒泡传播机制 onmouseout不会默认阻止事件的冒泡传播机制 事件委托事件委托的原理： 利用事件冒泡传播的机制，给最外层的元素的某个行为绑定相应的方法，当里面元素的行为触发的时候，外层的对应的行为也会跟着触发，只要对当前事件源进行判断，进行不同的处理，实现相应的功能 鼠标丢失解决 问题：当鼠标移动过快，盒子跟不上鼠标的速度，导致鼠标丢失，当鼠标抬起时，并没有执行标题的鼠标抬起事件，当下次再次划入这个标题时，会继续执行move这个方法 解决： 在IE和火狐浏览器下，有个setCapture 这个方法，会把鼠标和元素绑定在一起 在谷歌浏览器中，鼠标永远在document这个里面，由于事件冒泡传播的机制，所以给document绑定onmousemove onmouseup window.onload只有页面中HTML结构，图片、文字等所有资源加载完成才会执行这个方法，在页面中只能执行一次 jQuery中$(document).ready()只要页面中HTML结构加载完成，就会执行这个操作（一个页面可以使用多次）]]></content>
      <categories>
        <category>JavaScript</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5深入]]></title>
    <url>%2F2016%2F10%2F04%2FES5%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[内存、预解释、作用域、面向对象、正则、JSON数据、DOM机制、JS盒模型、DOM0级事件、DOM2级事件 编程语言分类强类型编程语言变量类型固定，内存空间大小固定，不能改变如java、c++等语言 内存堆内存存储对象数据类型 把对象数据类型的属性值属性名存进去 把function里面的代码当作字符串存进去 栈内存存储基本数据类型 内存释放堆内存释放存储对象数据类型，对象把属性名和属性值存储进去，函数把函数代码当作字符串存进去 谷歌：每隔一段时间，检查当前这个堆内存是否被外界占用，如果被占用，不进行处理；如果没有被占用，则浏览区会对内存进行回收释放 IE和火狐：每当一个东西占用这个堆内存，那么浏览器会进行计数，每多一个占用则+1，占用结束则-1，当减到0，浏览器对这个堆内存进行回收释放 优化：在代码中，手动清空对象，赋值null，那么相当于清空内存了 栈内存释放全局作用域和私有作用域，存储基本数据类型 全局作用域在页面打开的时候形成，只有当页面关闭的时候，栈内存才会回收 私有作用域：在函数执行的时候，形成私有作用域，执行完成后，当前的私有作用域才销毁 函数执行不止一次时，每完成一遍，该次的私有作用域销毁，下次执行时，形成新的私有作用域当函数执行return的结果为引用数据类型的，且被外界变量接收，则该私有作用域不能被销毁 预解释和作用域 当HTML加载页面时，整个js代码执行前，会形成一个全局作用域，会把全局作用域下的带var和function关键字的进行提前声明——预解释 declear（声明）：给变量开一个内存空间 define（定义，俗称赋值）：给数据开一个内存空间，并让变量和数据关联起来。 var：在预解释的时候，只进行提前的声明，没有定义（只声明不定义时，变量的值为undefined） function：在预解释的时候，不仅进行声明，还进行了定义（赋值） 在全局作用域下，如果没有被var或function，那么相当于给window新增一项属性，属性名是“=”左边的值，属性值是“=”右边的值 windowwindow是个对象 在全局作用域下定义的变量，相当于给window增加了一个属性（包含属性名和属性值）（window可以省） 在私有作用域下定义的变量，和全局没有任何的关系 全局作用域当HTML加载页面时，整个js代码执行前，会形成一个全局作用域 私有作用域（闭包） 只有当函数执行时才会形成，并且执行时先对该作用域下的var和function进行预解释 在私有作用域下形成的私有变量，函数保护了私有变量不受外界的干扰，函数的这种机制就叫做——闭包 在私有作用域中如果变量不是私有的，它的值往上一级作用域查找，直到找到window为止，如果window也没有，则报错。 首先看是不是形参 再看有没有被声明过 函数执行的过程 ①形成一个私有的作用域 ②形参赋值（形参也是私有变量） ③预解释 ④代码从上到下执行 查找上级作用域 上级作用域：只需要看当前函数是在哪个作用域下定义的，和在哪执行没有关系 查找上级作用域，一级一级向上查找，形成了作用域链 预解释的特殊情况 条件中的预解释 不管条件成立不成立，都要进行预解释 预解释时function只声明不定义（新版本浏览器） 预解释时function声明并定义（旧版本浏览器） 预解释只发生在“=”左边，右边不进行预解释 var fn=function (){}fn预解释，function不进行预解释 函数中return的内容不进行预解释，但是return后面的代码需要进行预解释 匿名函数不进行预解释 自执行函数本身不进行预解释，定义和执行一块完成，但是里面的代码进行预解释 预解释的时候，如果变量名字重复，不再声明，但是要重新定义 thisthis是关键字，当前行为发生的主体，和执行的范围（context）没有任何关系，和函数在哪定义的也没有关系this 常用几种情况： 全局下this指向window 看当前方法执行前面有没有”.”，如果有，“.”的前面的就是this指向的，如果没有，则是window 自执行函数中的this永远指向window 如果给元素绑定方法时，方法中的this就是指当前被绑定的这个元素 定时器里的this指向window 在构造函数中出现的this.xxx=xxx中的this都是当前类的实例,而某一个属性值(方法),方法中的this需要看方法执行的时候,前面是否有”.”才能知道this是谁 1234567891011121314151617181920function Fn() &#123; this.x = 100; this.y =200; this.getX = function () &#123; console.log(this.x) &#125; &#125; Fn.prototype = &#123; y : 300, getX : function () &#123; console.log(this.x) &#125;, getY : function () &#123; console.log(this.y) &#125; &#125; var f = new Fn; f.getX();//100 f.getY();//200 f.__proto__.getY();//300 f.__proto__是Fn.prototype 面向对象：基于对象面向对象（OOP）的三大特性：封装、继承、多态 对象：万物皆对象，泛指（大体的指向） Function 类：是对象的一个细分 实例：是类的一个具体的个体 js中内置的类： Number、Boolean、String、Null、Undefined Array、Object（基类）、RegExp、Date… Math不是类，类都是对象 Function : 内置类 所有的函数（普通函数、类（内置类，自定义类））都是函数类型的，都是Function这个类的一个实例,Function是所有函数的基类 所有的对象数据类型的（对象，实例，prototype），都是Object的一个实例 所有的实例是对象数据类型的 Object 和Function互为指向 Object 的原型上没有proto 这个属性 call1234567891011function fn1(num1,num2) &#123; console.log(num1,num2) console.log(this)//fn2&#125;;function fn2() &#123; console.log(2) console.log(this)&#125;;fn1.call([1,5,7],3,4,5);//3,4 [1,5,7]fn1.call.call(fn2);//2 window//相当于让fn2(); call方法执行的时候，先通过__proto__找到Function原型上的call方法，并让call方法执行； call方法执行时，首先把call中this的this变为call第一个传入的参数，然后让call中的this执行 传参数是用逗号隔开， 除了第一个参数以外，剩下的参数作为实参 两个call及两个以上call执行，都是让参数执行 严格模式和非严格模式下的call 在非严格模式下，如果call方法中不传参数，或者传null/undefined，那么fn1函数的this指向window 在严格模式下，如果call方法中不传参数或者传undefined，那么fn1函数的this指向undefined；如果call方法中传null，那么fn1函数的this指向null。 apply方法 Function的原型上有一个apply方法 函数数据类型的可以用apply方法 apply 也是改变方法this关键字的 执行的时候，apply方法执行，首先让apply前面的方法中this，变成apply方法传进的第一个参数，并且让apply前面的方法执行 在非严格模式下，如果apply方法中不传参数，或者传null/undefined，那么函数的this指向window 除了第一个参数以外，剩下的参数要把他放在一个数组中传入，然后用数组中的每一项给形参赋值 作用：可以实现将数组中的每一项作为实参传给指定函数 12345678910111213function fn(num1,num2) &#123; console.log(num1); console.log(num2); console.log(this); return 3;&#125;function fn2() &#123; console.log(4);&#125;var f=fn.apply(fn2);//fn执行f();//报错，f不是函数console.log(f)//f为函数fn1的返回值3fn.apply([null,2,3],[1,3,4]);//1 3 [null,2,3] apply和call的区别传参数方式不一样。call方法传参数——,隔开，一个个传进去apply 方法传参数——除了第一个参数以外，剩下的参数要把他放在一个数组中传入，然后用数组中的每一项给形参赋值（apply的参数只有两个，第二个必须为数组） apply运用（获取数组中的最大最小值）123var ary=[1,3,6,88,66,37,29];Math.min.apply(null,ary);Math.max.apply(null,ary); call和apply运用（类数组转数组方法）数组和类数组的区别：类数组不能调用数组的方法 12345678var ary =[];try&#123; ary=Array.prototype.slice.call(类数组)//IE8，7，6下不兼容&#125;catch()&#123; for(var i=0;i&lt;类数组.length;i++)&#123; ary[ary.length] = 类数组[i]; &#125;&#125; bind方法也是定义在Function上的一个方法fn1.bind(fn2);this的预处理：第一步，只是改变了this，bind执行，让fn1中的this变成bind传进去的第一个参数，将改进的fn1以返回值返回。（实际没有执行） 123456789101112function fn1() &#123; console.log(1); console.log(this); return 3;&#125;function fn2() &#123; console.log(4);&#125;var f=fn1.bind(fn2);//fn1不执行f();//this为fn2fn1();//this为windowconsole.log(f)//f为函数fn1 bind 在IE678 下是不兼容的(1,2,34,4,53,23,4)只会取最后一个值 创建实例的方式12var ary=[];//字面量方式创建var ary=new Array()//实例创建 instanceof12var a=[];console.log(a instanceof Array);//true 基本数据类型的值，如果用字面量方式创建，用instanceof判断的时候，返回一个false，如果用实例创建，返回true 对象数据类型，两种方式创建，用instanceof判断都返回true 所有后台语言，都是面向对象开发的，比如Java，php，c++，.net new Array只有一个参数并且是数字的话，代表当前实例（数组）length的属性值，如果用逗号隔开，那么会把参数当做数组的每项传进去 设计模式单例模式在JS中把描述同一事物的属性或者方法，放在同一个空间下面，起到了一个分组作用，即使属性名相同，他们相互之间也不冲突，那么这种分组的模式——单例模式 工厂模式把实现同一功能的代码放在函数中，通过传递参数的形式，获取或者修改相应的信息——函数的封装优点：减少代码的冗余——函数特点“低耦合高内聚” 构造函数模式（构造函数）1、方法名前面有new，那么当前的方法就是一个类2、构造函数模式创建一个类，把类实例联系起来，实例与实例之间的方法或者属性都是各自私有的 构造函数中，如果不需要传入参数，那么小括号可以省去的 构造函数中的this指向当前创建的这个实例，类中的function中的this要看具体情况 类中的私有变量和创建的实例没有任何关系 如果属性名发生重复，后面的会把前面的覆盖 在类中如果return出一个基本数据类型值，那么当前类的返回值还是那个实例；如果return出一个引用数据类型值，那么当前类的返回值就是return的那个对象 instanceof判断实例是否属于某个类、 通过new创建实例，实例和实例之间的方法或属性，是不相等的（私有属性） hasOwnProperty 检测某个属性是不是私有的 如果是私有的，返回true，如果不是返回false 12var f1 = new Fn;console.log(f1.hasOwnProperty("getX"))//如果true，则getX是f1的私有属性 构造函数模式和普通函数区别 相同：首先形成一个私有作用域，形参赋值–&gt;预解释–&gt;代码从上向下执行 不同点： 返回值：普通函数中没有return，返回值undefined；构造函数模式会返回一个实例 函数执行时： 普通函数：执行代码从上到下执行 构造函数：首先浏览器会默认创建一个对象，用于接收函数中的新增的属性，最后把创建的这个对象默认返回，返回当前类的一个实例 原型模式（原型）原型模式 ： 解决了方法的公有的问题 每一个函数数据类型（函数、类）都天生自带一个prototype的属性。prototype是对象数据类型的 prototype天生自带一个constructor属性，constructor这个属性的属性值指向当前prototype这个原型对应的类 每一个对象数据类型也天生自带一个__proto__的属性，属性值是指向当前实例所属类的原型 基类Object.prototype没有__proto__属性IE浏览器怕你通过__proto__把公有的修改，禁止使用__proto__ 原型链模式这样一级一级向上查找属性的方法，形成了原型链 首先查找私有的属性或者方法，如果是私有的，直接这个方法或者属性 如果私有中没有这个方法，那么实例会通过__proto__去查找，当前实例所属类的原型中的这个方法，如果有，就可以执行 如果当前实例所属类的原型也没有这个方法，那么会通过__proto__继续向上查找，直到找到Object为止 类的继承和多态多态多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果（由继承而产生了相关的不同的类，对同一个方法可以有不同的响应）。包括重载和重写 比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat JS没有多态的概念，但JS可以通过参数判断实现多态 重写：子类可以继承父类的方法，也可以对父类的方法进行修改 类的继承子类继承父类的方法或者属性 改变父类的原型，如果想让B的实例上面有A原型上的方法，那么让A的原型空间地址赋值给类B 原型继承原型继承：类A的私有属性和公有属性都继承为类B的公有属性 1234567891011121314function A()&#123; this.x = 100; this.name = "珠峰"&#125;;A.prototype.getX = function () &#123; console.log(this.x);&#125;function B() &#123; this.age = 18;&#125;;B.prototype = new A;var f = new B;console.log(f)f.getX()//100 call继承call继承：继承私有属性，不能继承公有属性 1234567891011function A()&#123; this.x = 100&#125;;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; A.call(this) // 普通函数A 执行，改变A方法中this指向，指向B 的实例&#125;var f = new B;console.log(f.x)//100 混合继承混合继承：call继承 + 原型继承 1234567891011function A() &#123; this.x =100;&#125;;A.prototype.getX = function () &#123; console.log(this.x)&#125;;function B() &#123; A.call(this)// 继承A 的私有属性&#125;;B.prototype = new A;//原型继承的时候私有公有属性都继承var f = new B; 冒充对象继承冒充对象继承 ： 类A的私有属性和公有属性都继承为类B的私有属性 12345678910111213function A() &#123; this.x =100;&#125;;A.prototype.getX = function () &#123; console.log(this.x)&#125;;function B() &#123; var temp = new A;// 对象 for(var key in temp)&#123;//for in 遍历私有属性和公有属性 this[key] = temp[key]; &#125;; temp =null;&#125;; 中间类继承中间类继承：通过__proto__这个属性改变当前对象的指向,在IE下不兼容，只继承公有属性arguments.__proto__ = Array.prototype 可枚举的和不可枚举属性内置类原型上的内置的方法，通过for in遍历不到，但是内置类原型上新增的（自定义的方法）是可枚举的，私有的属性或方法是可枚举的 可枚举 ：对象的私有属性 、原型上新增的属性 不可枚举 ： 内置类上内置的属性 正则RegExp创建正则 字面量方法创建var reg=/\d/g; 在字面量方式创建的正则中，用字符串拼接变量的值，是不被识别的（无法引入变量） 实例创建var reg=new RegExp(&quot;\\d&quot;,&quot;g&quot;);得/\d/ 在实例创建的正则中，可以对变量进行识别 把有意义的字符再次转义之后才是正则中的有意义的字符 正则中的组成/^\d$/：意思以0~9数字开头和结尾（即是一个0~9之间的数字）正则都是由元字符和修饰符组成的 元字符：在//之间有意义的字符\：转译字符，把在正则中有特殊意义的转化成自己本身的含义^：以某一个元字符开头$：以某一个元字符结尾\n：匹配一个换行符.：除了\n以外任意单个字符 量词元字符*：出现零次到多次+：出现一次或多次?：出现零次或者一次{n}：n是一个非负整数，匹配子表达式出现n次{n,}：n是一个非负整数，出现n到多次{n,m}：n，m是非负整数，出现n到m次x|y：x或y中的一个 1/^1|2&amp;/ //以1开头或者以2结尾的 [xyz]：x或y或z[^xyz]：除了x，y，z之外的任意字符[a-z]：小写a到z之间的任意字符[^a-z]：除了小写a到z之间字符之外的任意字符\d : 一个0-9之间的数字\D : 除了0-9之间的一个任意字符\b : 匹配一个边界字符\w : 数字 、字母、下划线 中的任意一个字符\s : 匹配一个空白字符、空格、制表符、换页符 []作用 []在中括号中，所有字符都代表本身意思的字符 []在中括号中，不识别两位数 ()作用 /(小正则)(小正则)/将大正则分解成几个小正则 改变优先级 分组的引用 /(\w)\1(\w)\2/（匹配&quot;rrtt&quot;得true） \1：代表和第一个分组出现一模一样的内容 \2：代表和第二个分组出现一模一样的内容 分组的捕获 捕获的时候，不仅把大正则内容捕获到，还可以把小正则内容捕获到 ?:在小括号中（头部），只匹配不捕获 12var reg=/^[\u4e00-\u9fa5]&#123;2,4&#125;&amp;/;//中国汉字的姓名 2-4汉字var reg=/^[\w-]+@[0-9A-Za-z]+(\.[A-Za-z]&#123;2,4&#125;)&#123;1,2&#125;$/;//邮箱正则 正则修饰符（用于修饰整个正则） global——g：全局捕获 ignoreCase——i：忽略大小写 multiLine——m：多行匹配 test——匹配正则上的方法判断当前字符串是否符合我们制定的规则语法：reg.test(str) 12var reg=/\d/;//表示包含一个0~9之间的数字console.log(reg.test("珠峰123zhufeng"));得true 捕获正则每次捕获之前都要先进行匹配，如果没有匹配成功的，则返回null，如果匹配成功，则返回一个数组 正则捕获的特点懒惰性正则每一次捕获，只捕获第一个匹配的内容，如果不进行任何处理的情况下，捕获还是第一次匹配的内容；（原因是每次都是从索引0开始匹配的） 解决办法 var reg=/\d+/g;原理：加上修饰符g，正则每一次捕获结束后，属性lastIndex都会发生改变，当下一次再捕获的时候，会从新的索引位置开始捕获 贪婪性正则每次捕获的时候，会按照匹配最想的结果捕获（2符合我们的正则，2017也符合，默认捕获2017） 解决办法 var reg=/\d+?/g;?放在量词后面，解决捕获的贪婪性 exec正则上的方法把字符串中符合我们规则的内容捕获到 123var reg=/\d/;console.log(reg.exec("zhufeng"));//得nullconsole.log(reg.exec("zhufeng123").index);//得["1",index:7,input:"zhufeng123"] 第一项：捕获到的内容 第2~n项：小正则捕获内容 index属性：捕获内容在当前字符串中的索引 input属性：是要进行捕获的字符串 match字符串上的方法 只捕获大正则内容，小正则中内容不捕获 1234var reg =/zhufeng(\d+)/g;var str ="zhufeng123zhufeng234zhufeng345";var ary=str.match(reg);//默认返回数组，并且把捕获到的内容，每一项放进数组中console.log(ary)；//得["zhufeng123", "zhufeng234", "zhufeng345"] JS中的捕获异常捕获异常：当js代码报错的时候，捕捉到，并且能把异常信息抓取到try catch finally（不常用）e.message可以看到具体的错误信息 1234567var num1=10;var num2=12;try&#123; console.log(num1);&#125;catch(e)&#123; console.log(e.message);&#125; try 代码报错，才会走catch里面的代码；如果try不报错，catch中代码不执行如果catch里面也有错误，需要看try中的代码，try有错误，那么catch中也报错，try没错，则代码正常。 catch的参数不能省 JSONJSON不是一种数据类型，只是一种数据格式给对象的属性名加上双引号，就变成了JSON格式的对象{&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:8}——JSON格式的对象&#39;{&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:8}&#39;——JSON格式的字符串JSON.parse()——把JSON格式的字符串转化为JSON格式的对象JSON.stringify()——把JSON格式的对象转化为JSON格式的字符串 JSON.stringify()不识别函数，JSON.parse(JSON.stringify([function(){})会转化为null JSON兼容问题JSON在IE6/7 不兼容解决办法 123456789var strObj='&#123;"name":"zhufeng","age":8&#125;';var utlis=&#123; toJSON:function(str)&#123; var newObj=null; "JSON" in window ? newObj=JSON.parse(str):newObj=eval("("+str+")");//eval("("+str+")")制将str转化为对象，而不是作为语句来执行（&#123;&#125;作为语句时表示JavaScript代码块的开始和结束标记，而不是对象的语法标识） return newObj &#125;&#125;utlis.toJSON(strObj); eval字符串转化成真正的表达式执行]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5基础]]></title>
    <url>%2F2016%2F09%2F22%2FES5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS输出方式、数据类型、函数、if语句、for循环、数组方法、字符串方法、Math方法、Date方法、DOM属性和方法 JavaScript简介JavaScript是轻量级脚本编程语言，对页面的数据实现实时刷新，还有动画、事件（例如点击一下） ECMAScript核心 规定了JS的语法 DOM文档对象模型Document Object Model 提供了js操作文档中元素的一些方法 BOM浏览器对象模型Browser Object Model 提供了js操作浏览器的一些方法和属性 JavaScript的引入方式行内式onclick=&quot;alter(&#39;ok&#39;)&quot; 安全性能比较低 （在F12里可以手动更改，不推荐） 内嵌式&lt;script type=&quot;text/javascript&quot;&gt;alter(&#39;ok&#39;)&lt;/script&gt; 将js代码写在script脚本块中间 外联式&lt;script type=&quot;text/javascript&quot; src=&quot;bov.js&quot;&gt;&lt;/script&gt; 将js代码写在外面文件中，将通src找到引入 在外链式中，script脚本块中间不可以写js代码，写了也不执行 为什么将css放到head里 js放到body里 先加载css样式 再加载html? 我们通常将js放到body的最后面，原因：html页面是从上到下加载的，js通常是获取html标签给予动态操作效果的，所以需要先加载html标签，才能再加载我们的js。 ES5核心JS的输出方式alertalert(&quot;免费课很重要&quot;);alert括号里面的内容，就是浏览器弹出框内的文本 consoleconsole.log(&quot;珠峰培训免费课大家要预习哟&quot;);在浏览器控制台输出我们的内容，输出的内容就是括号包起来的内容 documentdocument.write(&quot;现在是中午12点&quot;);在页面中输出显示内容 value只针对input标签内容赋值document.getElementsByClassName(&quot;类名&quot;)[0].value=&quot;显示内容&quot;; innerHTML和innerText给input标签以外的标签赋值document.getElementsByClassName(&quot;类名&quot;)[0].innerHTML=&quot;显示内容&quot;;document.getElementsByClassName(&quot;类名&quot;)[0].innerText=&quot;显示内容&quot;; 二者区别 innerHTML可以识别标签 innerText 不能识别标签 innerText在低版本火狐浏览器下不兼容 变量命名规范js 中的变量是一个抽象的概念，变量是用来存储值和代表值的var 自定义名称=1; var 定义变量 “=” 表示赋值（覆盖） var 自定义名称;只声明没有赋值，那么以后再获取这个变量就是undefined 在全局下定义一个变量，相当于给Windows增加一个属性名，属性名是当前的变量名字，属性值是变量存储的值 命名规范 不能以数字开头作为变量的名字 变量名是严格区分大小写的 不能以关键字或者保留字作为变量名 关键字：在js中有特殊意义的字 保留字：未来可能成为关键字的 变量名可以以字母、下划线”_”、”$”作为首字母 其他可以为字母、下划线”_”、”$”和数字 汉字或其他双字节字符来定义变量，但不建议这样做 驼峰命名法：除了第一个单词，其他完整的有意义单词的首字母最好大写 JS中的数据类型基本数据类型只表示一个值的数据称为值类型，即基本类型 number var num=1; NaN：不是个数字 但是他是number数据类型 string（字符串） var str=&quot;ab&quot;;（用单引号或者双引号包起来的是字符串） boolean（布尔类型） true/false null（空指针对象） 常用场景 通过ID获取元素，如果没有获取到当前元素，那么返回null document的nodeValue的值为null 正则捕获没有捕获到内容，返回也是null 给对象清空内存，var obj=null;不占内存 undefined 如果变量只声明未定义，那么当前变量存储的值为undefined 在函数中，定义了形参而没有传值，那么当前参数存储值为undefined 在函数中，如果没有return值，那么当前函数执行后返回结果为undefined 获取当前对象的属性值时，如果没有对应的属性名，那么输出undefined null和undefined的区别：都表示空，null表示现在为空，以后不一定为空；undefined表示现在是空，以后也为空； 引用数据类型一个数据里还能包含其它数据的这种复合体，称为对象类型，即引用类型 函数数据类型 对象数据类型 正则 var yy=/^\d+$/; Date Math等 数组 var Yy=[7,8,&quot;shy&quot;,null];数组是一组数据的集合 console.log(Yy[3]);控制台显示null（数组从0开始） 对象 var uu={name:&quot;xiaoming&quot;,age:18}对象是由一组组键值对组成，用“,”隔开 每一项:前是属性名，后是属性值 uu.age=81;如果已有属性名，就是修改属性值；如果没有属性名，那么就是新增 delete uu.age;彻底删除 uu.age=null;假删除 通过对象属性名获取对象console.log(uu.name);/console.log(uu[&#39;name&#39;]); 如果对象属性名由数字组成，只能通过console.log(uu[8]);获取 检测数据typeof用来检测基本数据类型、函数数据类型 返回值：字符串[数据类型，但是不能区分对象中具体的某个类返回值 ： 字符串 console.log(typeof 12);number console.log(typeof &quot;abc&quot;);string console.log(typeof [1,2]);object console.log(typeof {name:&quot;xiao&quot;});object console.log(typeof undefined);undefined console.log(typeof true);boolean console.log(typeof null);object 缺点不能分辨对象数据类型的具体类 constructor原型自带属性，指向当前实例所属类 instanceof判断A是否属于B，A instanceof B，判断某个实例是否属于某个类 返回值：true/false 检测时，只要在当前实例的原型链上，都返回true 万物皆对象，Object基类Array数组RegExp正则 基本数据类型的值，如果用字面量方式创建，用instanceof判断的时候，返回一个false，如果用实例创建，返回true 对象数据类型，两种方式创建，用instanceof判断都返回true Object.prototype.toString.call() 检测数据类型 返回值：&quot;[object Number]&quot;、&quot;[object String]&quot;、&quot;[object Boolean]&quot;、&quot;[object Null]&quot;、&quot;[object Undefined]&quot;、&quot;[object Object]&quot;、&quot;[object Function]&quot;、&quot;[object Array]&quot;、&quot;[object RegExp]&quot;、&quot;[object Date]&quot; &quot;[object Arguments]&quot; Arguments不是一个类，特定类型 number类型Number强制把数据转换成数字（当包含非数字时，得到NaN）Number(&quot;2324&quot;); parseInt/parseFloatt转换数据类型时，从左到右依次转换，直到遇到一个非有效数字时停止转换，然后把转换的输出出来（当以非数字开头时，得到NaN）parseInt(&quot;12asfffg&quot;); parseFloat比parseInt多识别一个小数点 isNaN检测是不是无效数字，是得到true，不是得到falseisNaN(a); 先将a通过Number强转 再判断是不是NaN toFixed 截取小数点后面几位即遵循四舍五入，保留几位小数 12var y=89.95555;console.log(y.toFixed(2)); string类型用单引号或双引号包起来的都是字符串有多少字符，长度（length）就为多少 123var test="zhufeng788m";console.log(test.length);//得到11 通过索引，找到第几个字符串 console.lo(test[0]);得到第一个字符z 字符串的运算方法乘除法把字符串转换为数字，再运算 12345678var tt="12";var dd="3";console.log(tt*dd);//得36var tt="12px";var dd="3";console.log(tt*dd);//得NaN 1234var tt="12";var dd="24";console.log(tt/dd);//得到0.5 减法把字符串转换为数字，再运算 12345678var tt="18";vat yy="34px";console.log(tt-yy);//得"NaN"var tt="34";vat yy="18";console.log(tt-yy);//得"16" 加法字符串的拼接法则：1、双引号，不能套双引号（单引号同理）2、如果要拼接变量的话，首先看外面是单引号还是双引号，如果外面是双引号，那么里面就是双引号，然后++；单引号同理。 12345678var tt="18";vat yy="34px";console.log(tt+yy);//得"1834px"var tt="18";vat yy="34";console.log(tt+yy);//得"1834" boolean类型 只有0，空字符串，NaN，null，undefined这五个值转换成boolean类型是false “！”表示取反，将！后面的值转化为boolean类型值，然后取反 基本数据类型和引用数据类型的区别基本数据类型是直接操作值的引用数据类型是操作地址的 开辟一个空间地址 把键值对放进开辟的空间里面 把当前新开辟的地址赋给当前变量 如果当前对象不存在对应属性名，那么获取它的属性值是undefined 如果当前对象有对应属性名，那么就是修改，没有就是新增属性和属性值 delete obj.age;delete将属性名属性值都删除 =、==和===数据类型比较 1个”=”赋值 2个”=”比较 相等得到true，不等false 对象==对象：比较的是空间地址（永远不等） 对象==字符串：会把对象转化为字符串再比较 对象==boolean：对象转换成字符串，再转化为数字，boolean转换为数字 对象==数字：对象先转成字符串，再转化为数字 字符串==数字：字符串转换为数字 字符串==boolean：同时转化为数字 boolean==数字：boolean转换为数字 NaN、null和undefined与其他任何数据比较都不相等，除了null==undefined；等true 3个”=”绝对比较 完全相同 null==undefined；等truenull===undefined；得false 三个判断if else if elseif(条件1){ 条件1成立，执行}else if(条件2){ 条件2成立，执行}else if(条件3){ 条件3成立，执行}else{ 都不成立，执行} 1234var num=10;if(num&lt;15)&#123;console.log("aa");&#125;else&#123;console.log("bb");&#125; 三元运算符12var num=10;num&lt;15?console.log("aa"):console.log("bb"); switch caseswitch中进行的是绝对比较 1234567891011var tt=15;switch(tt)&#123; case 15: console.log("aa"); break;//终止代码 case "15": console.log("bb"); break;//终止代码 default: console.log("15");&#125; while循环while(判断条件){ 执行代码} 12345var i=0;while(i&lt;18)&#123; console.log(i); i++;&#125; for循环for四部曲 定义i的初始值（在第一次循环才有） 判断条件是否成立 执行循环体内的代码 执行i++ 123for(var i=0;i&lt;18;i++)&#123; console.log(i);&#125; break：结束整个循环，i++也不再执行 continue：结束本轮循环 “i++”为i+1 “+=num”为i+num for in循环：遍历对象 如果属性名是数字的话，会先输出 1234var obj=&#123;name:"小明",age:16,sex:"男"&#125;;for(var key in obj)&#123; console.log(obj[key])&#125; function（函数）基础 function定义 开辟一个空间地址 把function中的代码当作字符串存到开辟的空间里面 把空间地址给函数名 123function sum(num,num1)&#123; console.log(num+num1);&#125; 执行 把空间存储的字符串转换成代码执行 sum(); 函数在执行的时候，会形成一个私有作用域，保护里面的变量不受外界的干扰，这种机制就是闭包 function的入口——形参num,num1sum(100,20);——100，20实参 arguments是函数天生自带的参数集合，是类数组，同样具有数组的特征作用：将参数通过索引形式输出arguments[0] arguments的属性callee：属性值为当前函数的本身 函数的属性caller：哪个函数让它执行，那么指向谁 return函数的出口return下面的代码不再执行 自执行函数12345(function sum()&#123; var num1=3; var num2=2; console.log(num1+num2);&#125;)(); 12345~function sum()&#123; var num1=3; var num2=2; console.log(num1+num2);&#125;(); 123!function ()&#123;&#125;();+function ()&#123;&#125;();-function ()&#123;&#125;(); 匿名函数整个函数赋值给一个变量 123456var fn1=function () &#123; var num1=3; var num2=2; console.log(num1+num2);&#125;;fn1(); 函数的递归在函数中直接或间接地调用函数本身，那么当前函数是个递归的函数 12345678function sum(num)&#123; if(num&lt;=50)&#123; return 50; &#125;else&#123; return num+sum(num-1); &#125;&#125;;sum(100); 回调函数把一个方法B当做方法A的参数，传给方法A，在函数A中，可以任意位置调用方法B，让方法B执行 惰性载入函数一种优化思想 函数的三种角色（函数的多面性） 1、普通函数：形成私有作用域–&gt;形参赋值–&gt;预解释–&gt;代码从上往下执行 2、类：把实例、原型、原型链关联在一起 3、对象：是Function一个实例，实例是对象数据类型的，可以新增属性名属性值 数组（对象数据类型） 天生自带length属性 数组每一项都对应一个属性名，那么这个属性名叫数组的索引。 在数组中，获取数组的某一项，那么数组类[index] 对象没有length这个属性，如果获取的话得undefined 数组的方法（函数）数组函数中的作为实参的索引可以为负值，从前往后为自然数（0开始），从后往前为负数（1开始） push(末尾新增)var ary=[1,2,3]; 向数组末尾添加项，多个项用“,”隔开 ary.push(18,19)末尾添加项18和19 返回值是新增一项后数组的长度 console.log(ary.push(18,19));得5 参数是要新增的那一项 原有数组发生改变 console.log(ary);得[1,2,3,18,19] pop（末尾删除）var ary=[1,2,3]; 删除数组最后一项 返回值是删除的那一项 console.log(ary.pop());得3 参数可以不传，传也没用 原有数组发生改变 console.log(ary);得[1,2] unshift（起始新增）var ary=[1,2,3]; 向数组前面新增项，多个项用“,”隔开 ary.unshift(18,19)前面添加项18和19 返回值是新增项后数组的长度 console.log(ary.unshift(18,19));得5 参数是要新增的项 原有数组发生改变，新增顺序为参数顺序 console.log(ary);得[18,19,1,2,3] shift （起始删除）var ary=[1,2,3]; 删除数组第一项 返回值是删除的那一项 console.log(ary.shift());得1 参数可以不传，传也没用 原有数组发生改变 console.log(ary);得[2,3] splice（删除替换多项）var ary=[1,2,3,5]; ary.splice(n,m,x,y...)从数组索引n开始（包括n）删除m项，替换成新增项x和y等 ary.splice(1,2,4)删除项2和3，用4替换 返回值是删除的m个项，以数组方式返回 console.log(ary.splice(1,2,4));得[2,3] 参数n索引，m删除个数，x新增的项 原有数组发生改变，新增顺序为参数顺序 console.log(ary);得[1,4,5] n&gt;ary.length，m无用，直接在最后新增项x和y等n为负数，从后往前索引，从索引n开始往后删除m项再替换新增 slice（截取项）var ary=[1,2,3,4,5]; ary.slice(n,m)截取数组从索引n（包括n）到索引m（不包括m）的项（索引n在数组中的位置必须是在索引m左边） ary.slice(1,3)截取项2和3 返回值是截取的项，以数组方式返回 console.log(ary.slice(1,3));得[2,3] 参数n索引，m索引 原有数组不发生改变 console.log(ary);得[1,2,3,4,5] 如果只有一项实参a，则从索引a开始（包括a）截取到末尾 concat（拼接数组）var ary=[1,2,3];var bry=[&quot;a&quot;,&quot;b&quot;]; 参数是往数组里面拼接的项，如果参数是数组，会把数组中的项拿出来拼接进去 ary.concat(bry,4,5)得[1,2,3,”a”,”b”,4,5] 返回值新数组 console.log(ary.concat(bry,4,5));得[1,2,3,”a”,”b”,4,5] 原有数组不发生改变 console.log(ary);得[1,2,3] joinvar ary=[1,2,3,4,5]; ary.join(&quot;*&quot;)将数组中的每一项，用符号*隔开 返回一个字符串 数组的每一项作为字符串和符号拼接 参数符号放在双引号中 原有的数组不变 reverse（反顺序） 将数组中各项顺序反过来 返回值：顺序调换后的数组 不需要参数 原有数组改变 sort（数组排序） 数组排序中能处理10以内的数组排序（根据第一个字符排序） 从小到大 123ary.sort( function (a,b) &#123;return a-b&#125;); 从大到小 123ary.sort( function (a,b) &#123;return b-a&#125;); sort原理：数组冒泡排序思想 indexOf ary.indexOf(n);判断当前项n是否属于数组的某一项，若是则返回当前项的索引，若否则返回-1 如果数组中存在多个相同项，那么只返回第一个匹配到项的索引 lastIndexOf ay.lastIndexOf(n);判断当前项n是否属于数组的某一项，若是则返回当前项的索引，若否则返回-1 如果数组中存在多个相同项，那么只返回最后一个匹配到项的索引 forEach/map（遍历）12var ary=[1,2,3,4,5];ary.forEach(function(item,index,input)&#123;return index&#125;)//得0，1，2，3，4（索引） 12var ary=[1,2,3,4,5]; ary.forEach(function(item,index)&#123;return item&#125;);//得1，2，3，4，5（各项） 返回值为各项和索引 删除数组最后一个项方法123ary.length--;ary.pop();ary.splice(-1,1); 复制123ary.slice()ary.slice(0)ary.concat(); Math（对象数据类型）Math的方法（函数） 取绝对值Math.abs() 向上取整（进1法）Math.ceil() 向下取整（取最小整数）Math.floor() 取整（四舍五入）Math.round() 产生0≤随机数&lt;1Math.random() 取最大数Math.max(1,2,3,4) 取最小数Math.min(1,2,3,4) n的m次方Math.pow(n,m) 12//取m~n之间的任意整数Math.round(Math.random()*(n-m)+m); DateDate的方法（函数） new Date();获取当前时间，var time=new Date(); time.getFullYear();年 time,getMonth();[0~11]月 time.getDate();[1~31]日 time.getDay();[0~6]星期 time.getHours();[0~23]时 time.getMinutes();[0~59]分 time.getSeconds();[0~59]秒 time.getMillSeconds();毫秒 time.getTime();设备时间距离1970年1月1日的毫秒差 字符串数组的方法(函数)toUpperCase（转化为大写） 把所有字母转化为大写 字符串.toUpperCase(); 返回值为大写的字符串 toLowerCase（转化为小写） 把所有字母转化为小写 字符串.toLowerCase(); 返回值为小写的字符串 charAt 通过索引获得对应的字符，字符串具有length属性，双引号内的有效字符（包括空格） 字符串.charAt(n); charCodeAt 通过索引获得对应的字符的Unicode编码值 字符串.charCodeAt(n); indexOf 返回字符a在字符串中的第一次出现位置的索引，如果不存在，返回-1 字符串.indexOf(a); lastIndexOf 返回字符a在字符串中的最后一次出现位置的索引，如果不存在，返回-1 字符串.lastIndexOf(a); replace（替换） 用m字符替换n字符 第一个参数：原有字符；第二个参数：新字符 字符串.replace(&quot;n&quot;,&quot;m&quot;); replace原理第一个参数是正则，对原字符进行符合要求的捕获，然后替换。第二个参数是函数，replace捕获几次，就执行几次，函数return的结果作为用来替换的内容 1234567var str = "zhufeng123zhufeng234zhufeng456";var reg = /zhufeng/g;str=str.replace(reg,function () &#123; console.log(arguments)//第一次捕获传入参数：["zhufeng",0,"zhufeng123zhufeng234",callee:function,Symbol(Symbol.iterator): function] return "珠峰培训"; &#125;) console.log(str);//"珠峰培训123珠峰培训234珠峰培训456" split 把字符串中的每一项通过特定字符分隔开成数组中的每一项 123456var str="1+2+3";console.log(str.split("+"));/*得["1","2","3"]*/var str="asdfg";console.log(str.split("+"));/*得["asdfg"]*/var str="1+2+3";console.log(str.split(""));/*得["1","+","2","+","3"]*/ 1234var ary=[1,2,3];var str=ary.join("+");console.log(eval(str));//"eval把字符串转为表达式处理(不属于字符串的方法) substr(n,m)截取字符串 从索引n开始，截取m个字符串 第一个参数：开始位置索引；第二个参数：从左往右截取的个数 只写一个参数，默认从索引n开始截取到末尾 没有参数，截取整个字符串 substring(n,m)截取字符串 从索引n开始，截取到索引m，包括n，不包括m 参数：都是索引 只写一个参数，默认从索引n开始截取到末尾 有一个为负数，从头截取到索引正数，不包括正数 都为负数，undefined 定时器首先约定一个时间，到了这个时间去执行相应的代码 window.setTimeout(function(){执行代码},n);n代表多少毫秒（ms）（1s=1000ms） 过多少毫秒，执行代码一次，结束 window.setInterval(function(){执行代码},n); 每隔一段时间都执行一次代码 定时器的返回值：表示这是当前页面中的第几个定时器 window.clearInterval(定时器);清除定时器 window.clearTimeout(定时器);清除定时器 各浏览器之间最小的时间区分不同，谷歌为5~6ms DOM文档对象模型获取元素JS的特点 要想操作谁 就要先获取谁console.log(document.getElementById(&quot;box&quot;));在当前文档下，通过属性值为box的Id属性来获取元素 document：当前文档 get：得到 Element：元素 By：通过 Id：属性名（Id属性值在一个文档中是唯一的，不可重复） 获取DOM元素的方法document 上下文（获取元素的范围） 通过id获取元素var oBox=document.getElementById(&quot;box&quot;); id前的上下文只能是document（id值重复，默认获取第一个）IE6，7将input表单元素的name值当成id值（尽量保证name值和id值的唯一性） 通过class名获取元素（IE6，7，8不兼容）var oSelect=document.getElementsByClassName(&quot;select&quot;)[0]; document.getElementsByClassName(&quot;select&quot;)为类数组，有索引值和length属性（索引从0开始依次递增） 通过索引值 ，获取某一个元素 通过标签名获取var oUl=document.getElementsByTagName(&quot;ul&quot;)[0]; document.getElementsByTagName(&quot;ul&quot;)为类数组，有索引值和length属性（索引从0开始依次递增） 通过索引值 ，获取某一个元素 通过属性名获取var oUl=document.getElementsByName(&quot;name&quot;)[0]; 上下文只能是document document.getElementsByName(&quot;name&quot;)为类数组，有索引值和length属性（索引从0开始依次递增） 通过索引值 ，获取某一个元素 获取html元素var oHtml=document.documentElement; 获取body元素var oBody=document.body; 获取浏览器窗口尺寸var width=document.documentElement.clientWidth||document.body.clientWidth;var height=document.documentElement.clientHeight||document.body.clientHeight; 移动端常用选择方法规律：css选择器的规则querySelector(css选择器);选择一个元素querySelectorAll(css选择器);选择多个元素 节点node分为元素节点、文本节点、注释节点、document包括标签，注释，文本内容、空格（space）和回车…… 获取节点childNodes 元素的子节点包括标签，注释，文本内容、空格（space）和回车……oTab.childNodes; children元素的子元素节点只包括标签oTab.children; parentNode元素的父节点oTab.parentNode; previousSibling同级上一个节点（哥哥节点）oTab.previousSibling; nextSibling同级下一个节点（弟弟节点）oTab.nextSibling; firstChild元素的第一个节点oTab.firstChild; lastChild元素的最后一个节点oTab.lastChild; 以下方法IE6，7，8不兼容 previousElementSibling同级上一个元素节点（哥哥元素节点）oTab.previousElementSibling; nextElementSibling同级下一个元素节点（弟弟元素节点）oTab.nextElementSibling; firstElementChild元素的第一个元素节点oTab.firstElementChild; lastElementChild元素的最后一个元素节点oTab.lastElementChild; 节点属性 节点的类型 nodeType nodeName nodeValue 元素 1 大小写标签名 null 文本 3 #text 文本内容 注释 8 #comment 注释内容 document 9 #document null DOM的动态操作实现DOM的增删改 增（appendChild、insertBefore） 创建一个元素 document.createElement(&quot;元素名&quot;)（必须是document） 向容器的末尾添加一个子节点 容器.appendChild(); 向容器的某个子节点前面新增一个节点 容器.insertBefore(newEle,oldEle); 第一个参数：新增元素；第二个参数：是容器中想要新增在其前面的元素 删（removeChild） 删除容器中的一个子节点 容器,removeChild(要删除的元素); 改（replaceChild） 替换节点 容器.replaceChild(newEle,oldEle); 第一个参数：用来替换的元素；第二个参数：被替换的元素 复制（cloneNode） 复制当前节点 当前节点.cloneNode(true) 默认false：只克隆当前节点；true：会把子节点同时克隆 123456var oUl=document.getElementsByTagName("ul")[0];var oLi=document.createElement("li");/*1、创建一个完整的div*/oLi.className="zhufeng";/*添加class名*/oUl.body.appendChild(oLi);/*2、容器末尾添加一个子节点*/var oldLi=oUl.getElementsByTagName("li")[1];oUl.insertBefore(newEle,oldLi);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webStorm和eclipse快捷键]]></title>
    <url>%2F2016%2F09%2F20%2FwebStorm%E5%92%8Ceclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[webStorm和eclipse快捷键 查找和代替 webStorm快捷键 eclipse快捷键 功能 ctrl+shift+N ctrl+shift+R 通过文件名快速查找工程内的文件（必记） ctrl+shift+alt+N ctrl+shift+alt+N 通过一个字符快速查找位置（必记） ctrl+F ctrl+F 在文件内快速查找代码 F3 ctrl+K 查找下一个 shift+F3 ctrl+shift+K 查找上一个 ctrl+R ctrl+F 文件内代码替换 ctrl+shift+R 指定目录内代码批量替换 ctrl+shift+F ctrl+H 指定目录内代码批量查找 界面操作 webStorm快捷键 eclipse快捷键 功能 ctrl+shift+A ctrl+shift+A 快速查找并使用编辑器所有功能（必记） alt+[0-9] alt+[0-9] 快速拆合功能界面模块 ctrl+shift+F12 ctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块） alt+shift+F alt+shift+F 将当前文件加入收藏夹 ctrl+alt+s ctrl+alt+s 打开配置窗口 ctrl+tab ctrl+tab 切换代码选项卡（还要进行此选择，效率差些） alt+←/→ alt+←/→ 切换代码选项卡 ctrl+F4 ctrl+F4 关闭当前代码选项卡 代码编辑 webStorm快捷键 eclipse快捷键 功能 ctrl+D ctrl+shift+↑ 复制当前行 ctrl+W alt+shift+↑ 选中单词 ctrl+←/→ ctrl+←/→ 以单词作为边界跳光标位置 alt+insert alt+insert 新建一个文件或其他 ctrl+alt+L ctrl+alt+L 格式化代码 shift+tab/tab shift+tab/tab 减少/扩大缩进（可以在代码中减少行缩进） ctrl+Y ctrl+D 删除一行 shift+enter shift+enter 重新开始一行（无论光标在哪个位置） 导航 webStorm快捷键 eclipse快捷键 功能 esc esc 进入代码编辑区域 alt+F1 alt+F1 查找代码在其他界面模块的位置，颇为有用 ctrl+G ctrl+L 到指定行的代码 ctrl+]/[ ctrl+]/[ 光标到代码块的前面或后面 alt+up/down ctrl+shift+up/down 上一个/下一个方法]]></content>
      <categories>
        <category>工具</category>
        <category>软件快捷键</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>软件快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端特性]]></title>
    <url>%2F2016%2F09%2F20%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[产品形态、手机分辨率、移动端和PC端区别、页面布局方式 移动端 、响应式开发 、H5 、微信二次开发 、场景应用 、HTML5+CSS3都是指同一个技能 产品形态 产品形态 域名地址 项目 团队 案例 pc端和移动端分离开 不同 2套 2个团队 京东、网易、凤凰 pc端和移动端用一套页面结构 相同 1套 1个人或团队 猎豹、华为 手机分辨率：（iphone手机） 机型 尺寸 dpr iphone4 320×480 dpr 2.0 iphone5/5s 320×568 dpr 2.0 iphone6 375×667 dpr 2.0 iphone6 plus 414×736 dpr 3.0 移动端设计稿常用尺寸（宽度） 设计稿尺寸 参照机型 手机分辨率 750px1334（单屏页面） 参照iphone6 手机分辨率：375*2 640px1136（单屏页面） 参照iphone5 手机分辨率：320*2 1242px2208（单屏页面） 参照iphone6 plus 手机分辨率：414*3 单排页面常用在场景应用的h5中 pc和移动端的区别pc：鼠标移上效果h5：没有鼠标移上效果 滑屏切换效果编辑器：webstorm浏览器： pc（浏览器兼容问题） 火狐，谷歌，百度，360，IE（7~11） css hack h5（手机适配问题，手机机型和分辨率有很多种） 谷歌浏览器 -webkit- meta:vp+tab 移动端必须要加的标签 meta &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt; 注意：移动端的宽度不要写死，采用流式布局（百分比布局）（图片，背景图片根据需求可以写死） 全屏的图片 100% 根据设备自动去适配 img 的父元素在盒子模型上几像素的间距 解决办法：img display:block; 页面布局方式 布局 方式 最常用形态 固定布局 宽高写死 float+position PC 流式布局（百分比布局） 百分比+媒体查询+px（单位） pc端和移动端共用一套页面结构 流式布局（百分比布局） 百分比+媒体查询+rem（单位） 移动端（h5页面） flexbox 弹性盒模型 remrem：font-size of root element 根元素（html中就是html元素）的字体大小|浏览器|html默认字体大小||:–:|:–:||谷歌|16px|html{font-size:100px;}（1rem=100px）原因： 减少和设计稿的偏差 方便计算 123//如果iphone6下1rem=100pxvar winW = document.documentElement.clientWidth;document.documentElement.style.fontSize = 100*winW/750 + "px"; 移动端背景图片 单独的背景图片 background-size:cover/100%; 完全覆盖元素内容的宽高 雪碧图（200*500）做背景图片，background-size:2rem 5rem; background-size:雪碧图的宽度 雪碧图的高度 图标大小不一致的情况下找一个参考的值，取所有小图标中宽度最大的宽度、高度最大的高度]]></content>
      <categories>
        <category>CSS</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>css</tag>
        <tag>webView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3]]></title>
    <url>%2F2016%2F09%2F19%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3 新增内容，媒体查询、怪异盒模型、background新增属性，box-radius、渐变、css3动画、css3选择器 媒体查询作用：用于为不同的媒介类型规定不同的样式。 注意：css样式的就近原则，写在下面的代码会把上面的代码覆盖掉，所以媒体查询写在后面 语法@media screen and (判断条件) and (判断条件){css样式代码} 注意点：单词之间空格隔开 1、@media 媒体 媒介2、 媒体类型（常用） 值 描述 screen 计算机屏幕（默认值） print 打印预览模式 / 打印页 all 适合所有设备 3、连接符 值 描述 and 和 only 仅仅/唯一 not 排除 4、判断条件 () 值 描述 max-width 最大宽度，当小于等于设置的值时 min-width 最小宽度375，当大于等于设置的值时 device-height 设备高度 device-width 设备宽度 -webkit-device-pixel-ratio 设备的像素比例，即dpr device：设备pixel：picture element 像素ratio：比率，比例 5、样式{}{ css样式代码（选择器{属性名:属性值;}）} css3属性css3属性写两行代码-webkit-css3属性名:s属性值;css3属性名:属性值; border-radius:(顺时针方向)默认值：0 默认不能继承 值 描述 length 设置圆角半径值 % 以元素height和width值的百分比设置圆角垂直和水平向半径 四个值：左上、右上、右下、左下三个值：左上、右上/左下、右下两个值：左上/右下、右上/左下一个值：四角同值 椭圆：单改宽或者高的数值 圆角项目中的用：焦点图/banner/轮播图、小圆点（分页器）、标签等 box-sizing 怪异盒模型默认值：content-box 默认不能继承 border-boxpadding和border 算在width里面 宽度和高度分别应用到元素的内容框。 在宽度和高度之外绘制元素的内边距和边框。 content-boxpadding和border 不算在width里面 为元素设定的宽度和高度决定了元素的边框盒。 为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 box-shadow 盒子阴影box-shadow: 10px 10px 10px 10px #000 inset; 值 作用 值类型 none 无阴影 第1个长度值 水平（x轴）方向的偏移量（值） 正数(向右)负数(向左) 第2个长度值 垂直（y轴）方向的偏移量（值） 正数(向下)负数(向上) 第3个长度值 则用来设置对象的阴影模糊值，模糊半径 不允许负值，越大越模糊 第4个长度值 则用来设置对象的阴影外延值，模糊半径的深度 可以为负值，值越大深度越大 第5个值 设置对象的阴影的颜色 第6个值 inset:设置对象的阴影类型为内阴影 该值为空时，则对象的阴影类型为外阴影 background新增属性background-attachment背景连接方式 background-attachment:fixed; 不随着滚动条的滚动而滚动 background-attachment:scroll; 随着滚动条的滚动而滚动 background-origin背景显示的起点位置 background-origin:border-box; 从边框border的位置开始显示图片 (包含边框border) background-origin:padding-box; 从内边距padding开始显示图片 (包含内边距padding) background-origin:conten-box; 从内容congten开始显示图片 background-clip背景被裁剪的位置 background-clip:border-box; 从边框border开始裁剪图片 (不包含边框border) background-clip:padding-box; 从内边距padding开始裁剪图片 (不包含内边距padding) background-clip:content-box ; 从内容 content开始裁剪图片 渐变linear-gradient线性渐变12345header&#123; width:100%; height: 80px; background: -webkit-linear-gradient(right,#2b7dd1,#c71b1b,#2791d0,#ffff00 50%); &#125; angle用角度值指定渐变的方向,如：30deg 用关键字来设置: to left:设置渐变为从右到左。相当于: 270deg to right:设置渐变从左到右。相当于: 90deg to top:设置渐变从下到上。相当于: 0deg to bottom:设置渐变从上到下。相当于: 180deg 渐变颜色的起止颜色 color 颜色/长度length或者百分比percentage指定起止色位置(不允许负值) radial-gradient径向渐变 shape 确定圆的类型 circle——指定圆形的径向渐变; ellipse——指定椭圆形的径向渐变; size 圆的类型的范围 closest-side——指定径向渐变的半径长度为从圆心到离圆心最近的边 closest-corner——指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side——指定径向渐变的半径长度为从圆心到离圆心最远的边 farthest-corner——指定径向渐变的半径长度为从圆心到离圆心最远的角 at position 确定圆心的位置 如果提供2个参数，第一个表示横坐标,第二个表示纵坐标; 如果只有提供一个,第二个默认为50%,即center; 【参数一】用百分比或者长度值指定径向渐变圆心的横坐标值,可以为负值;left(左边)/center(中间)/right(右边) 为径向渐变的横坐标值;【参数二】用百分比或者长度值指定径向渐变圆心的纵坐标值,可以为负值;top(顶部)/center(中间)/bottom(顶部) 为径向渐变的纵坐标值; filter滤镜效果-webkit-filter:none | blur(px) | brightness() | contrast() | grayscale() | hue-rotate(deg) | invert() | opacity() | saturate() | sepia() | drop-shadow( radius )| url() -webkit-filter:blur();——设置对象的模糊效果。 -webkit-filter:brightness();——亮度，取值范围0-1 -webkit-filter:contrast(2);——对比度，取值范围0 ~ *, 0为无对比度（灰色），1为原图，值越高对比度越大 -webkit-filter: grayscale(1);——灰度，取值范围0-1 -webkit-filter: hue-rotate(30deg);——色相（按照色相环进行旋转，顺时针方向，红-橙-黄-黄绿-绿-蓝绿-蓝-蓝紫-紫-紫红-红）此处为叠加黄色滤镜 -webkit-filter: invert(1);——反色，取值范围0-1, 0为原图，1为彻底反色之后 -webkit-filter: opacity(0.8); ——透明度，取值范围0 ~ 1, 0为全透明，1为原图 -webkit-filter: saturate(4); ——饱和度，取值范围0 ~ *, 0为无饱和度，1为原图，值越高饱和度越大 -webkit-filter: sepia(0.5); ——褐色程度，取值范围0-1 -webkit-filter: drop-shadow(0 0 20px red); ——阴影 css3动画1、规定好动画状态指定关键帧动画 @keyframes 动画的名称 是自定义（我们自己命名） 12345678910111213@keyframes 动画的名称&#123; 0%&#123; -webkit-transform:scale(1); transform:scale(1); opacity: 0.2; &#125;…… 100%&#123; -webkit-transform:scale(2); transform:scale(2); opacity: 1; &#125;&#125; 大括号{} 规定动画划分为多少块，0%——动画开始位置、100%——动画结束位置 用animation调用规定好的动画 transfrom变换可以控制： 坐标值translate 角度rotate(45deg) 放大缩小scale() 12345 -webkit-transform: translate(300px,100px) rotateZ(30deg) skew(30deg);-moz-transform: translate(300px,100px) rotate(360deg) skew(30deg);-ms-transform: translate(300px,100px) rotate(360deg) skew(30deg);-o-transform: translate(300px,100px) rotate(360deg) skew(30deg);transform:translate(300px,100px) rotateZ(30deg) skew(30deg); 2、给指定元素调用动画效果animation（8个属性值 前5个比较常用）指定元素调用关键帧动画（@keyframes 规定的动画）的动画效果 123-webkit-animation:myRotate 3s linear 1s infinite normal running;-o-animation:myRotate 3s linear 1s infinite normal running;animation:myRotate 3s linear 1s infinite normal running; 1、动画名称（animation-name） 值是关键帧动画 @keyframes后自定义的名称 2、单次持续时间（animation-duration） 3、动画运行的曲线（animation-timing-function） ease 平滑过渡 linear 线性过渡 ease-in 由慢到快过度 ease-out 由快到慢过渡 css3高级动画：steps(动画分割为几步，start/end) 第一个参数指函数划分为几步 第二个参数表示的是指定每一步发生变化的时间点，默认end start：忽略开始的第一帧 end：忽略结束的最后一帧 4、动画延迟的时间（animation-delay） 5、动画重复次数（animation-iteration-count）（infinite 无限次） 6、动画运动的方向（animation-direction） normal：正常方向 reverse： 反向 alternate：动画先正常运行再反方向运行，并持续交替运行 alternate-reverse：动画先反运行再正方向运行，并持续交替运行 7、动画运行的状态（animation-play-state） 运动 running 暂停 paused 8、 动画时间之外的状态（animation-fill-mode） both ：保留动画关键帧中，开始的一帧（0%）或结束的一帧（100%）（开始或结束状态） backwards：保留动画关键帧中，开始的一帧（0%）（开始状态） forwards：保留动画关键帧中，结束的一帧（100%）（结束状态） transition指定元素某属性改变时调用的动画效果 12345-webkit-transition:all 2s linear 1s;-moz-transition:all 2s linear 1s;-ms-transition : all 2s linear 1s;-o-transition: all 2s linear 1s;transition: all 2s linear 1s; 1、执行动画的属性（transition-property） all：所有属性 2、过渡时间（transition-duration ） 3、动画时间函数（transition-timing-function ） linear：线性函数 ease-in ease-out ease-in-out 4、延迟时间（transition-delay） 动画库 名称 效果 bounceInDown 从下往上 bounceInLeft 从左往右 bounceInRight 从右往左 bounceInUp 从上往下 插件 swier-slide css3选择器关系选择器兄弟选择器语法：选择器A~选择器F{声明}作用：选择在A之后所有的同级元素F 属性选择器[属性名^=”val”] { 声明}选择具有某属性且属性值为以val开头的字符串的元素。 [属性名$=”val”] { 声明}选择具有某属性且属性值为以val结尾的字符串的元素。 [属性名*=”val”] { 声明}选择具有某属性且属性值为包含val的字符串的元素。 伪类选择器选择器B:not(选择器A)匹配选择器B中不包含在选择器A的元素（差集） :root匹配元素在文档的根元素。在HTML中，根元素永远是HTML元素 选择器A:last-child匹配选择器A的父元素的最后一个子元素 选择器A:only-child匹配选择器A的父元素仅有的一个子元素 E:nth-child(n)匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效。（n为自然数） 选中所有的偶数子元素E，那么选择符可以写成：E:nth-child(2n)选中所有的奇数子元素E，那么选择符可以写成：E:nth-child(2n+1) E:nth-last-child(n)匹配父元素的倒数第n个子元素E，假设该子元素不是E，则选择符无效。 E:first-of-type匹配同类型中的第一个同级兄弟元素E E:last-of-type匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n)匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n)匹配同类型中的倒数第n个同级兄弟元素E。 E:empty匹配没有任何子元素（包括text节点）的元素E。 E:checked匹配用户界面上处于选中状态的元素E E:enabled匹配用户界面上处于可用状态的元素E。 E:disabled匹配用户界面上处于禁用状态的元素E。 E:target匹配相关URL指向的E元素。解释：URL后面跟锚点#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)，:target选择器用于选取当前活动的目标元素。 123456789101112131415&lt;style&gt; :target&#123; width :300px; height:300px; font-size: 20px; text-align: center; line-height: 300px; color :red; background: #9cff80; &#125;&lt;/style&gt;&lt;a href="#div1"&gt;div1&lt;/a&gt;&lt;a href="#div2"&gt;div2&lt;/a&gt;&lt;div id="div1"&gt;div1&lt;/div&gt;&lt;div id="div2"&gt;div2&lt;/div&gt; href后面跟一个#id,指向当前文档某个具体的元素，这个被连接的元素就是目标元素:target选择器：可用于当前活动的目标元素 伪元素 E::placeholder设置对象文字占位符的样式。 需要注意的是，除了Firefox是 ::[prefix]placeholder，其他浏览器都是使用 ::[prefix]input-placeholder Firefox支持该伪元素使用text-overflow属性来处理溢出问题。 E::selection设置对象被选择时的样式。 ::selection只能定义被选择时的background-color，color及text-shadow(IE11尚不支持定义该属性)]]></content>
      <categories>
        <category>CSS</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS规范及注意事项]]></title>
    <url>%2F2016%2F09%2F16%2FCSS%E8%A7%84%E8%8C%83%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[CSS规范及注意事项 CSS命名规范类名/id命名规范 不能是数字，也不能以数字为开头 严格区分大小写 遵循行业内的规范，例如 nav导航 subnav辅导航 banner 广告位 list 列表… 可以使用拼音全拼 miaosha 多个单词组成中间可以使用_或-进行连接 一律小写尽量用英文尽量不缩写，除非一看就明白的单词 常用命名 内容 命名 头 header 内容 content/container 尾 footer 导航 nav 侧栏 sidebar 栏目 column 页面外围控制整体佈局宽度 wrapper 左右中 left right center 登录条 loginbar 标志 logo 广告 banner 页面主体 main 热点 hot 新闻 news 下载 download 子导航 subnav 菜单 menu 子菜单 submenu 搜索 search 友情链接 friendlink / link 页脚 footer 版权 copyright 滚动 scroll 内容 content 标签 tags 文章列表 list 提示信息 msg 小技巧 tips 栏目标题 title 加入 joinus 指南 guide 服务 service 注册 regsiter 状态 status 投票 vote 合作伙伴 partner 注释的写法123/* Header */内容区/* End Header */ 类名/id的命名页面结构 内容 命名 容器 container 页头 header 内容 content/container 页面主体 main 页尾 footer 导航 nav 侧栏 sidebar 栏目 column 页面外围控制整体佈局宽度 wrapper 左右中 left right center 导航 内容 命名 导航 nav 主导航 mainnav 子导航 subnav 顶导航 topnav 边导航 sidebar 左导航 leftsidebar 右导航 rightsidebar 菜单 menu 子菜单 submenu 标题 title 摘要 summary 功能 内容 命名 标志 logo 广告 banner 登陆 login 登录条 loginbar 注册 register 搜索 search 功能区 shop 标题 title 加入 joinus 状态 status 按钮 btn 滚动 scroll 标籤页 tab 文章列表 list 提示信息 msg 当前的 current 小技巧 tips 图标 icon 注释 note 指南 guild 服务 service 热点 hot 新闻 news 下载 download 投票 vote 合作伙伴 partner 友情链接 link 版权 copyright CSS样式表文件命名 内容 命名 主要的 master.css 模块 module.css 基本共用 base.css 布局、版面 layout.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 补丁 mend.css 打印 print.css 其他注意事项 写在css文件中的内容是间接引入到html文件中，浏览器在加载的时候，写在css中的图片是不能够被html直接调用的，后台或者前台编辑人员是不能够通过一定手段改变图片的，所以在页面上经常更换的图片，需要用img标签引入 在项目中 公共文件会放在自己写的文件之前，因为那个文件要先加载]]></content>
      <categories>
        <category>CSS</category>
        <category>规范</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[photoshop快捷键]]></title>
    <url>%2F2016%2F09%2F14%2Fphotoshop%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[photoshop快捷键 常用快捷键 快捷键 功能 ctrl+图片中间的空白区域 会出现选区 ctrl+D 取消选区 ctrl+C 复制 ctrl+N 新建图 ctrl+V 粘贴 ctrl+shift+alt+S 另存为 ctrl+E 合并图层 M（大写） 选区 C（大写） 切片 alt+delete 填充背景色 ctrl+delete 填充前景色 ctrl+”+/-“ 放大/缩小 alt+滚轮 放大/缩小 空格 拖动画布]]></content>
      <categories>
        <category>工具</category>
        <category>软件快捷键</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>软件快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2016%2F09%2F12%2Fcss%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[选择器、display属性、盒模型、浮动、定位、单位 层叠样式表(Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 作用给html这个文件添加静态或者动态的样式 css和html融入的方法（html引入css的四种方式） 行内式：直接在标签后面加style的属性 12&lt;div style="width:100px;height:100px;"&gt;&lt;/div&gt; 内嵌式：一般写在head元素内，用style这个元素来对html元素进行修饰，用选择器选择元素 123&lt;style&gt;div&#123;width:100px;height:100px;&#125;&lt;/style&gt; 外联式：将css代码单独放置在一个css文件中，通过link来对html结构进行修饰，一般放在head元素内 123&lt;head&gt;&lt;link rel="stylesheet" href="css.css" type="text/css"&gt;&lt;/head&gt; 导入式：@import url();都是引入一个单独的css文件 导入式不是一个html标签，也不是css的一个属性，它是一个声明语句 这条语句必须放在&lt;style&gt;元素内的第一行或所在文件的第一行 在浏览器解析的时候，先把html文件（html结构，css样式）加载完，再加载@import这个声明的css文件 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的 四种方式的权重一个html元素最终加载的css样式是谁，谁的权重就最大有行内式的听行内的在css选择器相同的情况下，谁最后加载就听谁的 CSS选择器CSS语法： 选择器的组成部分最好不要超过三个选择器的查找机制是从右向左 面试题后代选择器没有必要将一层层元素都写出来，只写最关键节点即可(具有代表性的) css选择器的分类标签选择器直接将html元素的标签名当做选择器权重：1 1234&lt;style&gt;div&#123;width:100px;height:100px;&#125;&lt;/style&gt;&lt;div&gt;我是标签选择器&lt;/div&gt; 属性选择器利用标签的属性名和属性值来选择html元素权重：10语法： 12[标签属性名]&#123;css样式&#125;[标签属性名=属性值]&#123;css样式&#125; 一般我们不用属性选择器来选择属性名为class的html元素 当属性名有两个及两个以上的属性值时，不能使用属性选择器这种方式进行选择 类选择器权重：10 将html元素的class属性值，当做一个选择器使用，需要在这个属性值之前加一个. 一个html元素，可以有多个属性值（可以有多个类名），每一个类名之间用空格隔开 类名可以重复使用 1234&lt;style&gt;.div1&#123;background-color:red;&#125;&lt;/style&gt;&lt;div class="div1 div2 div3"&gt;我是div1&lt;/div&gt; 类名不能以数字开头，多个类名之间用空格隔开 id选择器权重：100 将html元素的id属性名，当做选择器来使用，需要在这个属性值前面加一个# 一个html元素，一个id属性值只能用于一个元素，id属性值具有唯一性 123456&lt;style&gt; #div1&#123; color:red; &#125;&lt;/style&gt;&lt;div id="div1"&gt;我是一个id选择器&lt;/div&gt; 在js中在同一个html页面不能出现两个及两个以上相同的id属性值 在给html页面加css样式的时候，id的属性值可以重复，但是在JS中不可以。一般我们写id属性值中，是在js中常用 通配符选择器匹配全部html元素权重：0&lt;*&lt;1一般我们不用，这个选择器比较消耗性能（全部匹配） 并集选择器作用：将选择器进行分组，被分为一组的选择器就可以分享相同的声明，权重计算的时候都是根据单个的选择器类型独立计算的，权重不会改变。用,隔开 12345&lt;style&gt; div,p,h1,h2&#123; background-color:red; &#125;&lt;/style&gt; 交集选择器作用：我们可以使用交集选择器来进行元素的准确选择两个（最多两个）选择器组合可以准确选择html元素 12345678910&lt;style&gt; div[title=div1]&#123; width: 100px; height: 100px; background-color: yellow; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt;&lt;div title="div1"&gt;&lt;/div&gt;&lt;h1 title="div1"&gt;&lt;/h1&gt;&gt; 交集选择器之间没有任何的符号和空格 标签选择器和其他选择器组合的时候，标签选择器要放在前面 交集选择器是两个选择器的共有部分，可以是标签和属性名、标签和类名、两个类选择器作用：精确查找元素，增加选择器的权重 子级选择器 存在包含关系的元素选择，通过父级确定选择子级，子元素选择器只能选择作为某元素子元素的元素 语法：父级选择器&gt;子级选择器&gt;子级的子级选择器（最多3级，层级过多消耗性能） 父级选择器是指准确查找的范围 子级选择器才是我们要添加样式的元素 权重：所有选择器之和 子级选择器必须是紧邻的父子关系 123456789101112131415161718192021222324&lt;style&gt; .div1&gt;ol&gt;li&#123; width:100px;height: 100px;background-color: red; &#125;&lt;/style&gt;&lt;div class="div1"&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div class="div2"&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 后代选择器（派生选择器）在一个根元素的范围内，查找到它的后代元素权重：所有选择器之和语法：祖辈选择器 要查找的后代选择器{} 要用空格连接 后代选择器在使用的时候，尽量控制在三个左右 12345678910111213141516&lt;style&gt; .div1 ul p&#123; &#125;&lt;/style&gt;&lt;div class="div1"&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 相邻兄弟选择器 通过哥哥元素选择弟弟元素，两个选择器之间用”+”连接 语法：哥哥选择器+弟弟选择器{} 权重：选择器之和 12345678910111213141516&lt;style&gt; .list1+li,.list3+li&#123; font-size:40px; color: red; &#125; /* .list3+li&#123; font-size:40px; color: red; &#125;*/&lt;/style&gt;&lt;ul&gt; &lt;li class="list1"&gt;&lt;/li&gt; &lt;li&gt;11111111111&lt;/li&gt; &lt;li class="list3"&gt;&lt;/li&gt; &lt;li&gt;22222222222&lt;/li&gt;&lt;/ul&gt; 伪类选择器给一个元素添加某种状态 1234a:link &#123;color: ;&#125;&lt;!--未访问的链接--&gt;a:visited &#123;color: ;&#125;&lt;!--已访问的链接--&gt;a:hover &#123;color: ;&#125;&lt;!--鼠标移动到链接上--&gt;a:active &#123;color: ;&#125;&lt;!--选定的链接--&gt; 伪类选择器常用的是鼠标经过的状态（:hover） 伪元素通过css代码向特定的元素内添加假的（html中不存在的）元素 1234567891011121314&lt;style&gt; div:before&lt;!--before会出现在div所有内容之前--&gt;&#123; display:block; content:"" &#125; div:after&lt;!--after会出现在div所有内容之后--&gt;&#123; display:block; content:"" &#125;&lt;/style&gt;&lt;div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;/div&gt; 使用伪元素的时候保证两个前提 要有display这个属性 要有content这个属性，里面的内容可以不写 css属性的继承子级元素从父级元素身上继承一些可以继承的css属性哪些css样式可以继承：和文字有关的css样式，和列表有关的样式如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上–&gt;inherit 123&lt;div style="float:left;"&gt;&lt;p style="float:inherit;"&gt;我是p&lt;/p&gt;&lt;/div&gt; 标签的分类块级元素块级元素特点： 独占一行 常用的块元素有哪些 块元素 描述 &lt;div&gt; 块 &lt;hi~h6&gt; 标题 &lt;p&gt; 段落 &lt;ul&gt; 无序列表 &lt;li&gt; 列表项 &lt;ol&gt; 有序列表 &lt;dl&gt; &lt;dt&gt; 定义列表项标题 &lt;dd&gt; 定义列表 &lt;table&gt; 表格 &lt;form&gt; 表单 内联元素内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文章、小图标（小结构）的搭建。 标签 描述 &lt;span&gt; &lt;i&gt; 斜体 &lt;b&gt; 加粗 &lt;em&gt; 强调 &lt;strong&gt; 强调 &lt;img&gt; &lt;a&gt; &lt;sup&gt; 上标 &lt;sub&gt; 下标 &lt;select&gt; 下拉列表 &lt;input&gt; 文本框 &lt;textarea&gt; 文本域 &lt;label&gt; 描述表单元素功能 &lt;del&gt; 删除线 display属性根据这个属性可以讲元素分成不同的类型也会显示出不同的状态，例如：属性值为block的时候，这个元素会独占一行；如果属性值为inline的时候，属性值的元素都会显示在一行，属性值为none的时候，元素会在页面上消失， 所有元素都有天生自带的display属性和属性值，它被称为“内置属性” block块状元素特点： 独占一行 可以设置宽高和盒模型的css属性（width、height、border、margin、padding） 默认宽度是父级元素内容的宽度，高度是本身内容的高度 可以嵌套其他元素 &lt;dt&gt;不能嵌套块元素，可以嵌套内联元素 &lt;p&gt;不能嵌套块元素，可以嵌套内联元素（ &lt;p&gt;不能嵌套&lt;p&gt;元素） 人为设置的样式要比元素自带的样式权重高 块级元素这些特点，我们将其称为BFC块状元素，在上下文的渲染模式(块状元素应该怎么排布——面试题)css布局之BFC模式（block formatting context） 在布局中如何使用css属性将块级元素放到一行排布 float:left/right;可以从左（右）向右（左）排布 display:inline/inline-block; inline 不能设置宽高 inline-block 只能从左向右排布，并且如果有空格或者回车会有间隙 inline内联元素特点： 在一行显示 默认排布是从左到右排的 不能设置宽高 padding、margin的上下值设置不生效，左右值设置生效 默认宽高是本身内容的宽高 几个内联元素默认的垂直方向对其方式是基线对齐 在编辑代码时，如果内联元素之间有回车或者空格，那么在页面显示的时候，就会默认有间隙 可以设置父级元素的font-size:0; ，此时子级元素都需要设置font-size属性值 内联元素不能嵌套块级元素 inline-block内联块元素特点： 在一行显示 默认排布是从左到右排的 可以设置宽高和盒模型css属性（padding、margin、border） 默认宽高是本身内容的宽高 几个内联元素默认的垂直方向对其方式是基线对齐 在编辑代码时，如果内联元素之间有回车或者空格，那么在页面显示的时候，就会默认有间隙 可以设置父级元素的font-size:0; ，此时子级元素都需要设置font-size属性值 内联元素不能嵌套块级元素 none将这个元素在页面上隐藏起来（完全消失） 怎样再显示出来：将none这个属性用其他属性进行替换，一般使用block vertical-align基线对齐(改变行内元素和行内块元素及基线对齐方式) 值 作用 top 所有平级元素中找最高（高度最高）元素的顶部进行对齐 bottom 所有平级元素中找最高（高度最高）元素的底部进行对齐 middle 所有平级元素中找最高（高度最高）元素的中部进行对齐 length（数值） 像素（px），% 改变对齐方式的时候，所有元素都要添加这个属性（一般用在小图标和文字结合的 text-align 这个属性用在有宽度的元素身上 有此属性元素的子级元素，如果属性为inline，inline-block或者是文字，都可以受到这个属性的影响 盒模型定义：盒模型是css布局的基石，它规定了网页元素如何显示以及元素之间相互关系。css定义所有的元素都可以拥有像盒子一样的外形和平面空间，即都包含边框、边界、补白、内容区，这就是盒模型。盒模型： 内容区：width、height 补白：padding 边界：margin 边框：border padding、margin和border1234padding: 1px 2px 3px 4px;/*上、右、下、左*/padding: 1px 2px 3px;/*上、左右、下*/padding:1px 2px;/*上下、左右*/padding:1px;/*上下左右*/ 12345margin:1px 2px 3px 4px; /**上右下左**/ top right bottom leftmargin:1px 2px 3px; /**上 左右 下**/margin:1px 2px; /** 上下 左右**/margin:1px; /**四个方向都是1px**/ border的写法 12345678910border-top-width 上边框的宽度border-top-style 上边框的样式border-top-color 上边框的颜色border-width 边框的宽度border-style 边框的样式border-color 边框的颜色border-width:1px 2px 3px 4px;border-style:solid dashed;/*上下、左右*/border-color:green yellow pink;/*上、左右、下*/ 计算盒子模型的公式 盒子本身的宽度=width+左右padding+左右border 盒子本身的高度=height+上下padding+上下border 盒子父级的width=子级的width+子级左右padding+子级左右border+子级左右margin 盒子父级的height=子级的height+子级上下padding+子级上下border+子级上下margin margin支持负值margin-left:-30px;margin-left和margin-top为负值的时候，跑出浏览器的部分会被吃掉，不会撑开整个页面 margin-top传递问题如果父级元素没有设置padding-top和border-top值（为0）的时候，子元素设置margin-top值，会将这个值传递给父元素解决方法： 给父级元素加一个属性 overflow:hidden; 将子元素设置一个属性，改成给父元素设置一个属性padding-top，这个方法建议使用 margin-left/margin-right在IE6中会双倍当这个元素浮动的时候，左右的外边距，有时候IE6会出现双倍边距的问题解决方案： 给这个元素添加overflow:hidden; 写IE6的兼容方式，例如： 1234567div&#123;float:left;margin-left:10px !important;_margin-left:5px;/*这句话的意思是，当浏览器是IE6的时候，读取这句话*/&#125;css属性的Hack!important 一般不用 css hack overflow超出盒子部分处理方式overflow:hidden;直接将多余的部分隐藏overflow:auto;如果有多余的部分就出滚动条，如果没有就不出现overflow:scroll; 不论是否有多余部分，都出现滚动条 background 背景和内容的关系，背景永远在内容之后 123456789background-image:url("路径");background-color:red;/*背景颜色*/background-repeat:no-repeat;/*背景图片是否平铺*/ - no-repeat：不平铺 - repeat：平铺 - repeat-x：x轴平铺 - repeat-y：y轴平铺background-position:20px 30px;/*给背景图片定位*/background-size:10px/50%/cover/contain;/*调整背景图片的大小*/ 如何让图片的中心点和盒子中心点重合background-position：center center； background:red url(&quot;路径&quot;) no-repeat center center;背景：颜色 图片 是否平铺 定位 123background-image：url("1.jpg")background-position:left top,right bottom;/*背景图可以是多个图片，但在IE6、7、8下不兼容*/ 在一张背景图下，background-position的值可以为正值在雪碧图的背景图下，background-position background-size 背景尺寸大小项目中的应用:移动端背景图片/场景应用全屏的背景图片值：长度px 百分比% cover contain 后两个常用 cover 覆盖`让背景图片等比例缩放 完全覆盖我的div元素 会出现背景图片显示不完整 图片变虚被拉伸 1234567page01&#123; width: 100%; /*全屏的宽高都是100%*/ height: 100%; background: url("img/bg.jpg")no-repeat; -webkit-background-size: cover; background-size: cover;&#125; contain让背景图片等比例缩放到其中一个边接触到div元素的边缘 会出现留白的情况 123456page01&#123; width: 100%; /*全屏的宽高都是100%*/ height: 100%; background: url("img/bg.jpg")no-repeat; -webkit-background-size: contain; background-size: contain;&#125; float浮动 left：从左向右浮动，从第一个元素开始，在父级元素内，从左向右排序，达到父级最大宽度时，会自动折行。 right：从右向左浮动，从第一个元素开始，在父级元素内，从右向左排序，达到父级最大宽度时，会自动折行。 none去掉浮动，将浮动元素的浮动属性去掉 特点： 脱离文档流（父级元素找不到子级），相当于来到了第二层，平行于基本的文档流 文档流：行内元素和行内块级元素默认的渲染模式 所有元素都可以设置这个属性 a img div li ul（无论是块级元素还是行内元素） 浮动属性可以直接设置盒模型的所以属性 浮动元素不设置宽高时，宽高时本身内容的大小 行内元素，行内块元素和文字会围绕着浮动元素排列 有浮动属性的元素，排列方式听浮动的，没有浮动属性的元素，听display的 清楚浮动的方法 给父级元素设置高度 这个元素内是否有内容，高度都是一定的 给父级元素设置overflower:hidden;属性 是将浮动元素拉回文档流 给父级元素设置float属性（父级元素都是浮动元素，就可以相互识别）—&gt;不要用 利用clear:both;属性清除浮动 带有这个属性的元素放在最后一个浮动元素后面 这个属性需要依附的是一个块级元素 这个块元素不能带有浮动属性 利用伪类清除浮动工作中常用方法 定位相对定位特点： 不会脱离文档流 参照物是本身 给绝对定位元素当参照物 位置改变的时候，原来的位置还占用 层级大于文档流的普通元素的时候，会覆盖在其他元素的上面 当top和bottom同时设置时，top生效，当left和right同时设置时，left生效（和书写顺序无关） position:relative;和float同时设置时，都起作用，先浮动后定位 盒子发现位置改变，又不影响其他元素的时候，用相对定位 绝对定位特点： 脱离文档流 不设置宽高的时候，绝对定位元素的内容是本身内容决定的 不设置参照物的时候，参照物默认是body 所有元素默认都会去找参照物的起点位置，互相重叠在一起 绝对定位元素，如果不设置四个方向值的时候，并且同级之间有其他内容，它会默认排在这个内容之后 当绝对定位元素有宽高时，在top和bottom同时设置时，top生效，在left和right同时设置时，left生效（和书写顺序无关） 当绝对定位设置宽高100%，继承的宽高是参照物的宽高 当不设置绝对定位元素宽高时，在top和bottom同时设置时，都生效，在left和right同时设置时，都生效（此时宽高不再为他内容决定，top、bottom、right、left可以为负值） 设置参照物的时候 需是这个绝对定位的父级元素（可以不是相邻的父级） 参照物元素必须是带有定位属性的（相对、绝对、固定） 同级定位元素不能作为参照物 父级元素都是定位属性，绝对定位元素的参照物是离他最近的那个父级元素 固定定位特点： 脱离文档流 参照物始终是可视区域 不设置宽高时，宽和高是内容大小 多用在辅导航、返回头部位置 &lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;href中写一个“#top”或者什么都不写 或者只写一个“#”都可以实现返回头部的效果 去掉定位属性pasition:staticz-inde改变定位的层级关系特点： 不能改变父子之间的层级关系（z-index：正值） 可以设置负值，会在所有元素之后（在工作中，一般不要设置负值） 当父子元素都有z-index值得时候，如果父级元素有值，那么子级元素z-index值没有意义（指所有父级元素） 设置透明度opacity:0.3;0-1兼容高版本浏览器filter: alpha(opacity=30);0-100 兼容ie低版本浏览器 有这个属性的元素，里面所有内容都会变成半透明 单位常用长度单位 名称 描述 px（像素） 相对单位，分辨率 em 倍数 是本身字体或父级字体大小的倍数 rem 倍数（css3） 是html根元素字体大小的倍数 百分数 是父级元素宽度或者高度的百分之多少，如果是绝对定位的元素，是参照物的百分之多少 16px=1em 2em=32pxhtml,body{font-size:16px;} 12345&lt;div style="font-size:3rem;"&gt;我是div&lt;/div&gt;&lt;!--16*3rem=48px--&gt;&lt;div style="position:relative;width:500px;"&gt; &lt;div style="position:absolute;width:100%;"&gt;&lt;/div&gt;&lt;/div&gt; 色值（颜色） 名称 描述 英文单词 red pink… 不常用 十六进制 #00ffff #0ff #000fff（这种不能缩写） #000000 #000 rgb(0,0,0) 红 绿 蓝 rgba(0,0,0,0.5)（IE9+） 红 绿 蓝 透明度（不兼容ie低版本） cmyk 印刷颜色 不用（有时候存储图片的格式存储成了cmyk 在ie低版本浏览器中图片是不显示的）]]></content>
      <categories>
        <category>CSS</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5]]></title>
    <url>%2F2016%2F09%2F10%2FHTML5%2F</url>
    <content type="text"><![CDATA[HTML5新增标签和新增属性、视口 HTML5新增标签作用：1、标签更加语义化更加明确 作用 h5标签 头部 &lt;header&gt;&lt;/header&gt; 底部 &lt;footer&gt;&lt;/footer&gt; 文档中唯一的主体部分 &lt;main&gt;&lt;/main&gt; 导航 &lt;nav&gt;&lt;/nav&gt; 侧边栏 &lt;aside&gt;&lt;/aside&gt; 划分大结构(相当于pc里的div标签) &lt;section &gt;&lt;/section&gt; 一段文章内容 &lt;article&gt;&lt;/article&gt; 音频(可以引一段mp3格式的音乐) &lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 视频 &lt;video src=&quot;&quot;&gt;&lt;/video&gt; canvas动画(H5场景应用比较多核心原理都是js代码) &lt;canvas&gt;&lt;/canvas&gt; 标题组(里面可以放多个标题) &lt;hgroup&gt; 放img图片 &lt;figure&gt; 放图片的文字内容 &lt;figcaption&gt; 本地存储 localStore video1234567891011&lt;!--video--&gt;&lt;video src="http://download.qupai.me/qupai_res/images/qupai.mp4" autoplay="autoplay" controls="controls" width="100%" height="300px"&gt;&lt;/video&gt;&lt;!-- src 视频资源的路径地址 width 宽度 height 高度 autoplay 自动播放 loop 循环播放 preload 预加载 controls 控制控件显示隐藏--&gt; audio12345678&lt;!--audio--&gt;&lt;audio src="http://file.ws.126.net/f2e/ent/ent_painting2016/files/sjsznh.mp3" loop&gt;&lt;/audio&gt;&lt;!-- src 音频资源的路径地址 autoplay 自动播放 loop 循环播放 preload 预加载--&gt; H5新增表单类型 type属性 作用 &lt;input&gt;元素type属性值 日历控件 &lt;input type=&quot;date&quot;/&gt; 颜色面板 &lt;input type=&quot;color&quot;/&gt; 进度条控件 &lt;input type=&quot;range&quot;/&gt; &lt;br/&gt; 链接 &lt;input type=&quot;url&quot;/&gt; search搜索标签 &lt;input type=&quot;search&quot;/&gt; number数字&amp;数值标签 &lt;input type=&quot;number&quot;/&gt; color颜色&amp;色值选择标签 &lt;input type=&quot;color&quot;/&gt; email 邮件类型输入框 &lt;input type=&quot;email&quot;/&gt; telephone电话号码输入标签 &lt;input type=&quot;tel&quot;/&gt; time时钟标签 &lt;input type=&quot;time&quot;/&gt; placeholder属性：input框默认显示的文本的内容，当你输入内容，显示文本内容就消失 autofocus: 页面加载的时候，input框自动获取焦点 required: 必填项 pattern: 验证输入的格式（正则），如：pattern=&quot;[A-z]{4}&quot; 输入框事件oninput：事件在用户输入时触发，当元素的值发生改变的时候触发onchange : 当文本框中内容发生改变触发的事件onfocus : 文本框获取鼠标焦点执行该方法onblur :文本框失去焦点的事件 HTML5新增标签的兼容处理处理ie9以下标签的兼容性问题(在head中引入) 123&lt;!--[if lt IE 9]--&gt;&lt;script src="html5.min.js"&gt;&lt;/script&gt;&lt;!--[endif]--&gt; 本地存储localStorage本地存储 setItem : 往localStorage存储属性和属性值 getItem : 获取localStorage 这个里面某个属性的值 removeItem :获取localStorage中的属性 sessionStorage信息的会话存储，会话窗口信息存在，sessionStorage就有相应的信息，会话窗口关闭，信息也没了 cookie：把信息存储到客户端的浏览器中，（服务器也是可以获取cookie）session：把信息存储到服务器上（ 服务器存储） 视口的概念 viewport移动端常说的视口(viewport)：指浏览器显示页面内容的屏幕区域。 快捷键：meta:vp+Tab键（放head 标签里面） 1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no"&gt; 属性 解释 width=device-width 宽度等于设备的宽度 height=devic-height 高度等于设备的高度 user-scalable=no 用户是否可以手动缩放页 面 yes initial-scale=1.0 初始的缩放比例是 1.0 maximum-scale=1.0 最大的缩放比例是 1.0 minimum-scale=1.0 最小的缩放比例是 1.0 属性名 取值 描述 width 正整数或device-width 定义视口的宽度，单位为像素 height 正整数或device-height 定义视口的高度，单位为像素,一般不用 initial-scale [0-10] 定义初始缩放值 mininum-scale [0-10] 定义缩小最小比例,它必须小于或等于maxinum-scale设置 maxinum-scale [0-10] 定义放大最大比例,它必须大于或等于mininum-scale设置 user-scalable yes/no 定义是否允许用户手动缩放页面，默认值yes 常见viewport数值：(980~1024) 类型 viewport数值 iphone 980 iPad 1024 Android 980 WinPhone 1024 浏览器会判断当前是移动端还是PC端，进行不同的处理980是浏览器默认移动的可视窗口宽度]]></content>
      <categories>
        <category>HTML</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识点]]></title>
    <url>%2F2016%2F09%2F06%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本结构、常用标签、标签分类 HTML（超文本标记语言）网页文件本身是一种文本文件（除了文字再无其他），通过在文本文件中添加标记符，才能把那些普通的文本在浏览器中正常的显示，在页面中遇到图片如何展示在html页面中的。需要超文本进行引入才能正常的显示在页面中 特点浏览器根据标记来解析和描述内容（从html的第一行开始向下解析），如果遇到错误，浏览器不会指出错误，也不会报错。浏览器会跳过这个错误，继续进行解析，编辑人员需要根据显示效果去分析哪里出错误——html不会报错 兼容问题因为浏览器是由不同厂家开发的，所以对html的解析有分歧，产生的页面效果显示的不一样，我们把这个问题，叫做浏览器的兼容问题。 超文本（标签）标签语法：由成对的尖括号和关键字（标签名tagName）组成，叫做标签“tagName” 12&lt;div&gt;&lt;p&gt; 关键字（标签名）：是已经规范过的，不是自己随便制造的 标签属性标签属性是提供了有关HTML元素的更多信息语法：由属性名和属性值组成（键值对key=”value”） 1&lt;h1 style="color:red;font-size:14px;" title="标题"&gt;文字&lt;/h1&gt; h1 标签style 标签属性color：red；标签属性名和标签属性值（标签属性名和标签属性值之间用冒号隔开）（一个属性值和属性名结束带分号） 一个标签可以有很多标签属性，每一个属性之间用空格隔开 标签的分类开始标签&lt;div&gt;结束标签&lt;/div&gt;空标签（自闭合标签）&lt;img /&gt;&lt;br /&gt; HTML（标签）的元素可以将元素理解成一个容器，容器最终放置的就是我们网页显示的内容由标签和内容组成，叫做元素 12&lt;div&gt;此内容可以为空&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 元素的分类 由开始标签和结束标签组成，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容 只有一个空标签，只能进行功能上的添加，例如img元素，用来引入图片，br元素进行换行 空标签&lt;img /&gt;&lt;br /&gt;标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素中的内容 HTML的常用标签（元素） 标签 描述 &lt;div&gt; 无意义标签，来划分大的模块 &lt;p&gt; 段落 &lt;img&gt; 插入图片 &lt;h1~h6&gt; 标题 &lt;body&gt; 主体，身体部分（网页的主体部分），内容在浏览器的可视区显示 &lt;br&gt; 换行 &lt;b&gt; 加粗 &lt;i&gt; 斜体 &lt;em&gt; 强调（在浏览器中有默认表示为斜体） &lt;strong&gt; 强调（在浏览器中有默认表示为加粗） &lt;span&gt; 无意义，用于行内划分小模块 &lt;a&gt; 超链接（锚点）target=&quot;_blank&quot;：新窗口打开连接 &lt;ul&gt; 无序列表，结合，&lt;li&gt;：来使用——是列表项 &lt;ol&gt; 有序列表，结合&lt;li&gt;来使用——是列表项 &lt;dl&gt; 定义列表 主要用于新闻页面（列表）， &lt;dt&gt;：标题（只能有一个）， &lt;dd&gt;：描述（可以多个） &lt;table&gt; 表格 &lt;form&gt; 表单 &amp;nbsp；：空格符(存在多个空格时使用) table表格 &lt;caption&gt;：标题 &lt;thead&gt;：表头 &lt;tr&gt;：行 &lt;th&gt;：表头单元格 &lt;tbody&gt;：表身 &lt;tr&gt;：行 &lt;td&gt; ：普通单元格 &lt;tfoot&gt;：表尾 &lt;tr&gt;：行 &lt;td&gt; ：普通单元格 123456789101112131415161718192021222324&lt;table border="1"&gt; &lt;caption&gt;标题&lt;/caption&gt; &lt;thead&gt;&lt;!--表头--&gt; &lt;tr&gt;&lt;!--行--&gt; &lt;th&gt;表头单元格&lt;/th&gt; &lt;th&gt;表头单元格&lt;/th&gt; &lt;th&gt;表头单元格&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;!--表身--&gt; &lt;tr&gt;&lt;!--行--&gt; &lt;td&gt;表身单元格&lt;/td&gt; &lt;td&gt;表身单元格&lt;/td&gt; &lt;td&gt;表身单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt;&lt;!--表尾--&gt; &lt;tr&gt;&lt;!--行--&gt; &lt;td&gt;表尾单元格&lt;/td&gt; &lt;td&gt;表尾单元格&lt;/td&gt; &lt;td&gt;表尾单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 在表格中，只能有一个&lt;thead&gt;和&lt;tfoot&gt;，可以有多个&lt;tbody&gt; 一般我们把&lt;tfoot&gt;直接放置在&lt;thead&gt;的后面，防止因&lt;tbody&gt;内容过多，加载过慢的情况，虽然&lt;tfoot&gt;代码书写位置在前面，但在页面显示时，浏览器自动解析在&lt;tbody&gt;后面 一般&lt;table&gt;用来搭建结构，一般只需写&lt;tr&gt;和&lt;td&gt; form表单1234567891011121314151617181920212223242526272829303132333435363738&lt;form&gt; &lt;input type="radio" name="ok"&gt;&lt;!--单选按钮--&gt; &lt;label&gt;非常满意&lt;/label&gt;&lt;!--label描述表单元素功能--&gt; &lt;!-- input：标签 type：类型 name：名字 checked：选中 --&gt; &lt;input type="radio" name="ok"&gt;&lt;!--单选按钮--&gt; &lt;label&gt;不满意&lt;/label&gt;&lt;!--描述表单元素功能--&gt;&lt;br&gt; &lt;input type="checkbox" checked&gt;&lt;!--checked表示默认选中--&gt; &lt;label&gt;吃&lt;/label&gt; &lt;input type="checkbox" &gt;&lt;!--多选按钮--&gt; &lt;label&gt;喝&lt;/label&gt; &lt;input type="checkbox" &gt; &lt;label&gt;玩&lt;/label&gt; &lt;input type="checkbox" &gt; &lt;label&gt;乐&lt;/label&gt; &lt;br&gt; &lt;br&gt; &lt;textarea maxlength="10"&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength属性用于设置输入的最大字符数--&gt; &lt;br&gt; &lt;lable&gt;用户名&lt;/lable&gt;&lt;input type="text"&gt;&lt;!--文本框--&gt; &lt;br&gt; &lt;lable&gt;密码&lt;/lable&gt;&lt;input type="password"&gt;&lt;!--密码--&gt; &lt;br&gt; &lt;input type="button" value="提交"&gt; &lt;input type="button" value="登录"&gt; &lt;!--value值是button的内容--&gt;&lt;/form&gt; 表单元素 类型 元素 文本 &lt;input type=&quot;text&quot;/&gt; 密码 &lt;input type=&quot;password&quot;/&gt; 按钮 &lt;input type=&quot;button&quot; value=&#39;提交按钮&#39;/&gt; 提交 &lt;input type=&quot;submit&quot;/&gt; 重置 &lt;input type=&quot;reset&quot;/&gt; 文件 &lt;input type=&quot;file&quot;/&gt; 单选按钮 &lt;input type=&quot;radio&quot;/&gt; 复选按钮 &lt;input type=&quot;checkbox&quot;/&gt; iframe元素&lt;iframe src=&quot;http://www.baidu.com&quot; width=&quot;500px&quot; height=&quot;500&quot;&gt; &lt;iframe&gt;在引入其他文件的时候，必须设置宽高 WS中注释 ctrl+/：一整行注释 ctrl+shift+/：用于内容后面的注释，或者是注释代码块 怎么注释的就怎么取消注释 注释的作用：一般用于帮助开发人员理解代码的意思 HTML的基本结构一个HTML文件也叫做一个网页，可以称作是一个文档（document） 整个文档从HTML元素开始，一直向下延伸，像一颗大树一样，所以我们将HTML元素叫做这个文档的“根元素” !DOCTYPE html声明文档作用：定义这个文档类型的，浏览器先识别这句话，会按照定义的类型去解析这个文档。 12345&lt;!DOCTYPE html&gt;&lt;!--这个是html5的文档声明，那么浏览器会根据按照HTML5的规则来解析整个页面--&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!--HTML4的文档声明--&gt; 所有高版本都会向下兼容，所以我们在以后的工作中，我们直接可以将文档声明写成HTML5就可以了 文档声明必须写在第一行 文档声明不区分大小写 如果HTML文件中没有文档声明，会触发浏览器怪异模式 文档声明不是一个HTML元素或标签 HTML元素此元素可告知浏览器自身是一个html文档，是由开始标签到结束标签所有代码组成的，html文件里面所有的元素（内容）都放在这个html元素内 head元素整个文档的头部，&lt;head&gt;自带隐藏的功能display:none;里面的内容不会隐藏，只不过一般放置在&lt;head&gt;元素中的其他元素和内容也是自带隐藏功能的，例如：meta title…… meta规定了HTML文档的元信息12345&lt;meta charset="UTF-8"&gt;charset="UTF-8" 文档的编码UTF-8 国际通用编码gbkgb2312国际 &lt;meta name=&quot;keywords&quot; content=&quot;HTML5,js&quot; /&gt;keywords关键字、content内容 &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt;description描述、content内容 利于SEO搜索引擎优化 title元素HTML文档名称一个页面只有一个&lt;title&gt;元素，只能写文字，显示在浏览器页卡位置 link &lt;link rel=&quot;shortcut icon&quot; href=&quot;url&quot; type=&quot;image/x-icon&quot; media=&quot;screen&quot;/&gt;&lt;!--rel属性表示被连接文档和当前文档之间的关系--&gt; 图标让设计师生成 一般把这个小图片放在项目的根目录下 显示在浏览器页卡位置，在title内容之前 &lt;link href=&quot;url&quot; rel=&quot;stylesheet&quot;&gt; type=&quot;text/css&quot; /&gt; 引入一个外部的CSS文件 rel不能缺少、stylesheet样式表 type可以省略，但是建议写全 body元素定义整个文档的主体部分、所有展示给用户的内容，都要写在这个元素中&lt;body&gt;元素中常用的元素（div，ul），文本内容，音视频，图片，表单，表格…… 标签语义化为什么 利于SEO优化（也就是搜索引擎的抓取，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重）； 在样式丢失的时候，还是可以比较好的呈现结构； 更好的支持各种终端，例如无障碍阅读和有声小说等； 利于团队开发和维护，W3C给我们定了一个标准，那么团队中都遵循这个标准，那么代码的差异就会缩小，在开发和维护的时候就可以提高效率 怎么做 尽量减少使用无意义标签，例如span和div； 尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 表格搭建时，使用&lt;thead&gt;表格头部&lt;/thead&gt; &lt;tbody&gt;表格身体&lt;/tbody&gt; &lt;tfoot&gt;表格尾部&lt;/tfoot&gt;； 列表搭建时，使用&lt;ul&gt;无序列表&lt;/ul&gt; &lt;ol&gt;有序列表&lt;/ol&gt; &lt;dl&gt;定义列表&lt;/dl&gt;]]></content>
      <categories>
        <category>HTML</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>html</tag>
      </tags>
  </entry>
</search>
